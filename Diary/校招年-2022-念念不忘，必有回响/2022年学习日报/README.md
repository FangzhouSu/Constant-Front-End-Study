- 新年新气象！
  - 为了回报JD智慧城市部前端大大的信任！
  - 为了今年春招暑期实习的时候可以拿到心仪大厂的offer！
  - 为了今年八月份校招提前批的时候可以从容不迫！
- 请努力！

> 2022/1
>
> - 更加扎实的**前端三件套基础知识**，尤其注意JS高级部分的学习
>   - 红宝书
> - 认真对待一月份的实习生活，努力提升自我！
>   - 多向组里的前辈们学习，开阔视野！
>   - 争取参与到JD的开源项目中！
>   - 避免几个月的实习过后还无法更新简历
> - **计算机网络**继续看书-网络是怎样连接的、图解HTTPの二刷
> - 加强**刷算法**的强度，认真对待每次周赛！

# 1.1

元旦找**宝贝颖♥**一起吃个饭，过个元旦，背背毛概

但是！在外学习还是没在正确的学习效率上！1.2得抓紧时间复习了啊！！

```js
Totally 240min
1.前端开发学习
    1.1 前端基础学习 min 
		/*  */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 数据库&毛概 190min
		/*  */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 20min	
    	/* 考试期间 就做一下每日一题就好了 
        一维数组转二维 除了暴力解 用了个更好的方法 一次复制一行的内容到二维数组中*/
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
    	// 21/12/15更：总结啥的可以少一些 但是要多写题、多敲代码！代码敲太少了啊！
    	// 21/12/27更：假期去实习学习前端开发的同时，别忘了每天刷每日一题+HOT100+剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没做出来，马上把错误思路放在一边然后去看题解的正确思路，不要走偏！
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4.1 项目开发-Vue 30min
    	/* 总结项目还需要完成的内容 */
```

> 学习顺序预告——日积月累，稳步提升！——等项目完事儿之后再分配下比例！
>
> - 力扣每日一题 5% `已完成`
> - 期末考试内容复习 数据库+毛概 45+40% ==未完成==
> - 外包项目 收尾！10% `已完成`
> - bonus time - React学习 简单瞅瞅文档然后撸项目！前辈建议直接看文档~  ==未完成==

- [x] 总结项目还需要完成的内容
- [ ] 毛概复习
- [x] 数据库复习
- [x] 一道数组(每日一题)

## 1.前端基础

# 1.2

梦回初中 躺在床上刷漫画刷到五点 睡了三四个小时上午继续刷 把金坎比大大的《家》硬是给刷完了。。。快乐之后就是空虚呐，一狠之下卸载了咚漫，ta太懂营销勒，，

下午效率提上来吧，别再做无意义的时间浪费勒！

下午晚上效率还不赖~今天一点前睡觉咯！

```js
Totally 520min
1.前端开发学习
    1.1 前端基础学习 10min 
		/* 看了看可视化的内容 之后有时间玩一玩~ */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 数据库&毛概 100+200min
		/* 数据库给的时间太少了 明天全力肝起来！！ */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 140min	
    	/* 一个不是很难想的medium 390消除游戏 结果卡在一个bug上有八十分钟。。一度对自己的for循环操作产生怀疑
        后来发现暴力模拟还不行XD 下回规定时间内没想出来就换题吧~*/
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
    	// 21/12/15更：总结啥的可以少一些 但是要多写题、多敲代码！代码敲太少了啊！
    	// 21/12/27更：假期去实习学习前端开发的同时，别忘了每天刷每日一题+HOT100+剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.做项目
    4.1 项目开发-Vue 70min
    	/* debug */
```

> 学习顺序预告——日积月累，稳步提升！——等项目完事儿之后再分配下比例！
>
> - 力扣每日一题 5% `超额完成` 建议一题卡住了就去题解区换换思维~
> - 期末考试内容复习 数据库+毛概 40+40% ==未完成==
> - 外包项目 收尾！10% `已完成`
> - bonus time - React学习 `放假再说`

- [x] 项目debug
- [x] 毛概复习
- [x] 数据库复习
- [x] 每日一题

## 1.前端基础

# 1.3

八点多睁眼 然后倒头继续睡到十一点多，算是补了昨天的觉了吧！

今天依旧是靠下午的高效了~

```js
Totally 500min
1.前端开发学习
    1.1 前端基础学习 30min 
		/* 复习了下给图片加边框的两种方法 一种给img加 一种给div加background-img并且设置background-size与盒子的width height
        外边距合并问题
        前端闲聊~*/

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 数据库&毛概 320+40min
		/* 疯狂复习~ */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 110min	
    	/* 今天又没顶住！看了一眼官方答案后又纠结上了！不好！明天一定要遵守这个15/30分钟守则！ */
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
    	// 21/12/15更：总结啥的可以少一些 但是要多写题、多敲代码！代码敲太少了啊！
    	// 21/12/27更：假期去实习学习前端开发的同时，别忘了每天刷每日一题+HOT100+剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.做项目
    4.1 项目开发-Vue min
    	/*  */
```

> 学习顺序预告——日积月累，稳步提升！
>
> - 力扣每日一题 5% `超额完成` 建议一题卡住了就去题解区换换思维~
> - 期末考试内容复习 数据库+毛概 60+30% ==未完成==
> - bonus time - React学习 `放假再说`

- [x] 毛概复习
- [x] 数据库复习
- [x] 每日一题

## 1.前端基础

#### 复习了下给图片加边框的两种方法

 一种给img加 一种给div加background-img并且设置background-size与盒子的width height

![image-20220103161708924](https://gitee.com/su-fangzhou/blog-image/raw/master/202201031617087.png)

# 1.4

依旧是晚睡晚起的一天

靠下午咯~干就完了！

最近的低效。。。难顶啊。。。希望能通过今天早睡来缓解一下吧！

```js
Totally 500min
1.前端开发学习
    1.1 前端基础学习 min 
		/*  */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 数据库复习+考试&毛概 360+140min
		/* 疯狂复习~ */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode min	
    	/*  */
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
    	// 21/12/15更：总结啥的可以少一些 但是要多写题、多敲代码！代码敲太少了啊！
    	// 21/12/27更：假期去实习学习前端开发的同时，别忘了每天刷每日一题+HOT100+剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.做项目
    4.1 项目开发-Vue min
    	/*  */
```

> 学习顺序预告——日积月累，稳步提升！——等项目完事儿之后再分配下比例！
>
> - 力扣每日一题 5% hard 拜拜了您嘞~
> - 期末考试内容复习 数据库+毛概 60+30% ==未完成==
> - bonus time - React学习 `放假再说`

- [x] 毛概复习
- [x] 数据库复习
- [x] 每日一题

## 1.前端基础

# 1.5

考完大三上最后一科——毛概！

出考场昨晚核酸检测之后疯狂地放纵了一把，出去请朋友们恰了一顿涮羊肉（说好了找到实习了请大家吃饭哈哈哈）然后回寝室开始王者上（掉）大分，简单收拾了下寝室，收拾了行李（欸毕竟得有三四个月回不来呢）

那么 电子科技大学 下学期再见咯！

```js
Totally 360min
1.前端开发学习
    1.1 前端基础学习 min 
		/*  */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 毛概复习+考试&网安法期末大作业 300+60min
		/* 疯狂复习+考试
        还有网安法导论的作业 麻了嗷*/

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode min	
    	/* 今天浪大了 没写orz */
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
    	// 21/12/15更：总结啥的可以少一些 但是要多写题、多敲代码！代码敲太少了啊！
    	// 21/12/27更：假期去实习学习前端开发的同时，别忘了每天刷每日一题+HOT100+剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.做项目
    4.1 项目开发-Vue min
    	/*  */
```

> 学习顺序预告——日积月累，稳步提升！——等项目完事儿之后再分配下比例！
>
> - 力扣每日一题 5%
> - 期末考试完事儿~ 
> - 收拾东西 恰个饭
> - bonus time - React学习 `放假再说`

- [x] 毛概复习
- [x] 网安法导论作业

## 1.前端基础

# 1.6 *放假回家咯！调整下作息，恢复健身节奏！

回家折腾得好累啊！晚上美美地吃了一顿之后没啥精神了就 加上忙活租房子的事情 焦头烂额哦！

```js
Totally 210min
1.前端开发相关知识学习
    1.1 前端基础学习 min 
		/*  */
    1.2 React框架复习 min
    	/*  */

2.学习核心基础知识
	2.1 计网 50min
    	/* 复习了下HTTP协议的内容，思考了下网络包的收发过程 */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 40min	
    	/* 每日一题 栈相关 */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 120min
    	/* 肝进度 玩一玩时间控件 */
```

- [x] 每日一题
- [ ] React开冲！！——没冲起来orz
- [x] 外包项目

## 1.前端基础



# 1.7

回家以后依旧起不来 哦耶~

今天不管项目啥情况都要早睡了 特么的再不早睡早起人没了！

```js
Totally 460min
1.前端开发相关知识学习
    1.1 前端基础学习 60min 
		/* 隐式类型转换又一次被唤醒了！
        另外考虑了一下*/
    1.2 React框架复习 250min
    	/* 学习react 脚手架出了一些难以解决的问题，最后用npx解决了
        简单复习了一下react 技术胖的课程跨度真大 要不是我有基础 就很难听懂了orz 明天把react基础看完 看看redux 再过一遍文档吧 */

2.学习核心基础知识
	2.1 计网 min
    	/*  */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 20min	
    	/* 每日一题 括号相关easy题 */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 130min
    	/* 继续推进进度咯~地图上的一些交互问题 以及接口联调 */
```

- [x] 每日一题
- [x] 前端基础复习
- [x] React开冲 好想学react啊啊啊啊啊
- [x] 外包项目继续肝进度

## 1.前端基础

#### 隐式类型转换复习

[由一道面试题引入的对JavaScript隐式转换的学习 - 掘金 (juejin.cn)](https://juejin.cn/post/7022837573059870727)

# 1.8 *加入cxr的催学社~

早睡早起第一天~十二点多到八点半的睡眠 舒服了~

希望今天可以更早嘞

外出玩耍较多得一天 下午效率也差了些

行啊 当是放松了吧！

```js
Totally 300min
1.前端开发相关知识学习
    1.1 前端基础学习 min 
		/*  */
    1.2 React框架复习 140min
    	/* 复习react生命周期 
    	今天把react基础看完 看看redux 再过一遍尚硅谷笔记吧 */

2.学习核心基础知识
	2.1 计网 min
    	/*  */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode min	
    	/*  */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 160min
    	/* 继续debug 好多bug啊 orz */
```

- [x] 每日一题 
- [x] 继续学习React Redux
- [x] 外包项目继续肝进度

## 1.前端基础

#### class类组件的绑定this

[事件处理 – React (docschina.org)](https://react.docschina.org/docs/handling-events.html)

如果**回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染**。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。

![image-20220108174355407](https://gitee.com/su-fangzhou/blog-image/raw/master/202201081743478.png)

#### 不推荐使用index来作为索引！

[列表 & Key – React (docschina.org)](https://react.docschina.org/docs/lists-and-keys.html#keys)

一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：

```jsx
const todoItems = todos.map((todo) =>
  <li key={todo.id}>    
	{todo.text}
  </li>
);
```

当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：

```jsx
const todoItems = todos.map((todo, index) =>
  // Only do this if items have no stable IDs 
  <li key={index}>    
	{todo.text}
  </li>
);
```

如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会**导致性能变差**，还可能引起**组件状态的问题**。可以看看 Robin Pokorny 的[深度解析使用索引作为 key 的负面影响](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318)这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。

要是你有兴趣了解更多的话，这里有一篇文章[深入解析为什么 key 是必须的](https://react.docschina.org/docs/reconciliation.html#recursing-on-children)可以参考。

> 在子元素列表末尾新增元素时，更新开销比较小。比如：
>
> ```jsx
> <ul>
>   <li>first</li>
>   <li>second</li>
> </ul>
> 
> <ul>
>   <li>first</li>
>   <li>second</li>
>   <li>third</li>
> </ul>
> ```
>
> React 会先匹配两个 `<li>first</li>` 对应的树，然后匹配第二个元素 `<li>second</li>` 对应的树，最后插入第三个元素的 `<li>third</li>` 树。
>
> 如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：
>
> ```jsx
> <ul>
>   <li>Duke</li>
>   <li>Villanova</li>
> </ul>
> 
> <ul>
>   <li>Connecticut</li>
>   <li>Duke</li>
>   <li>Villanova</li>
> </ul>
> ```
>
> React 并不会意识到应该保留 `<li>Duke</li>` 和 `<li>Villanova</li>`，而是会重建每一个子元素。这种情况会带来性能问题。

为了解决上述问题，React 引入了 `key` 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 `key` 之后，使得树的转换效率得以提高：

```jsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

现在 React 知道只有带着 `'2014'` key 的元素是新元素，带着 `'2015'` 以及 `'2016'` key 的元素仅仅移动了。

实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：

```jsx
<li key={item.id}>{item.name}</li>
```

当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。



最后，你也可以使用元素在数组中的下标**index**作为 key。这个策略在元素不进行重新排序时比较合适，如果有**顺序修改**，diff 就会变慢。

当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么**修改顺序时会修改当前的 key**，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。

# 1.9 *折腾指数拉满的一天 呼哧呼哧

经历了人生最漫长的一次塞车，疫情是真的太折磨了啊！

八点出门，十点在京沪高速上堵住，下午两点半还堵在距离检查口1KM的地方，，一直到七点半才过了安全检查

然后！因为疫情原因 天津滴同学不让进公司~

明天看看能不能办个远程入职了~

```js
Totally 170min
1.前端开发相关知识学习
    1.1 前端基础学习 10min 
		/* 复习了下闭包的概念 闭包是在预编译阶段就生成的对象（感觉也可以理解成函数哈） */
    1.2 React框架复习 150min
    	/* 看看掘金博文 */

2.学习核心基础知识
	2.1 计网 min
    	/*  */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 10min	
    	/* 每日一题 */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue min
    	/* */
```

- [ ] 每日一题 
- [x] 学习react HOOKS
- [ ] 拉一个项目下来 对照着看看redux react-router的内容
- [ ] 外包项目继续肝进度

## 1.前端基础

### React

[大神绘图 React 生命周期](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)点击生命周期即可跳转官网解读

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c7b704f45fd435cb4ec579e8f0038ee~tplv-k3u1fbpfcp-watermark.awebp)

# 1.10 *开始（远程）实习—集中精力，全力学习！

天津人很难过地不能进公司😢

但还好！12号进行一波远程入职！leader大大也已经给了学习资料 那么——

准备开工！！

```js
Totally 430min
1.前端开发相关知识学习
    1.1 前端基础学习 280min 
		/* 明确下远程入职的问题，接到leader给出的学习任务，开工！
        */
    1.2 React框架复习 min
    	/*  */

2.学习核心基础知识
	2.1 计网 min
    	/*  */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode min	
    	/*  */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 21/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 150min
    	/* 解决一些细节问题 修改子区区域重合验证中涉及得bug */
```

- [ ] 每日一题 没搞完 直接抄了 反省下！
- [x] 学习react HOOKS
- [ ] 加入团队前的学习——
  - [x] 代码规范 看六小节
  - [x] 分支管理规范 第一章 & 2.1小节
  - [ ] `TodoMVC demo` by React —— 这里今天木有看呐~时间管理有问题欸！反省下！
- [x] 外包项目继续肝进度
- [ ] 每日睡前总结——睡前状态稀碎！反省下！

## 1.实习日常

### 今日工作内容

#### 学习了集中式工作流；

> `Git`很赞的一点是，任何人可以解决他自己的冲突。在这个例子中，小红可以简单的运行[`git status`](https://www.atlassian.com/git/tutorial/git-basics#!status)命令来查看哪里有问题。 冲突文件列在`Unmerged paths`（未合并路径）一节中：
>
> ```
> # Unmerged paths:
> # (use "git reset HEAD <some-file>..." to unstage)
> # (use "git add/rm <some-file>..." as appropriate to mark resolution)
> #
> # both modified: <some-file>
> ```
>
> 接着小红编辑这些文件。修改完成后，用老套路暂存这些文件，并让[`git rebase`](https://www.atlassian.com/git/tutorial/rewriting-git-history#!rebase)完成剩下的事：
>
> ```
> git add <some-file> 
> git rebase --continue
> ```
>
> 要做的就这些了。`Git`会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。
>
> 如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行[`git pull --rebase`](https://www.atlassian.com/git/tutorial/remote-repositories#!pull)命令前的样子：
>
> ```
> git rebase --abort
> ```

个人感觉我这两天和同学一起进行的团队开发就是使用的集中式工作流（两个人分别开发 在push之前pull一下，有问题改一下冲突再pull，最后push，完成当日工作），但是没有用到rebase这个高级一些的操作——

> 小红用[`git pull`](https://www.atlassian.com/git/tutorial/remote-repositories#!pull)合并上游的修改到自己的仓库中。 这条命令类似`svn update`——拉取所有上游提交命令到小红的本地仓库，并尝试和她的本地修改合并：
>
> ```
> git pull --rebase origin master
> ```
>
> `--rebase`选项告诉`Git`把小红的提交移到同步了中央仓库修改后的`master`分支的顶部，如下图所示：
>
> [![img](https://github.com/xirong/my-git/raw/master/images/git-workflow-svn-6.png)](https://github.com/xirong/my-git/blob/master/images/git-workflow-svn-6.png)
>
> 如果你忘加了这个选项，`pull`操作仍然可以完成，但每次`pull`操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。 对于集中式工作流，最好是使用`rebase`而不是生成一个合并提交。

#### 学习了一些团队JS规范

#####  [3.对象](https://github.com/lin-123/javascript#对象)

- [3.2](https://github.com/lin-123/javascript#es6-computed-properties) 使用计算属性名创建一个带有动态属性名的对象。

  > 这里我一直都是用的bad的方法创建动态属性呐，，，
  >
  > 之后要把动态属性写到对象里头来~

  > 为什么？因为这可以使你在同一个地方定义所有对象属性。

  ```js
  function getKey(k) {
    return `a key named ${k}`;
  }
  
  // bad
  const obj = {
    id: 5,
    name: 'San Francisco',
  };
  obj[getKey('enabled')] = true;
  
  // good
  const obj = {
    id: 5,
    name: 'San Francisco',
    [getKey('enabled')]: true,
  };
  ```

- [3.7](https://github.com/lin-123/javascript#objects--prototype-builtins) 不要直接调用 `Object.prototype`上的方法，如 `hasOwnProperty`、`propertyIsEnumerable`、`isPrototypeOf`。

  > 这个best操作太高级了orz 想不到啊这个！

  > 为什么？在一些有问题的对象上，这些方法可能会被屏蔽掉，如：`{ hasOwnProperty: false }` 或空对象 `Object.create(null)`

  ```js
  // bad
  console.log(object.hasOwnProperty(key));
  
  // good
  console.log(Object.prototype.hasOwnProperty.call(object, key));
  
  // best
  const has = Object.prototype.hasOwnProperty; // 在模块作用域内做一次缓存。
  console.log(has.call(object, key));
  /* or */
  import has from 'has'; // https://www.npmjs.com/package/has
  console.log(has(object, key));
  ```

- 3.8 对象浅拷贝时，更推荐使用扩展运算符（即`...`运算符），而不是`Object.assign`。获取对象指定的几个属性时，用对象的 rest 解构运算符（即`...`运算符）更好。eslint:`prefer-object-spread`
  - 这一段不太好翻译出来， 大家看下面的例子就懂了。`^.^`

```js
// very bad 
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
// 这样子写会导致基本的浅拷贝都无法完成——删除a之后会把a也删掉，所以还是不要用assign做浅拷贝的好~
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

// good es6 扩展运算符 ...
const original = { a: 1, b: 2 };
// 浅拷贝
const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }

// rest 解构运算符——获取对象指定的几个属性——           简单的解构，极致滴享受~
const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
```

##### [4.数组](https://github.com/lin-123/javascript#数组)

- [4.6](https://github.com/lin-123/javascript#arrays--mapping) 用 [`Array.from`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 而不是 `...` 运算符==去做 map 遍历==。 因为这样可以==避免创建一个临时数组==。

  > 涨知识了！原来[`Array.from`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)方法里还可以放一个回调函数！
  >
  > 这个方法可以很高效地做数组遍历呐！
  >
  > ```js
  > Array.from(arrayLike[, mapFn[, thisArg]])
  > ```
  >
  > ### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from#参数)
  >
  > - `arrayLike`
  >
  >   想要转换成数组的伪数组对象或可迭代对象。
  >
  > - `mapFn` 可选
  >
  >   如果指定了该参数，新数组中的每个元素会执行该回调函数。
  >
  > - `thisArg` 可选
  >
  >   可选参数，执行回调函数 `mapFn` 时 `this` 对象。
  >
  > ### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from#返回值)
  >
  > 一个新的[`数组`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)实例。

  ```js
  // bar为回调函数（遍历的规则）
  // bad
  const baz = [...foo].map(bar);
  
  // good
  const baz = Array.from(foo, bar);
  ```

##### [5.解构](https://github.com/lin-123/javascript#解构)

- [5.1](https://github.com/lin-123/javascript#destructuring--object) 用对象的解构赋值来获取和使用对象某个或多个属性值。eslint: [`prefer-destructuring`](https://eslint.org/docs/rules/prefer-destructuring)

  > 解构赋值的好处——
  >
  > 为什么？解构使您**不必**为这些属性**创建临时引用**，并且**避免重复引用对象**。重复引用对象将造成代码重复、增加阅读次数、提高犯错概率。
  >
  > Destructuring objects also provides a single site of definition of the object structure that is used in the block, rather than requiring reading the entire block to determine what is used.

  ```js
  // bad
  function getFullName(user) {
    const firstName = user.firstName;
    const lastName = user.lastName;
  
    return `${firstName} ${lastName}`;
  }
  
  // good
  function getFullName(user) {
    const { firstName, lastName } = user;
    return `${firstName} ${lastName}`;
  }
  
  // best 这个方法有点秀啊，，没见到过这么用的 学习了嘿嘿
  function getFullName({ firstName, lastName }) {
    return `${firstName} ${lastName}`;
  }
  ```





## 2.前端基础

# 1.11

凌晨三点才躺下睡觉，，早上九点爬起来还是挺懵的，从今天开始立个早睡flag吧！

下午人力资源部门的姐姐给打来电话落实了电脑邮寄的问题~

今天虽然学习状态没提升起来 但是对于学习日程的规划逐渐清晰了！

```js
Totally 380min
1.前端开发相关知识学习
	// 每天9:00之前在催学社、校招收割群issue区打卡
    1.1 前端基础学习 270min 
		/* 继续学习代码规范问题 学习功能分支工作流
		更新学习总结方式
        */
    1.2 React复习 min
    	/*  */

2.学习核心基础知识
	2.1 计网 min
    	/*  */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 20min	
    	/* 复习了异或算法 复习了一下排序算法 */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 22/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 90min
    	/* 继续改bug 改了一下提交表单时的数据暂存格式 */
```

> 学习时的状态：关闭所有社交软件+手机打开番茄钟

- [x] 每日一题 (困难直接抄了 换一题) + HOT100重新开刷 + 小册复习

- [ ] 加入团队前的学习——

  - [x] 复盘昨日学习内容

  - [x] 代码规范 复习昨日内容+再看六小节

  - [x] 分支管理规范 看2.2小节 

  - [ ] `TodoMVC demo` by React ——阅读react源码，查询不懂的地方，模仿代码风格，尝试仿写（啊 今日工作又没完成）

      回头使用**`gitflow`工作流**模拟多协作者开发流程

- [x] 外包项目继续肝进度

- [x] 每日睡前（尽量在23点30之前）总结——刷题+工作内容+基础知识

## 1.实习日常

### 昨日工作复盘

- 学习了集中式工作流 其实就是很常规的一种分支管理方法，没有啥复杂的操作 我之前协作开发项目都是使用的这种模式（当然回头还得细化下这个概念！）

- 学习了JS代码规范

  - 对象相关

    - 有一个==存疑==点 对象中属性什么时候加单引号？

  - 数组相关

    - 要熟练使用扩展运算符`...`
    - map遍历的最佳实践—— `Array.from(arr, mapFn)`

  - 解构的优点

    - 不必为属性创建临时引用

    - 避免重复引用对象

      - 所以——直接解构对象即可~

      ```js
      // bad
      function getFullName(user) {
        const firstName = user.firstName;
        const lastName = user.lastName;
      
        return `${firstName} ${lastName}`;
      }
      
      // good
      function getFullName(user) {
        const { firstName, lastName } = user;
        return `${firstName} ${lastName}`;
      }
      
      // best 这个方法有点秀啊，，没见到过这么用的 学习了嘿嘿
      function getFullName({ firstName, lastName }) {
        return `${firstName} ${lastName}`;
      }
      ```

### 今日工作内容

#### 学习了[功能分支工作流](https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md#22-%E5%8A%9F%E8%83%BD%E5%88%86%E6%94%AF%E5%B7%A5%E4%BD%9C%E6%B5%81)

> 功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用`Pull Requests`的方式**讨论**变更。
>
> [![img](https://github.com/xirong/my-git/raw/master/images/git-workflow-feature-branch-1.png)](https://github.com/xirong/my-git/blob/master/images/git-workflow-feature-branch-1.png)
>
> - PR操作
>
> 功能分支除了可以隔离功能的开发，也使得通过[`Pull Requests`](https://github.com/xirong/my-git/blob/master/pull-request.md)讨论变更成为可能。 一旦某个开发者完成一个功能，不是立即合并到`master`，而是`push`到中央仓库的功能分支上并发起一个`Pull Request`请求，将修改合并到`master`。 在修改成为主干代码前，这让其它的开发者有机会先去`Review`变更。
>
> **`Code Review`**是`Pull Requests`的一个重要的收益，而`Pull Requests`则是讨论代码的一个通用方式。 你可以把`Pull Requests`作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行`Code Review`。 比如，一个开发者开发功能需要帮助时，要做的就是发起一个`Pull Request`，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。
>
> **一旦`Pull Request`被接受了，发布功能要做的就和集中式工作流就很像了**。
>
> 首先，确定本地的`master`分支和上游的`master`分支是同步的。然后合并功能分支到本地`master`分支并`push`已经更新的本地`master`分支到中央仓库。

我们之前做的外包项目就是这样一个流程 但是很尴尬的是，小组成员都不太会进行pr，大家的版本乱作一团，于是换成了集中式工作流😂

下面看个例子学习下功能分支工作流的操作流程

> [my-git/git-workflow-tutorial.md at master · xirong/my-git (github.com)](https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md#223-示例)
>
> > 下面这里是个关键，检查完功能分支的代码无误之后，进行**PR操作**——
>
> 一旦小黑可以的接受`Pull Request`，就可以合并功能到稳定项目代码中（可以由小黑或是小红来做这个操作）：
>
> ```
> git checkout master
> git pull
> git pull origin marys-feature
> git push
> ```
>
> 无论谁来做合并，首先要检出`master`分支并确认是它是最新的。然后执行`git pull origin marys-feature`**合并`marys-feature`分支到和已经和远程一致的本地`master`分支**。 你可以使用简单`git merge marys-feature`命令，但前面的命令可以保证总是最新的新功能分支。 最后更新的`master`分支要重新`push`回到`origin`。
>
> 这个过程常常会生成一个合并提交。有些开发者喜欢有合并提交，因为它像一个新功能和原来代码基线的连通符。 但==如果你偏爱线性的提交历史，可以在执行合并时`rebase`新功能到`master`分支的顶部，这样生成一个快进（`fast-forward`）的合并==（这里每台搞懂啥意思 rebase的概念有必要的话还得再看看）。
>
> 一些`GUI`客户端可以只要点一下『接受』按钮执行好上面的命令来自动化`Pull Request`接受过程。 如果你的不能这样，至少在功能合并到`master`分支后能自动关闭`Pull Request`。

> 当小红和小黑在`marys-feature`上工作并讨论她的`Pull Request`的时候，小明在自己的功能分支上做完全一样的事。
>
> 通过隔离功能到独立的分支上，每个人都可以自主的工作，当然必要的时候在开发者之间分享变更还是比较繁琐的。
>
> 到了这里，但愿你发现了功能分支可以很直接地在 `集中式工作流` 的仅有的`master`分支上完成多功能的开发。 另外，功能分支还使用了`Pull Request`，使得可以在你的版本控制`GUI`客户端中讨论某个提交。
>
> 功能分支工作流是开发项目异常灵活的方式。**问题是，有时候太灵活了**。对于大型团队，常常需要给不同分支分配一个更具体的角色。接下来要学习的 `Gitflow`工作流是管理功能开发、发布准备和维护的常用模式。

#### 学习了一些JS规范

#### [7.函数](https://github.com/lin-123/javascript#函数)

- [7.1](https://github.com/lin-123/javascript#functions--declarations) 使用命名函数表达式而不是函数声明。eslint: [`func-style`](http://eslint.org/docs/rules/func-style)

  > 函数表达式： `const func = function () {}` √

  > 函数声明： `function func () {}` ×

  > 为什么？函数声明会发生提升，这意味着在一个文件里函数很容易在其被定义之前就被引用了。这样伤害了代码可读性和可维护性。如果你发现一个函数又大又复杂，且这个函数妨碍了这个文件其他部分的理解性，你应当单独把这个函数提取成一个单独的模块。不管这个名字是不是由一个确定的变量推断出来的，别忘了**给表达式清晰的命名**（好==追踪错误==（这里不太理解来着）一些）（这在现代浏览器和类似 babel 编译器中很常见）。这消除了由匿名函数在错误调用栈产生的所有假设。 ([讨论](https://github.com/airbnb/javascript/issues/794))

  > 译者注：这一段可能不是很好理解，简单来说就是**使用函数声明会发生提升**（即在函数被声明之前就可以使用），**使用匿名函数会导致难以追踪错误**。[这一段英文原文在这](https://github.com/airbnb/javascript#functions)。

  ```js
  // bad
  function foo() {
    // ...
  }
  
  // bad
  const foo = function () {
    // ...
  };
  
  // good
  // lexical name distinguished from the variable-referenced invocation(s)
  // 函数表达式名和声明的函数名是不一样的
  const short = function longUniqueMoreDescriptiveLexicalFoo() {
    // ...
  };
  ```

- [7.2](https://github.com/lin-123/javascript#functions--iife) 把立即执行函数包裹在圆括号里。eslint: [`wrap-iife`](http://eslint.org/docs/rules/wrap-iife.html)

  > 复习下立即执行函数 Immediately Invoked Function expression 的概念——让函数立即被调用

  > 立即执行函数：Immediately Invoked Function expression = IIFE。 为什么？一个立即调用的函数表达式是一个单元 - 把它和它的调用者（圆括号）包裹起来，使代码读起来更清晰。 另外，在模块化世界里，你几乎用不着 IIFE。

  ```js
  // immediately-invoked function expression (IIFE)
  (function () {
    console.log('Welcome to the Internet. Please follow me.');
  }());
  ```

- [7.6](https://github.com/lin-123/javascript#es6-rest) 不要使用 `arguments`，用收集参数语法 `...` 代替。eslint: [`prefer-rest-params`](http://eslint.org/docs/rules/prefer-rest-params)

  > 为什么？`...` 明确你想用哪个参数。而且==收集参数args是真数组==，而不是类似数组的 `arguments`。
  >
  > > ## [类数组（Array-like）对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#array-like)
  > >
  > > `slice` 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。 一个函数中的 [`arguments`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments) 就是一个类数组对象的例子。
  > >
  > > ```js
  > > function list() {
  > > return Array.prototype.slice.call(arguments);
  > > }
  > > 
  > > var list1 = list(1, 2, 3); // [1, 2, 3]
  > > ```
  > >
  > > 除了使用 `Array.prototype.slice.call(``arguments``)`，你也可以简单的使用 `[].slice.call(arguments)` 来代替。

  ```js
  // bad
  function concatenateAll() {
    const args = Array.prototype.slice.call(arguments);
    return args.join('');
  }
  
  // good
  function concatenateAll(...args) {
    return args.join('');
  }
  ```

- [7.7](https://github.com/lin-123/javascript#es6-default-parameters) 用默认参数语法而不是在函数里对参数重新赋值。

  > 如果需要给某个参数赋一个默认值的话 建议使用默认参数语法 `function handleThings(opts = {}) {}`
  >
  > 参数重新赋值会导致意外行为，尤其是对 `arguments`。这也会导致优化问题，特别是在 V8 引擎里。

  ```js
  // really bad
  function handleThings(opts) {
    // 不！我们不该修改 arguments
    // 第二：如果 opts 的值为 false, 它会被赋值为 {}
    // 虽然你想这么写，但是这个会带来一些微妙的 bug。
    opts = opts || {};
    // ...
  }
  
  // still bad
  function handleThings(opts) {
    if (opts === void 0) {
      opts = {};
    }
    // ...
  }
  
  // good
  function handleThings(opts = {}) {
    // ...
  }
  ```

- [7.9](https://github.com/lin-123/javascript#functions--defaults-last) 另外建议**把默认参数赋值放在最后**。eslint: [`default-param-last`](https://eslint.org/docs/rules/default-param-last)

  ```js
  // bad
  function handleThings(opts = {}, name) {
    // ...
  }
  
  // good
  function handleThings(name, opts = {}) {
    // ...
  }
  ```

- [7.11](https://github.com/lin-123/javascript#functions--signature-spacing) 函数定义部分要有空格。eslint: [`space-before-function-paren`](http://eslint.org/docs/rules/space-before-function-paren) [`space-before-blocks`](http://eslint.org/docs/rules/space-before-blocks)

  > 为什么？**统一性好**，而且在你**添加/删除一个名字**（下面例子中的a）的时候**不需要添加/删除空格**，很方便啦~。

  ```js
  // bad
  const f = function(){};
  const g = function (){};
  const h = function() {};
  
  // good
  const x = function () {};
  const y = function a() {};
  ```

#### [8.箭头函数](https://github.com/lin-123/javascript#箭头函数)

- [8.3](https://github.com/lin-123/javascript#arrows--paren-wrap) 如果表达式涉及多行，把他包裹在圆括号里以**提高可读性**。

  > 这里确实经常被我忽略！加上了括号确实好读很多！

  > 为什么？这样能清晰地**显示函数的开始位置和结束位置**。

  ```js
  // bad
  ['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call(
      httpMagicObjectWithAVeryLongName,
      httpMethod
    )
  );
  
  // good
  ['get', 'post', 'put'].map(httpMethod => (
    Object.prototype.hasOwnProperty.call(
      httpMagicObjectWithAVeryLongName,
      httpMethod
    )
  ));
  ```

- [8.4](https://github.com/lin-123/javascript#arrows--one-arg-parens) 在箭头函数参数两头，总是使用小括号包裹住参数，这样做使代码更清晰且一致. eslint: [`arrow-parens`](https://eslint.org/docs/rules/arrow-parens.html)

  > 我写箭头函数是有多不规范，，，下次参数只有一个的时候也不要忘记加括号啊！

  > 为什么？当你想要添加或删除参数时能比较省事。

  ```js
  // bad
  [1, 2, 3].map(x => x * x);
  
  // good
  [1, 2, 3].map((x) => x * x);
  
  // bad
  [1, 2, 3].map(number => (
    `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`
  ));
  
  // good
  [1, 2, 3].map((number) => (
    `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`
  ));
  ```

- [8.5](https://github.com/lin-123/javascript#arrows--confusing) 避免箭头函数（`=>`）和比较操作符（`<=`, `>=`）混淆. eslint: [`no-confusing-arrow`](http://eslint.org/docs/rules/no-confusing-arrow)

  > 这里之前也没主要到（也没碰到过）
  >
  > 之后在箭头函数中使用大于等于号和小于等于号时要加上**括号/大括号**来避免混淆

  ```js
  // bad
  const itemHeight = (item) => item.height <= 256 ? item.largeSize : item.smallSize;
  
  // bad
  const itemHeight = (item) => item.height >= 256 ? item.largeSize : item.smallSize;
  
  // good
  const itemHeight = (item) => (item.height <= 256 ? item.largeSize : item.smallSize);
  
  // good
  const itemHeight = (item) => {
    const { height, largeSize, smallSize } = item;
    return height <= 256 ? largeSize : smallSize;
  };
  ```

#### [9.类与构造函数](https://github.com/lin-123/javascript#类与构造函数)

- [9.1](https://github.com/lin-123/javascript#constructors--use-class) 使用 `class` 语法。避免直接操作 `prototype`。

  > 为什么？`class` 语法更简洁更易理解。

  ```js
  // bad
  function Queue(contents = []) {
    this.queue = [...contents];
  }
  Queue.prototype.pop = function () {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
  };
  
  // good
  class Queue {
    constructor(contents = []) {
      this.queue = [...contents];
    }
    pop() {
      const value = this.queue[0];
      this.queue.splice(0, 1);
      return value;
    }
  }
  ```

- 如果未声明构造函数，则类会有一个默认的构造函数，没必要用空的构造函数或者将其委托给父类，eslint: [no-useless-constructor](http://eslint.org/docs/rules/no-useless-constructor)

```js
// bad
class Jedi {
  constructor () {}

  getName() {
    return this.name
  }
}

// bad
class Rey extends Jedi {
  constructor (...args) {
    // 这种构造函数是不需要写的
    super(...args)
  }
}

// good
class Rey extends Jedi {
  constructor (...args) {
    super(...args)
    // 如果构造函数中有需要初始化的内容 那么可以写一下~
    this.name = 'Rey'
  }
}
```

#### [10.模块](https://github.com/lin-123/javascript#模块)

- [10.1](https://github.com/lin-123/javascript#modules--use-them) 使用（`import`/`export`）模块而不是非标准的模块系统。你可以随时转到你喜欢的模块系统。

  > 为什么？**模块化是未来，让我们现在就开启未来吧**。

  ```js
  // bad
  const AirbnbStyleGuide = require('./AirbnbStyleGuide');
  module.exports = AirbnbStyleGuide.es6;
  
  // ok
  import AirbnbStyleGuide from './AirbnbStyleGuide';
  export default AirbnbStyleGuide.es6;
  
  // best
  import { es6 } from './AirbnbStyleGuide';
  export default es6;
  ```

- [10.8](https://github.com/lin-123/javascript#modules--multiline-imports-over-newlines) 多行 `import` 应该缩进，就像多行数组和对象字面量一样。

  > 好尴尬 之前项目的引入就是使用的bad的方法，，，

  > 为什么？花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。

  ```js
  // bad
  import {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';
  
  // good
  import {
    longNameA,
    longNameB,
    longNameC,
    longNameD,
    longNameE,
  } from 'path';
  ```

- [10.9](https://github.com/lin-123/javascript#modules--no-webpack-loader-syntax) 在 `import` 语句里不允许 Webpack loader 语法。eslint: [`import/no-webpack-loader-syntax`](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md)

  > 为什么？一旦用 Webpack 语法在 import 里会把代码耦合到模块绑定器。最好是在 `webpack.config.js` 里写 webpack loader 语法

  ```js
  // bad
  import fooSass from 'css!sass!foo.scss';
  import barCss from 'style!css!bar.css';
  
  // good
  import fooSass from 'foo.scss';
  import barCss from 'bar.css';
  ```

#### [11.迭代器与生成器](https://github.com/lin-123/javascript#迭代器与生成器)

- [11.1](https://github.com/lin-123/javascript#iterators--nope) 不要用迭代器。使用 JavaScript 高级函数代替 `for-in`、 `for-of`。eslint: [`no-iterator`](http://eslint.org/docs/rules/no-iterator.html) [`no-restricted-syntax`](http://eslint.org/docs/rules/no-restricted-syntax)

  > 为什么？这强调了我们不可变的规则。 处理返回值的纯函数比处理副作用更容易。

  > 用数组的这些迭代方法： `map()` / `every()` / `filter()` / `find()` / `findIndex()` / `reduce()` / `some()` / ... , 用对象的这些方法 `Object.keys()` / `Object.values()` / `Object.entries()` 去产生一个数组，这样你就能去遍历对象了。

  ```js
  const numbers = [1, 2, 3, 4, 5];
  
  // bad
  let sum = 0;
  for (let num of numbers) {
    sum += num;
  }
  sum === 15;
  
  // good
  let sum = 0;
  numbers.forEach(num => sum += num);
  sum === 15;
  
  // best (use the functional force)
  const sum = numbers.reduce((total, num) => total + num, 0);
  sum === 15;
  
  // bad
  const increasedByOne = [];
  for (let i = 0; i < numbers.length; i++) {
    increasedByOne.push(numbers[i] + 1);
  }
  
  // good
  const increasedByOne = [];
  numbers.forEach(num => increasedByOne.push(num + 1));
  
  // best (keeping it functional) 最好是使用纯函数！
  const increasedByOne = numbers.map(num => num + 1);
  ```

- 生成器的概念~

- [11.2](https://github.com/lin-123/javascript#generators--nope) 现在暂时不要使用生成器。

  > 为什么？生成器目前不能很好地转换为 ES5 语法。

## 2.前端基础

# 1.12 *创建每日一题仓库 *创建self introduction profile *加入UESTC开源社区 *开启“日有所进”专区

早上八点半起来 坐床上玩了半小时手机才起，看来清晨番茄钟很有必要啊~

九点出头开始工作，问题不大（才怪）！

今天是投身（玩儿）开源社区的一天呐！对未来的开发之路动力满满！明天要把重心放在学习上了！

恢复学习状态！兴奋起来了！！

```js
Totally 560min
1.前端开发相关知识学习
	/** 每天开始学习之前在催学社仓库issue区打卡
	 * 每天中午在每日一题仓库issue区打卡
	 * 每天下班之后汇总每日一题答案
	 * 每天睡觉之前总结今日收获
	 */
    1.1 前端基础学习 270+180+30+50min 
		/** 简单学习了一下gitflow工作流 fork工作流 明天还得再过一遍，感觉有点复杂呐！JS代码规范看了十节的内容
         * 每日一题汇总、学习 鲨鱼哥面试指导~打打鸡血 总结下学习路线 把github个人页面介绍做出来
         * 加入UESTC开源社区~玩儿了一下discussion
         * 向老大学习一些经验——要重视基础！多啃文档！
         */
    1.2 React复习 min
    	/*  */

2.学习核心基础知识
	2.1 计网 min
    	/* 搞完鸡儿外包项目腾出时间学习计网~ */

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 30min	
    	/* HOT100-数组一题；每日一题； */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 22/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue min
    	/*  */
```

> 学习时的状态：关闭所有社交软件+手机打开番茄钟

- [x] 每日一题 + HOT100数组专题 + 小册复习

- [ ] 加入团队前的学习——

  - [x] 复盘昨日学习内容

  - [x] 代码规范 复习昨日内容+再看十小节

  - [x] 分支管理规范 看2.3小节 

  - [ ] `TodoMVC demo` by React ——阅读react源码，查询不懂的地方，模仿代码风格，尝试仿写（今天又没写成，，）

      回头使用**`gitflow`工作流**模拟多协作者开发流程

- [x] 总结每日一题+做一下101.对称二叉树

- [ ] 外包项目继续肝进度 今天没来得及做

- [x] 每日睡前（尽量在23点30之前）总结——刷题+工作内容+基础知识 好！十二点半总结的

## 1.实习日常

远程入职第一天~

### 昨日工作复盘

- 学习了功能分支工作流 最后得知这个工作流其实用得不多，不过可以培养一下分支工作流的思想~

  - 以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。这样可以在把新功能集成到正式项目前，用`Pull Requests`的方式**讨论**变更。

    ![git-workflow-feature-branch-1.png](https://github.com/xirong/my-git/blob/master/images/git-workflow-feature-branch-1.png?raw=true)

- PR操作

功能分支除了可以隔离功能的开发，也使得通过[`Pull Requests`](https://github.com/xirong/my-git/blob/master/pull-request.md)讨论变更成为可能。 一旦某个开发者完成一个功能，不是立即合并到`master`，而是`push`到中央仓库的功能分支上并发起一个`Pull Request`请求，将修改合并到`master`。 在修改成为主干代码前，这让其它的开发者有机会先去`Review`变更。

**`Code Review`**是`Pull Requests`的一个重要的收益，而`Pull Requests`则是讨论代码的一个通用方式。 你可以把`Pull Requests`作为专门给某个分支的讨论。这意味着可以在更早的开发过程中就可以进行`Code Review`。 比如，一个开发者开发功能需要帮助时，要做的就是发起一个`Pull Request`，相关的人就会自动收到通知，在相关的提交旁边能看到需要帮助解决的问题。

**一旦`Pull Request`被接受了，发布功能要做的就和集中式工作流就很像了**。

- 功能分支工作流是开发项目异常灵活的方式。**问题是，有时候太灵活了**。对于大型团队，常常需要给不同分支分配一个更具体的角色。接下来要学习的 `Gitflow`工作流是管理功能开发、发布准备和维护的常用模式。

- 使用命名函数表达式 而不是函数声明！ `const short = function longUniqueMoreDescriptiveLexicalFoo()`

  - > **使用函数声明会发生提升**（即在函数被声明之前就可以使用），**使用匿名函数会导致难以追踪错误**。[这一段英文原文在这](https://github.com/airbnb/javascript#functions)。

- 想要获取函数中的参数的话 使用 `...args`

  - ```js
    // bad
    function concatenateAll() {
      const args = Array.prototype.slice.call(arguments);
      return args.join('');
    }
    
    // good
    function concatenateAll(...args) {
      return args.join('');
    }
    ```

- 给函数的参数赋默认值

  - > 如果需要给某个参数赋一个默认值的话 建议使用默认参数语法 `function handleThings(opts = {}) {}`
    >
    > 参数重新赋值会导致意外行为，尤其是对 `arguments`。这也会导致优化问题，特别是在 V8 引擎里。

- [9.1](https://github.com/lin-123/javascript#constructors--use-class) 使用 `class` 语法。避免直接操作 `prototype`。

  > 为什么？`class` 语法更简洁更易理解。

  ```js
  // bad
  function Queue(contents = []) {
    this.queue = [...contents];
  }
  Queue.prototype.pop = function () {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
  };
  
  // good
  class Queue {
    constructor(contents = []) {
      this.queue = [...contents];
    }
    pop() {
      const value = this.queue[0];
      this.queue.splice(0, 1);
      return value;
    }
  }
  ```

- [11.1](https://github.com/lin-123/javascript#iterators--nope) 不要用迭代器。使用 JavaScript 高级函数代替 `for-in`、 `for-of`。eslint: [`no-iterator`](http://eslint.org/docs/rules/no-iterator.html) [`no-restricted-syntax`](http://eslint.org/docs/rules/no-restricted-syntax)

  > 为什么？这强调了我们不可变的规则。 处理返回值的纯函数比处理副作用更容易。

  > 用数组的这些迭代方法： `map()` / `every()` / `filter()` / `find()` / `findIndex()` / `reduce()` / `some()` / ... , 用对象的这些方法 `Object.keys()` / `Object.values()` / `Object.entries()` 去产生一个数组，这样你就能去遍历对象了。

  ```js
  const numbers = [1, 2, 3, 4, 5];
  
  // bad
  let sum = 0;
  for (let num of numbers) {
    sum += num;
  }
  sum === 15;
  
  // good
  let sum = 0;
  numbers.forEach(num => sum += num);
  sum === 15;
  
  // best (use the functional force)
  const sum = numbers.reduce((total, num) => total + num, 0);
  sum === 15;
  
  // bad
  const increasedByOne = [];
  for (let i = 0; i < numbers.length; i++) {
    increasedByOne.push(numbers[i] + 1);
  }
  
  // good
  const increasedByOne = [];
  numbers.forEach(num => increasedByOne.push(num + 1));
  
  // best (keeping it functional) 最好是使用纯函数！
  const increasedByOne = numbers.map(num => num + 1);
  ```

### 今日工作内容

#### [2.3 Gitflow工作流](https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md#23-gitflow%E5%B7%A5%E4%BD%9C%E6%B5%81)

`Gitflow`工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。

#### JS规范

- [15.5](https://github.com/lin-123/javascript#comparison--switch-blocks) 在 `case` 和 `default` 分句里用大括号创建一块包含词法声明的区域（例如：`let`、`const`、`function` 和 `class`）。eslint rules: [`no-case-declarations`](http://eslint.org/docs/rules/no-case-declarations.html).

  > 为什么？词法声明在整个 `switch` 的代码块里都可见，但是只有当其被分配后才会初始化，仅当这个 `case` 被执行时才被初始化。当多个 `case` 分句试图定义同一个对象时就会出现问题。

  ```js
  // bad
  switch (foo) {
    case 1:
      let x = 1;
      break;
    case 2:
      const y = 2;
      break;
    case 3:
      function f() {
        // ...
      }
      break;
    default:
      class C {}
  }
  
  // good
  switch (foo) {
    case 1: {
      let x = 1;
      break;
    }
    case 2: {
      const y = 2;
      break;
    }
    case 3: {
      function f() {
        // ...
      }
      break;
    }
    case 4:
      bar();
      break;
    default: {
      class C {}
    }
  }
  ```


- [15.7](https://github.com/lin-123/javascript#comparison--unneeded-ternary) 避免不必要的三元表达式。eslint rules: [`no-unneeded-ternary`](http://eslint.org/docs/rules/no-unneeded-ternary.html)

  ```js
  // bad
  const foo = a ? a : b;
  const bar = c ? true : false;
  const baz = c ? false : true;
  
  // good
  const foo = a || b;
  const bar = !!c;// c为真 则为true
  const baz = !c;
  ```

- [18.1](https://github.com/lin-123/javascript#comments--multiline) 多行注释用 `/** ... */`。

  > 这里我一般都一整行洋洋洒洒地写注释，这样不好！

  ```js
  // bad
  // make() returns a new element
  // based on the passed in tag name
  //
  // @param {String} tag
  // @return {Element} element
  function make(tag) {
  
    // ...
  
    return element;
  }
  
  // good
  /**
   * make() returns a new element
   * based on the passed-in tag name
   */
  function make(tag) {
  
    // ...
  
    return element;
  }
  ```

  > 这里真的是学习到了！改掉了之前的坏习惯~


- [18.2](https://github.com/lin-123/javascript#comments--singleline) 单行注释用 `//`，将单行注释放在被注释区域==上面==。==如果注释不是在第一行，那么注释前面就空一行==。

  > 这里是我之前做得很bad的一点！之后一定要正确地加单行注释啊朋友！

  ```js
  // bad
  const active = true;  // is current tab
  
  // good
  // is current tab
  const active = true;
  
  // bad
  function getType() {
    console.log('fetching type...');
    // set the default type to 'no type'
    const type = this._type || 'no type';
  
    return type;
  }
  
  // good
  function getType() {
    console.log('fetching type...');
  
    // set the default type to 'no type'
    const type = this._type || 'no type';
  
    return type;
  }
  
  // also good
  function getType() {
    // set the default type to 'no type'
    const type = this._type || 'no type';
  
    return type;
  }
  ```


## 2.日有所进

### 昨日学习收获

### 今日学习收获

有个宏观的认识~

![image-20220112211633382](https://gitee.com/su-fangzhou/blog-image/raw/master/202201122116683.png)

- 和老大聊了一下，表达了对可视化感兴趣，他建议我多读文档 多读书来强化基础~
- 鲨鱼哥的校招经验分享会上打了一针鸡血，重视基础知识，平趟所有面试~
- 开源社区今天玩儿了个够！





# 1.13 *慢慢进入状态！

早上九点五十才起来，，，属于是一大波上班迟到了 明天争取强制往早了调整一下！

终于！今天的状态 终于！好起来了！

但是！还不够，最近绷得太紧有些时段的效率不行，劳逸结合吧！多起来走走~保持心情畅快哦！

```js
Totally 730min
1.前端开发相关知识学习
	// 减少在开源社区折腾的时间 聚焦于学习知识本身
	/** 每天开始学习之前在仓库issue区打卡
	 * 每天中午在每日一题仓库issue区打卡
	 * 每天下班之后汇总每日一题答案
	 * 每天睡觉之前总结今日 学习/工作 收获
	 */
    1.1 前端基础学习 60+140+220+50+30min 
		/** 昨日事务处理+昨日总结+今日工作展望
         * 上午工作——学习JS规范 复习下生命周期 
         * 下午工作——复习一遍工作流 练习git
         * *加班 晚上做todoMVC 创建打卡仓库（又一个~）
         * 每日一题总结 箭头函数 this指针问题 ...使用
         * 今日总结
         */
    1.2 React复习 min
    	//

2.学习核心基础知识
	2.1 计网 min
    	// 搞完鸡儿外包项目腾出时间学习计网~

3.通过写代码强化逻辑思维、对语言更加熟练
	3.1 leetcode 80min	
		/** 每日一题简单模拟题+数组去重
		 * 归并排序简单学习（还没看代码）
         */
    	// 21/12/27更：假期去实习的同时，别忘了每天刷每日一题+HOT100/剑指Offer+小册/算法小抄/代码随想录（学习新技巧！）+坚持打周赛
    	// 22/1/2更：一道easy/medium如果在15/30min内没AC，马上把卡住的思路放在一边然后去看题解的正确思路，不要走偏！

4.工作生活
    4.1 外包项目开发-Vue 150min
    	// 继续肝需求，每天尽量搞一个完善一些的出来！
```

> 学习时的状态：关闭所有社交软件+手机打开番茄钟

- [x] 每日一题
- [ ] 加入团队前的学习——

  - [x] 复盘昨日学习内容

  - [x] 代码规范 看完

  - [x] 分支管理规范 看完并且再过一遍之前的内容，进行实操

  - [ ] `TodoMVC demo` by React ——先尝试拉下来公司仓库里的内容 回头使用**`gitflow`工作流**模拟多协作者开发流程并进行仿写（四天没看 明天学习一整天咯~）
- [x] 总结每日一题
- [x] 外包项目继续肝进度
- [x] 又大大滴思考了一波打卡形式以及整体学习日常
  - [x] 要规律些啊！慢慢调整嗷！
- [x] 每日睡前（尽量在23点30之前）总结——刷题+工作内容+基础知识

## 1.实习日常

远程入职第二天~

### 昨日工作复盘

- 远程入职第一天，处理俺滴身份，研究办公软件用了不少时间
- JS规范往下看了十个小节，感觉还是要在实际开发环境中使用到才更好记忆些！不过一些规范性的东西真的还是让人很有收获
  - 不要用链式声明的原因
  - 多行注释
  - 块

### 今日工作内容

- 完成第一轮JS代码规范的学习
  - 命名规范要牢记于心，看到不优雅的命名就浑身难受——目的达到了~
- 练习git的一些操作
  - 好多不是很清楚的点！暂时不过多纠结，在实际开发过程遇到了再说咯！
- 明确了要使用git flow工作流在本地以A的身份完成一个ReactJS版本的`todolist` 和 一个React Hooks（搭配脚手架）版本的`todolist`
  - 铺垫了这么久 React搞起来哦耶耶耶！

## 2.日有所进

### 昨日学习收获

- 加入UESTC开源社区，玩儿了一下github的一些内容
- 创建了每日一题仓库 并负责每天进行每日一题的汇总
- 两道力扣 贪心算法+二叉树的简单题 N刷了都
- 参加鲨鱼哥的校招经验分享会，更清楚之后要学习的内容了！搞定外包项目之后课余时间就是跟着文档学习了！
- 和老大聊一些前端人成长的话题，老大建议踏踏实实地夯实基础
- 另外就是开辟“日有所进专区”，学习到一个点就记录下来，第二天再回味一下~

### 今日学习收获

- 还是没少玩儿开源社区啊~
  - 创建一个`UESTCer`的打卡仓库
  - 完善校招收割机仓库 模式&内容
- 热爱开源没错，但是不要过度沉迷这些好玩儿的简单内容（打卡啊 面经分享 每日一题）这些都是比较功利 或者说是体现在效率方面的内容欸~
  - 咱们的目标不应该是**踏踏实实学习技术**然后做出优秀的、体现前端技术的开源仓库嘛！

- 复习了一下Vue nuxt的生命周期（女票问 回头看一眼 发现她比我还明白 笑死）
- 继续肝外包项目，写业务的时候头脑要清晰些哦！
- [每日一题内容](https://github.com/FangzhouSu/FE-Harvester-studyEveryday/tree/main/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E6%B1%87%E6%80%BB#22113%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98)
  - 箭头函数与普通函数的一些区别 顺带着复习了一下箭头函数的规范哈哈哈
  - this指针问题，谁调用就指向谁咯~
    - 真的这么简单就好了XD
  - 扩展运算符的使用
- `leetcode`
  - 每日一题 简单模拟题 但是也没有在最开始找到最优解 反省下吧！居然想到优先队列/单调栈那里去了 其实记录三个变量就ok！
  - 数组去重
    - 各种方式的遍历
    - 哈希表
    - 排序之后进行冒泡去重
  - 归并排序 真恶心！



