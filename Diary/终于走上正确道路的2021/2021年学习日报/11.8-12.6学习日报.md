- 不断摸索前进方向的开始 [9.6-10.10的学习日报](./9.6-10.10学习日报)

- 渐入佳境的10月份，明确方向与重要面试时间节点，接触企业级项目的前端开发 [10.11-11.7的学习日报](10.11-11.7学习日报)

> 需要极强时间管理的11月！不要浪费时间！保证规律作息！
>
> - 三门重要专业课的期中、期末考试
> - 信控平台项目的DDL
> - （也许会有？）一些面试

# 11.8 做项目之余不要忘记基本功的扎实！

虽然九点多才爬起来但是状态蛮不错，是睡得比较久的缘故么？

但是下午时间规划差一些，三点多午睡起来之后开始快乐玩耍勒，所幸晚上效率尚可，这要是抓好早上+下午，一天不得学他个十几个小时！😄（做白日梦ing）

```js
// 今日主要收获 & 学习时间
Totally 520min
1.前端基础知识
    1.1 前端基础学习 60min 
    // 红宝书、刷题
		/* this指针的指向复习——谁调用A函数，A函数中的this就指向谁~
		了解了下Cookie中domain字段，存储请求的地址的信息，前后端分离的小概念~
        思考下一些鼠标悬停效果的实现，这个雀氏没想过*/
    1.2 JS 30demos 60min
    	/* 把24 25俩demo简单完成了一下 25中对事件的学习蛮有感觉的~
        26-30的基本模板也整了下*/

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 50min
		/* 专题：与HTTP协作的Web服务器：单台虚拟主机实现多个域名 & 通信数据转发程序-代理、网关、隧道（后面两个可以保证数据传输的安全性，回头再学习下） & 保存资源的缓存-使用代理缓存服务器保存资源副本/本地磁盘保存资源副本
        跨域*/
	2.2 操作系统 & 数据库 20min
		/* 数据库作业-是真心看不懂啊，回头赶紧复习吧... */

3.面试刷题
	3.1 刷算法 刷力扣 60min	
    	/* 掘金小册 11/28
        	每日一题，比较简单的一道模拟题，因为对哈希表不熟悉+规则没想明白写了快一个小时！之后做模拟题把思路理清楚！*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 
    3.2 面试内容 30min
    	/* 看了会儿剑指Offer 早日刷到这个专题呐！（先把基础内容刷了）
        复习下Git的操作，看点儿基础知识刷小册~*/
4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 160min
    	/* 项目阶段性汇总+困难总结，这个阶段要完成的是静态页面之上的内容勒！
    	思考前后端交互的实现方式，继续阅读各个组件的代码
    	继续讨论如何完成这个项目~
        */
5.其他 
	周总结 感慨蛮多，距离出去找实习准备工作越来越近勒鸭~ 40min
    windows自带的剪切板没法用勒，下载了个copyQ暂时用它吧！ 40min
```

> 学习顺序预告

- [x] 基础知识学习
- [x] 周总结+上月小结+本月展望
- [x] 项目任务拆分+请求场外援助~
- [x] 今日刷题
- [x] 项目进度推进
- [ ] 复习OS & 数据库
- [x] 看会儿图解网络
- [x] JS30demos简略地完成两个
- [x] 项目内容讨论

## 1.前端基础

- this指针
- cookie中的domain字段

![image-20211108130852905](https://gitee.com/su-fangzhou/blog-image/raw/master/202111081308970.png)

- 前后端分离，前端、后端分别部署在不同的服务器上，但是具体怎么个部署法，细节是啥 还**不清楚**嘞~

## 2.计网

#### 图解HTTP第五章

- 单台虚拟主机实现多个域名 √

- 使用代理服务器实现资源的缓存

  ![image-20211108193724535](https://gitee.com/su-fangzhou/blog-image/raw/master/202111081937786.png)

  - 缓存有效性的检验

  ![image-20211108193903845](https://gitee.com/su-fangzhou/blog-image/raw/master/202111081939994.png)

- 使用客户端本地磁盘保存资源副本实现**缓存**

#### 我们访问一个网页的大致过程（从服务器的角度来看）

> 这个问题是从cookie 的 domain字段的内容引起的！
>
> ![image-20211108200508226](https://gitee.com/su-fangzhou/blog-image/raw/master/202111082005281.png)
>
> 很奇怪这个domain中的“域名”到底是前端服务器的域名还是后端服务器的域名呢？
>
> 为啥前端服务器还要个域名呢？
>
> 知乎一下学习学习

- 前后端交互的过程——
  - cookie生成的时间点

![image-20211108200124299](https://gitee.com/su-fangzhou/blog-image/raw/master/202111082001427.png)

- 拓展下跨域的问题

![image-20211108200133079](https://gitee.com/su-fangzhou/blog-image/raw/master/202111082001136.png)

## 3.Vue

- 总结下项目进度 开始构思如何把数据显现出来（继续读代码）

## 4.LeetCode

#### [299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)

写了个题解[[JavaScript 哈希表]注释齐全的小白模拟解法](https://leetcode-cn.com/problems/bulls-and-cows/solution/javascript-ha-xi-biao-zhu-shi-qi-quan-de-7i79/)

## 5.准备面试~

- 看点小知识点，写写简历咯~

# 11.9 *tag:手忙脚乱

为啥手忙脚乱呢。

- 11.12字节跳动视频面试，也是人生中第一次接收前端开发的面试。

没关系，大方地说出“对不起，我只会这些内容了”是我最后的体面。

- 11.11操作系统期中考试。
- 11.14项目基本页面功能交付。

我….行吧，被DDL逼出最好的自己系列，做完这个项目我继续投简历，来啊，来虐我啊😐

```js
// 今日主要收获 & 学习时间
Totally 470min
1.前端基础知识
    1.1 前端基础学习 40min 
    // 红宝书、刷题
		/* 复习一下闭包（要return 内部函数）、作用域、异步的基础知识，感觉还是很有收获！ */
    1.2 JS 30demos 30min
    	/* demo26，很好看的特效，主要是写两个回调函数然后去监听~重点是设计出对应的CSS样式呐！ */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 30min
		/* 看看计网宏观的科普视频~本来想静下心来看看书，但是被面试的消息搞得有点浮躁！这可不好！
        */
	2.2 操作系统 & 数据库 20min
		/* 简单梳理下期中考试要涉及的内容，下午还得多给点时间看看，另外数据库也得给点时间！
        明天操作系统 多学点儿吧！虽说是期中但也不能啥也写不出来啊！*/

3.面试刷题
	3.1 刷算法 刷力扣 50min	
    	/* 掘金小册 13/28
        	用栈实现队列，走了点弯路（看了眼小册，思路带歪了XD），下次见到它五分钟以内干掉！
        	数据结构相关复习*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 
    3.2 面试内容 160min
    	/* 接到字节实习生面试的一面通知（这周五 也就是11.12），忐忑+兴奋吧，慌忙规划了一下接下来这几天该怎么同时完成期中考试的准备+面试的准备XD 得出结论，要找时间肝掉一些面试必备知识：扎实的数据结构知识+计网知识，掘金小册仔细看完，Vue的基本使用要会！ 
    	看了看面经，嗯，都不老会的~
    	专心看一些基础-数据结构+计网...另外看了看牛客 模拟面试了一下 懵逼！
    	筛选勒下资源 看看之后咋学*/
4.做项目
	4.1 Vue学习 140min
		/* 学习了一下vuex和vue router，但还是有些一知半解的地方！基础知识没问题了，需要用实际开发熟熟手~ */
    4.2 项目开发 min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] 基础知识学习（明天请你下床学😐）
- [x] 每日刷题+小册专题推进
- [x] 操作系统复习
- [x] Vue学习
- [x] JS数据结构快速浏览+复习
- [x] JS30demos

突然来了个 小面试，配合上   期中考试和自己贫瘠的基础，突然进入地狱难度了鸭~

## 1.前端基础



## 2.计网



## 3.Vue



## 4.LeetCode

hard难度的祖玛游戏II 我直接一个跳过

二刷了一下 用栈实现队列，倍儿熟啊！对栈&队列这俩数据结构有了更清晰的认知！

## 5.准备面试~

手 忙 脚 乱

# 11.10 

高开低走的一天！反省下自我咯！

```js
// 今日主要收获 & 学习时间
Totally 510min
1.前端基础知识
    1.1 前端基础学习 70min 
    // 红宝书、刷题
		/* 看Promise规范，看一些JS的基础，了解到了为啥typeOf null是object，又是二进制哈~
        学习了一下事件相关，怎么阻止冒泡，怎么取消默认行为的事件*/
    1.2 JS 30demos 160min
    	/* demo26对事件冒泡和事件捕获又有了思考 熟悉了事件监听 熟悉了DOM注册事件的操作（三种方法）
    	 */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 60min
		/* 看了HTTP首部的一些内容~知识广度++（图解HTTP很细致！
        */
	2.2 操作系统 & 数据库 100min
		/* 复习~就学下信号量、调度算法的内容了！ */

3.面试刷题
	3.1 刷算法 刷力扣 80min	
    	/* 掘金小册 14/28
        	每日一题（简单的数组模拟题）+双端队列解决滑窗问题*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 
    3.2 面试内容 min
    	/* 扎实的数据结构知识+计网知识，掘金小册仔细看完，Vue的基本使用要会！ 
    	*/
4.做项目
	4.1 Vue学习 min
		/* 看看基础知识点 */
    4.2 项目开发 20min
    	/* 整理下第一阶段的项目进度 */
5.其他 
	人工智能作业应付下咯~强化学习的内容XD还是很好玩儿（数学）的~ 20min
```

> 学习顺序预告

- [x] 基础知识学习（实在太冷了😐我也想早点下床嘛八点多抵达教室，还行吧~）
- [x] 每日刷题，看小册巩固双端队列 做了道困难题 双端队列思想本身不很难，维护双端队列时的思想是关键
- [x] 看计网
- [x] 人工智能作业
- [x] 看JS CSS基础的一些知识点~补充学习
- [x] JS30demos快速完成计时器的内容~暂时告一段落咯！
- [x] 项目进度推进一些，看看Vue基础知识~
- [x] 操作系统-信号量+内存管理ppt复习（聚焦于调度算法）
- [x] 睡前看Vue相关面试题~

## 1.前端基础



## 2.计网

#### HTTP首部的内容

> 更多具体细节一定要多读一下《图解HTTP》！讲得可详细了~

![image-20211110102718109](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101027457.png)

##### 通用首部字段

通用首部字段是指，请求报文和响应报文双方**都会使用的首部**。

![image-20211110112720637](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127702.png)

##### 请求首部字段

请求首部字段是从客户端往服务器端**发送请求报文中所使用的字段**， 用于**补充**请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

![image-20211110112742415](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127565.png)

##### 响应首部字段

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于**补充**响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

![image-20211110112751761](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127907.png)

##### 实体首部字段

实体首部字段是包含在请求报文和响应报文中的**实体部分所使用的首部**，用于**补充**内容的更新时间等与实体相关的信息。

![image-20211110112758301](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101127448.png)

##### 为Cookie服务的首部字段

![image-20211110113059259](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101130537.png)

两个很重要的首部字段！！

![image-20211110113114974](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101131098.png)

简单解析

- 服务器发给客户端的报文中携带的Set-Cookie字段

![image-20211110113140853](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101131989.png)

- 客户端发给服务端的报文中携带的Cookie字段

![image-20211110113242041](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101132222.png)

## 3.Vue



## 4.LeetCode

#### [495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)-数组模拟

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)-双端队列

## 5.准备面试~

# 11.11 *OS期中考试混过去勒！接下来要更专注地学习！

- 操作系统期中考完了。感悟是：以后每天真的要学一些了！这么下去期末危啊！另外数据库…也赶紧学起来吧XD
- 字节的面试推到了下周五11.19-生存时间++ 多刷一下面试题，好好看看项目咯！

是因为面试没了+刚考完试松懈+没睡午觉糟心得麽？状态略差呐~这可不行！我决定了明天还是早起出去然后中午在外面睡了午觉再回寝室吧！寝室舍友打游戏太吵了！难过😢

晚上状态也不行。没啥好说的 明天努力吧。

```js
// 今日主要收获 & 学习时间
Totally 400min
1.前端基础知识
    1.1 前端基础学习 140min 
    // 红宝书、刷题
		/* web API相关的基础知识刷一刷~
        跟着小青蛙可视化网站通过24个练习学习flex布局
        从鲨鱼哥那里拿学习资料，clone下来放桌面上看一看咯~*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 50min
		/* 复习下HTTPS+学习一下SPDY消除HTTP协议的一些性能瓶颈-包括AJAX comet技术都是来源于此 */
	2.2 操作系统 & 数据库 110min
		/* 最后复习下调度算法+信号量的内容，期中考试50分钟写得很懵逼QAQ */

3.面试刷题
	3.1 刷算法 刷力扣 10min	
    	/* 掘金小册 14/28
        	抄了一道困难的动归~不会啊！回头要赶紧撸这里的专题！*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 30min
    	/* 拉一下项目代码，看一下对应页面的实现方法 */
5.其他 
	金融学作业顺便看个国足~rz 60min
```

> 学习顺序预告

- [x] 准备操作系统考试
- [x] 计网基础知识
- [x] 每日刷题
- [x] 刷一下基础知识
- [ ] 项目进度推进
- [x] 金融作业

## 1.前端基础

- 简单系统学习下flex布局，之前只是“用过”~

## 2.计网

- 图解HTTP真是本入门用的好书！

## 3.Vue



## 4.LeetCode

- 629. K个逆序对数组 每日一题hard+动归。。

# 11.12 

昨天（确切说是今天）看国足+玩游戏有点兴奋，折腾到两点才睡！不该！下回不看了（真的….）

被今天的课搞起来，状态还可以吧，中午睡一下把状态找回来一点。

今天得**推进项目进度**勒！活儿全让朱神干了QAQ，努力！

下午+晚上贯彻到底的颓靡…这是咋了😂**破纪录**的低效啊！这可不行，明天恢复状态！！

```js
// 今日主要收获 & 学习时间
Totally 260min
1.前端基础知识
    1.1 前端基础学习 30min 
    // 红宝书、刷题
		/* 看了一看基础知识~ */
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 60min
		/* 一刷图解HTTP完成！下阶段计网学习计划-网络是怎样连接的 + 图解HTTP二刷（再悄悄看看八股文🧑‍💻） */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 80min	
    	/* 掘金小册 14/28
        	复习勒DFS-栈思想 回顾了下BFS-队列思想 复习一下经典BFS题 二叉树的层序遍历*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 90min
    	/* 合并下之前的项目，处理一堆报错。。。 */
5.其他 
```

> 学习顺序预告

- [x] 看点儿计网
- [x] 每日刷题
- [x] 肝项目
- [x] 梳理下前端三件套基础

## 1.前端基础



## 2.计网

- 一刷图解HTTP完结

## 3.Vue



## 4.LeetCode

- 抄 375. 猜数字大小 II dp中等题我也做不来啊！（且看不懂）

- DFS BFS专题 [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



# 11.13

早起去沙河校区探亲~

今天恢复状态！把昨天没学的学回来！！

状态起伏大了些，晚上注意力集中得不错，看来还是专心做项目更能让人精力集中呐！

明天项目大体上要搞定了！

```js
// 今日主要收获 & 学习时间
Totally 490min
1.前端基础知识
    1.1 前端基础学习 110min 
		/* 看了一下web API的内容
        复习下HTML CSS基础*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 30min
		/* 复习下HTTP协议相关的基础知识~ */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 150min	
    	/* 掘金小册 16/28
        	递归+DFS思想复习一遍
        	周赛-被虐 “暴力法是解决不了问题的，请选择更高级的思想-dp√”*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 200min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] JS基础知识-校车上看
- [x] 每日刷题
- [x] 计网小知识
- [x] 前端三件套基础知识复习
- [x] 项目进度推进，读代码，更新功能
- [x] 力扣周赛
- [ ] 前端基础睡前复习+录个起床铃

## 1.前端基础



## 2.计网



## 3.Vue



## 4.LeetCode

- [520. 检测大写字母](https://leetcode-cn.com/problems/detect-capital/) easy~
- 复习一下“有效的括号” 主要是因为上力扣发现有人在评论区跟我讨论这个 那时候我还用着Java刷题！嗨呀！
- 周赛又跪在一道medium上了。。超时！用的暴力解，小规模用例都没毛病。这题，得想个方法优化——不要每个数都从头比对！明天看看题解

![image-20211114001037876](https://gitee.com/su-fangzhou/blog-image/raw/master/202111140010116.png)

```js
var maximumBeauty = function(items, queries) {
    // 用了个冒泡把二维数组按照第一个值排了个序
    for(let i = 0; i < items.length - 1; i++){
        for(let j = 0; j < items.length - i - 1; j++){
            if(items[j][0] > items[j + 1][0]){
                [items[j], items[j + 1]] = [items[j + 1], items[j]]
            }
        }
    }

    let ans = [];
    for(let i = 0; i < queries.length; i++){
        let tempMax = 0;
        let temp = 0;
        while(true){
            // 就是这里时间复杂度太高了！
            let price = items[temp][0];
            let beauty = items[temp][1];
            if(price <= queries[i]){
                tempMax = tempMax > beauty ? tempMax : beauty;
                temp++;
            }
            // 遍历完一遍才将答案入数组。。工作量巨大！
            if(queries[i] < price || temp >= items.length){
                ans.push(tempMax);
                break;
            }
        }
    }
    return ans;
};
```

# 11.14

十一点才从床上爬下去。。优秀如我，不过睡是睡够了XD挺精神的！

狂刷项目的一天

之前给自己挖太多坑了！！

总之，下周继续加油！要准备人生第一次面试了！

```js
// 今日主要收获 & 学习时间
Totally 580min
1.前端基础知识
    1.1 前端基础学习 30min 
		/* 继续抽空复习前端三件套基础
        着重又看了下Map数据结构（力扣每日一题碰到了）总结了一些内容到知识库认识更深一些了！*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 10min	
    	/* 掘金小册 16/28
        	仓促地刷掉每日一题*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 540min
    	/* 尝试写一些假数据到页面上，好测试一下点击效果是否可用
        疯狂推项目得进度，差不多完成绿波带和子区配置得效果，但是还有好多细节要搞！*/
5.其他 
```

> 学习顺序预告

- [x] 搞项目
- [x] 每日一题
- [x] 睡前看下前端基础

## 1.前端基础



## 2.计网



## 3.Vue

- 搞 项 目

## 4.LeetCode

[677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)

# 11.15

又是十点半才从床上爬下去。。明天开始早上得锁机。。

下午高效了两个多小时 晚饭回来学习力生产力降到0

nice！！！！！！！！！！！！！

明天找回状态吧 今天得是破了记录了吧 麻了(⊙﹏⊙)

```js
// 今日主要收获 & 学习时间
Totally 240min
1.前端基础知识
    1.1 前端基础学习 170min 
		/* 刷了一下CSS基础知识 门道儿真多 布局真烦！但是基础也得扎实鸭~ */
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 40min
		/* 看看HTTP HTTPS协议相关知识 */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 20min	
    	/* 掘金小册 16/28
        	DFS思想+递归解决全排列*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 10min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] 看计网基础
- [x] 前端基础复习
- [x] 每日一题 算法小册进度继续推~
- [x] 睡前前端基础复习+小结

## 1.前端基础

- CSS加载性能
- z-index失效

父元素相对定位，改一种定位方法；元素本身没设置定位，设一个定位；元素本身设置了浮动，去掉浮动

- 布局单位

![](https://gitee.com/su-fangzhou/blog-image/raw/master/202111151639636.png)

- line-height

把 line-height 值设置为 height 一样大小的值可以**实现单行文字的垂直居中**；

一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；

## 2.计网



## 3.Vue



## 4.LeetCode

- 脑筋急转弯题 直接抄了 319. 灯泡开关

# 11.16

早上还是没起来！另外下午吃完饭回来颓了一会儿，晚上上完琴课颓了一会儿 加上和两位学长聊了聊天，又浪费了一会儿 整体状态就没那么好！

明天知道该怎么做吧！

```js
// 今日主要收获 & 学习时间
Totally 470min
1.前端基础知识
    1.1 前端基础学习 110min 
		/* JS基础，看了看隐式类型转换的内容
        又看了看数组去重，对数组的熟练程度++
        总结下目前知识储备，更新下个人前端能力画像~
        JS的new关键字干啥的？再复习一下~*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 160min	
    	/* 掘金小册 16/28
        	我超 回溯算法太恶心了 不过套路感十足啊！了解了一下回溯的思想，好玩儿！算法还是好玩儿的！就是太难了XD*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 60min
		/* 看了下组件间通信的内容，下午在实际项目中试一下 */
    4.2 项目开发 100min
    	/* 解决一些bug，做一些新的业务 */
5.其他 
	和16和18级的学长聊了下~进大厂的自信心又++勒？学长让我抓紧时间去实习（学三个月前端？实习轻松进！（真的么...））40min
```

> 学习顺序预告

- [x] 简单学习下Vue的基础
- [x] 每日一题+小册进度推进l
- [x] JS基础复习~
- [x] 总结下个人前端开发知识掌握程度-让他人/自己更了解自己！
- [x] 项目中的绿波带状态栏在点击下发按钮后进行更改 点击进入配置详情页面之后隐藏地图配置图层

## 1.前端基础

- [隐式类型转换](https://juejin.cn/post/7022837573059870727)
- [数组塌陷现象](https://blog.csdn.net/thunderevil35/article/details/80514680)——从[数组查重](https://juejin.cn/post/6844903981311852557)的一个[好方法](https://juejin.cn/post/6844903981311852557#heading-10)里看到了这个

```js
let arr = [12,1,12,3,1,88,66,9,66];
function unique(arr) {
    let obj = {};
    for(let i=0;i<arr.length;i++){
        let cur = arr[i];
        if(obj[cur]){// 如果当前遍历到的元素之前碰到过，进入逻辑把它从arr中删了
            // 01 删除重复元素法一
            arr.splice(i,1);// 导致数组塌陷——用i--的方式规避数组塌陷！
            // 删除重复元素法二
            // arr[i]=arr[arr.length-1];// 重复元素的坑给数组最后一个元素勒
            // arr.length--;// 删除最后一项
            console.log(i);// 2 4 6
            // 02 对重复元素进行操作之后 手动将索引值-1 保证数组的每一项都被遍历~
            i--;// 注意！删了这个元素之后它之后的数组元素都提前勒！要倒回去一个索引获得原本的下一个数组元素。
            continue;// 跳过obj[cur] = cur，给i加上1 进入下一轮循环（其实这句不加也无所谓，给对象重复赋值也没啥影响~）
        }
        obj[cur]=cur;// 给obj新增键值对；属性名和属性值是一样的
    }
}
unique(arr);
console.log(arr);// 法一答案 [12, 1, 3, 88, 66, 9] 法二答案 [12, 1, 66, 3, 9, 88] 
```

- 数组塌陷

对数组进行操作的时候，会使数组的长度产生变化，同时**操作的数组那个项的下一个索引会被跳过**，从而造成数组的某项会被跳过

- [new关键字的作用](https://juejin.cn/post/7012887169878458404/) 一些细节又学习了一下~

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f493f86148bf4a3c888e34b6f6fd79c1~tplv-k3u1fbpfcp-watermark.awebp?)

手写new过程

```js
 new Person('bill',21) = {
     // 01 新建空对象实例
     var person = {};
     // 02 将构造函数的原型绑定到新创的对象实例上
     person.__proto__ = Person.prototype;
     // 03 调用构造函数并获得返回值res
     var res = Person.call(person, 'bill', 21);
     // 04 判断构造函数的返回值类型，如果res为对象类型，new Person的最终结果为res 而非我们想要的那个实例对象person！
     let isObject = typeof res === 'object' && res !== null;//判断res是否为对象
     // 额外注意 typeof null = object 
     let isFunction = typeof res === 'function';
     // 05 如果构造函数的返回值为对象类型
         //（比如{text: 'fake~'}），则调用new Person('bill', 21)会返回{text: 'fake~'}.
     // 如果返回值不是对象类型就返回之前新建的实例对象person
     return isObject || isFunction ? res : person;
 }

```

- `display:none` `visibility:hidden`的区别

  1.display:none是彻底消失，**不在文档流中占位**，浏览器也不会解析该元素；visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，**在文档流中占位**，浏览器会解析该元素；

  ![image-20211116222402053](https://gitee.com/su-fangzhou/blog-image/raw/master/202111162224130.png)

  2.使用visibility:hidden比display:none性能上要好，

  - display:none切换显示时页面产生**回流**（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），
  - 而visibility切换是否显示时则**不会引起回流**。

## 2.计网



## 3.Vue



## 4.LeetCode

- 每日一题又是困难，抄了。
- 学习回溯算法的思想，递归真烧脑啊！

# 11.17

十一点爬下床的我像个小丑🦹请改掉床上看技术文章的习惯，很空虚欸！踏踏实实坐在电脑桌前好吧！

感觉下午状态还蛮好的，为啥今天就学了这么一会儿捏…

明天balance一下刷题和前端基础嗷！后天面试哩！激动+紧张嘿嘿

```js
// 今日主要收获 & 学习时间
Totally 410min
1.前端基础知识
    1.1 前端基础学习 120min 
		/* 看了些面试题和JS基础知识，感觉手写体&数组API这里自己还是有欠缺啊！
		更新前端三件套主要学习内容
		数组API复习一波~
		复习了一下逻辑运算符，位运算 */
    1.2 JS 30demos 50min
    	/* 简单完结这个项目的一刷，回头再看一遍！ */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 40min
		/* 数据包在网络中遨游的具体流程~ */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 80min	
    	/* 掘金小册 16/28
        	回顾二叉树几道题的迭代法，回顾了一下三数之和 */   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 20min
		/* 继续了解下组件间通信的内容，和Vue基础知识点 */
    4.2 项目开发 40min
    	/* debug... */
5.其他 
	写写面试自我介绍咯~ 60min
```

> 学习顺序预告

- [x] 前端三件套基础复习
- [x] 计网基础复习
- [x] 每日一题+二叉树经典题
- [x] JS30demos-29
- [x] 项目进度推进

## 1.前端基础

- 逻辑运算符 写了篇 [位运算基础知识-按位与& 按位或| 异或^ 短路运算符（逻辑与&& 逻辑或||）](https://blog.csdn.net/qq_45704942/article/details/121379696)

## 2.计网

- 数据包在网络中遨游的具体流程~ 

## 3.Vue

- v-show VS v-if

![image-20211117113655628](https://gitee.com/su-fangzhou/blog-image/raw/master/202111171136710.png)

## 4.LeetCode

- #### [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

下面两题的迭代解法~一个道理的

- #### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

- #### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```js
const postorderTraversal = function(root) {
  // 定义结果数组 —— 这里是个队列（头插-保证根节点是最后进去的）
  const res = []  
  // 处理边界条件
  if(!root) {
      return res
  }
  // 初始化栈结构
  const stack = [] 
  // 首先将根结点入栈
  stack.push(root)  
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
      // 将栈顶结点记为当前结点
      const cur = stack.pop() 
      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部
      res.unshift(cur.val)
      // 若当前子树根结点有左孩子，则将左孩子入栈
      if(cur.left) {
        stack.push(cur.left)
      }  
      // 若当前子树根结点有右孩子，则将右孩子入栈 - 右孩子先出栈插到res队头 保证右孩子在左孩子后面
      if(cur.right) {
        stack.push(cur.right)
      }
  }
  // 返回结果数组
  return res
};
```



# 11.18

又是十点才下床，而且真的是十点才醒。额…感觉还是晚睡的锅吧。我慢慢调整咯！

晚上搞完项目那会儿得玩儿了俩小时！所以睡眠时间被压缩了，蓝瘦！

```js
// 今日主要收获 & 学习时间
Totally 570min
1.前端基础知识
    1.1 前端基础学习 320min 
		/* HTML CSS基础
        原型链复习
        对象的隐式类型转换复习
        CSS复习*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 70min	
    	/* 掘金小册 16/28
        	 回顾一下合并有序的数组 看看二叉树问题的迭代实现，复习DFS深搜解题*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 170min
    	/* 修改之前bug 完成地图切换过程中图层的隐藏 左侧状态栏的显示完成 */
5.其他 
	改进一下面试自我介绍~ 10min
```

> 学习顺序预告

- [x] 前端三件套继续复习~
- [ ] 计网复习
- [x] 树的题大致刷完+每日一题
- [x] 搞项目

## 1.前端基础

- [原型链复习](https://juejin.cn/post/7011719899634630692)

- [对象的隐式类型转换复习](https://juejin.cn/post/7022837573059870727)
- 隐藏元素的方法有哪些
- display:none 与 visibility:hidden 的区别
- Sass、Less 是什么？为什么要使用他们？
  - 预处理器，其实就是 CSS 世界的“轮子” 预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：
  - 主要是因为写起来好看懂一些（工程师说得~）
- 媒体查询
  - link元素中 使用 media属性
  - 在style标签中 @media
- z-index 属性在什么情况下会失效
- em 和 rem的区别
- **vw/vh** 和百分比很类似，两者的区别
- 一般两栏布局指的是**左边一栏宽度固定，右边一栏宽度自适应**，两栏布局的具体实现
-  对 BFC 的理解，如何创建 BFC  盒模型块级上下文格式化
  - Box: **Box** 是 CSS 布局的对象和基本单位，⼀个页面是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。
  - **Formatting context**：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。

实现自适应两栏布局可以给左边设置浮动 右边设置`overflow: hidden`。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就**不会发生重叠**。

- 元素的层叠顺序

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODcyMDM1OC0xMjlhMmMzMWIyN2Y3YzU1LnBuZw)

- 层叠上下文是个啥欸！
- sticky 粘性定位

粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。

- 它的行为就像 **position:relative;** 
- 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。

元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。**否则其行为与相对定位相同**。

- [JavaScript toString() 方法](https://www.w3school.com.cn/jsref/jsref_tostring_number.asp)

toString方法在Object的显示原型上，其他对象对toString方法进行了重写~

![image-20211119083904566](https://gitee.com/su-fangzhou/blog-image/raw/master/202111190839663.png)

toString() 方法可把一个 Number 对象转换为一个字符串，并返回结果。

语法

```js
NumberObject.toString(radix)// radix就是指进制数
```

比较有趣的一个点

![image-20211118184251915](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181842996.png)

小数居然算是`NumberObject`…？ ==存疑！==

看了下MDN [Number.prototype.toString()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) 依旧困惑。暂且记住好了 

- (10) 是 numObj  10不是
- (0.6) 是 numObj 0.6也是numObj

![image-20211118191027604](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181910721.png)

> ```js
> var count = 10;
> 
> console.log(count.toString());    // 输出 '10'
> console.log((17).toString());     // 输出 '17'
> console.log(17.toString());     // Uncaught SyntaxError: Invalid or unexpected token
> console.log((17.2).toString());   // 输出 '17.2'
> console.log(17.2.toString());   // 输出 '17.2'
> 
> var x = 6;
> 
> console.log(x.toString(2));       // 输出 '110'
> console.log((254).toString(16));  // 输出 'fe'
> 
> console.log((-10).toString(2));   // 输出 '-1010'
> console.log((-0xff).toString(2)); // 输出 '-11111111'
> ```
>
> 

- 利用这个方法 配合 [`substr()`方法](https://www.runoob.com/jsref/jsref-substr.html) 可以实现**随机验证码生成**

```js
Math.random().toString(36).substr(2, 10);// 以36进制将随机数转换为随机字符串，从得到的随机字符串的第二位开始拿10个字符~根本重复不了！
```

以36进制将随机数转换为随机字符串，从得到的随机字符串的第二位开始拿10个字符~根本重复不了！

![image-20211118184717386](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181847459.png)



## 2.计网



## 3.Vue

继续肝项目 学到了v-if在实际开发中常用~（用于组件的切换啥的） v-show一般就是切换一个单独元素的状态，用的较少

## 4.LeetCode

#### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

```js
var findTilt = function(root) {
    let ans = 0;
    const dfs = (node) => {
        if (!node) {
            return 0;
        }
        const sumLeft = dfs(node.left);
        const sumRight = dfs(node.right);
        ans += Math.abs(sumLeft - sumRight);
        return sumLeft + sumRight + node.val;
    }
    dfs(root);
    return ans;
};
```



# 11.19 *【人生第一面】ByteDance一面

今日份大事件-人生第一次面试！！

对问答题的表现还算自我满意吧，大概都能聊两句，但是算法题做得太糟糕了！

```js
// 今日主要收获 & 学习时间
Totally 550min
1.前端基础知识
    1.1 前端基础学习 300min 
		/* JS基础复习一下~
        人生第一面~基础知识都能答上来，算法题GG
        面试总结！*/
    1.2 JS 30demos min
    	/*  */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 min
		/*  */

3.面试刷题
	3.1 刷算法 刷力扣 190min	
    	/* 掘金小册 16/28
        	面试前多刷了一些题~*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS + 递归
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 60min
    	/* 推进项目进度 都是一些机械化的工作！ */
5.其他 
```

> 学习顺序预告

- [x] 前端三件套继续复习~

## 1.前端基础

- **存在性判定**：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。

- - **includes**：判断字符串与子串的包含关系：

```js
const son = 'haha' 
const father = 'xixi haha hehe'
father.includes(son) // true
```

- - **startsWith**：判断字符串是否以某个/某串字符开头：

```js
const father = 'xixi haha hehe'
father.startsWith('haha') // false
father.startsWith('xixi') // true
```

- - **endsWith**：判断字符串是否以某个/某串字符结尾：

```js
const father = 'xixi haha hehe'
  father.endsWith('hehe') // true
```

- **自动重复**：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：

```js
const sourceCode = 'repeat for 3 times;'
const repeated = sourceCode.repeat(3) 
console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;
```

- 对象深拷贝

- 对象深拷贝常用方法
  - `JSON.stringify()` 方法将一个 JavaScript 对象或值转换为 JSON 字符串
  - `JSON.parse()` 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象

```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = JSON.parse(JSON.stringify(outObj))
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 1, b: 2}}
```

- 深拷贝与浅拷贝的区别

![img](https://camo.githubusercontent.com/667a0c19bb77ec41c552350d2c8b4c4d1be9662acdd2f931504f214d00b9876f/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31353835363136392d323665326534613066633861333962342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f3331302f666f726d61742f77656270)

![img](https://camo.githubusercontent.com/89821ea9eb62e96d8699acc8f24676a542d0ee2d3d8b71816b0f2e96f402c23a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31353835363136392d383862643539373565616661613438382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f3630302f666f726d61742f77656270)

- `**Object.assign()**` 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
```

- 遍历map

```js
map.forEach( (value,key,map) => {
     console.log(key,value); // foo 1    bar 2
})
```

- [面试总结](https://blog.csdn.net/qq_45704942/article/details/121432692?spm=1001.2014.3001.5502)

## 2.计网

- HTTPS相关复习了一下

## 3.Vue



## 4.LeetCode

一堆题。。懒得记录了

# 11.20 *面试过后开始复习学校专业课+多刷题！ *恢复正常作息！

经过第一次面试被毒打，让我对自己的代码实现能力上的不足有了一个认知！为了展现给面试官更好的自己，要更加努力地去完成这部分的内容！来多少题都给它干掉！

```js
// 今日主要收获 & 学习时间
Totally 340min
1.前端基础知识
    1.1 前端基础学习 80min 
		/* 复习了下作用域中的内容
		回忆了一下昨天的面经缺了两个小知识点 CDN、页面渲染——看了看浏览器相关的知识（页面渲染那块儿） */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 min
		/*  */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 40min	
    	/* 掘金小册 16/28
        	594. 最长和谐子序列*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 150min
    	/* 解决各种需求，查验成果 */
5.其他 
	接下来的学习路线总结+之前的周报小结 70min
```

> 学习顺序预告

- [x] 前端基础学习+学习路线小结
- [ ] 肝一下项目~
- [ ] 网安复习+整理一下作业
- [ ] 数据库复习
- [ ] 每日一题+二叉树继续钻研~

## 1.前端基础

- this指向问题

普通函数中出现this的话 会指向**调用这个函数的上下文** 

![image-20211120133150008](https://gitee.com/su-fangzhou/blog-image/raw/master/202111201331140.png)

稍微变式一下——（说明输出的是b中的a属性）

![img](https://gitee.com/su-fangzhou/blog-image/raw/master/202111201332850.jpg)

## 2.计网



## 3.Vue



## 4.LeetCode

# 11.21 

七点半被闹铃摇起来，然后意志力不坚定地倒头睡到十点半。。

明天要开始早起打开勒。。可一定要起来鸭！

下午晚上不太在状态，早睡调整咯！

```js
// 今日主要收获 & 学习时间
Totally 360min
1.前端基础知识
    1.1 前端基础学习 50min 
		/* jS数据类型 ES6复习~ */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 70min
		/* 网络包遨游的前三步-生成网络包、DNS域名解析、协议栈的概念（委托给OS干发消息的活儿） */
	2.2 操作系统 & 数据库 & 网络安全 70+80min
		/* 数据库-简单看了下mooc 总结了下之后要学习的方法-根据作业中涉及的知识点学习知识点——会做题~ 
		网安：复习下各个章节的内容*/

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 90min	
    	/* 掘金小册 16/28
        	BFS进行层序遍历、DFS进行二叉树翻转、DFS进行二叉搜索树的插入、二叉树/N叉树的深度
           	*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] 计网学习
- [x] 数据库ppt整理+梳理一下要学习的点（根据每次的作业）
- [x] 网安重点梳理+作业题简单整理（这在书上就没办法了）
- [x] JS基础复习
- [x] 力扣树专题推进+每日一题

## 1.前端基础

#### 判断数组的方式

- 通过`Object.prototype.toString.call()`做判断

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

- 通过原型链做判断

```js
obj.__proto__ === Array.prototype;
```

- 通过ES6的Array.isArray()做判断

```js
Array.isArrray(obj);
```

- 通过instanceof做判断

```js
obj instanceof Array
```

- 通过Array.prototype.isPrototypeOf

```js
Array.prototype.isPrototypeOf(obj)
```

#### 箭头函数的this指向

- 从自己作用域的上一级继承this

- 注意继承得来的this是永远不会改变的！

可以⽤Babel理解⼀下箭头函数: 

```js
// ES6 
const obj = { 
  getArrow() { 
    return () => { 
      console.log(this === obj); 
    }; 
  } 
}
```

转化后：

```js
// ES5，由 Babel 转译
var obj = { 
   getArrow: function getArrow() { 
     var _this = this; 
     return function () { 
        console.log(_this === obj); 
     }; 
   } 
};
```

#### 扩展运算符可以用来修改对象的部分属性

如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。

```js
let bar = {a: 1, b: 2};
let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
```

利用上述特性就可以很方便的修改对象的部分属性。

实际应用：在`redux`中的`reducer`函数规定必须是**一个纯函数**，`reducer`中的`state`对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。

#### 嵌套解构

有时会遇到一些嵌套程度非常深的对象：

```js
const school = {
   classes: {
      stu: {
         name: 'Bob',
         age: 24,
      }
   }
}
```

像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：

```js
const { name } = school
```

显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：

```js
const { classes } = school
const { stu } = classes
const { name } = stu
name // 'Bob'
```

但是还有一种更标准的做法，可以用一行代码来解决这个问题：

```js
const { classes: { stu: { name } }} = school
       
console.log(name)  // 'Bob'
```

可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。

#### `Array.prototype.includes()`

##### [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#语法)

```
arr.includes(valueToFind[, fromIndex])
```

##### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#参数)

- `valueToFind`

  需要查找的元素值。**Note:** 使用 `includes()`比较字符串和字符时是区分大小写的。

- `fromIndex` 可选

  从`fromIndex` 索引处开始查找 `valueToFind`。如果为负值，则按升序从 `array.length + fromIndex` 的索引开始搜 （即**从末尾开始往前跳 `fromIndex` 的绝对值个索引**，然后往后搜寻）。默认为 0。

## 2.计网

- 学习了——

网络包遨游的前三步-

【1】客户端生成这个网络包准备发到服务端

【2】DNS寻址，获得IP地址 整个过程就和我们日常生活中找人问路的过程类似，**只指路不带路**。

【3】通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给**操作系统**中的**协议栈**。

上面的部分会向下面的部分委托工作 上层的应用程序（浏览器）通过**调用 Socket 库**，来委托协议栈工作。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCvbLic0XNMIJgJ0pDm6K4s39vgGO4enAIT1jzDXfQPYrdiaQe8TMy11Wicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下一步网络包要去找TCP大佬！

- 【1】浏览器与Web服务器交互的过程（宏观）

![image-20211121131214925](https://gitee.com/su-fangzhou/blog-image/raw/master/202111211312041.png)

![image-20211121131237757](https://gitee.com/su-fangzhou/blog-image/raw/master/202111211312856.png)

![image-20211121131246700](https://gitee.com/su-fangzhou/blog-image/raw/master/202111211312795.png)

- 【2】寻找响应的DNS服务器并获取IP地址

![image-20211121133602271](https://gitee.com/su-fangzhou/blog-image/raw/master/202111211336383.png)

具体步骤如下：

![image-20211121133644267](https://gitee.com/su-fangzhou/blog-image/raw/master/202111211336367.png)

图解网络中的解析 

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCv5bBPibRf9nk4wIb6J3jP62L6NEmPk3HicMUgf8VatcBicynP6BKLeT6GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 3.Vue



## 4.LeetCode

# 11.22 *二面来勒，与考试并行准备~

六点五十成功起床 哦耶~

今天把书签啥的全搬到edge里了 受不了chrome不保存我的cookie！

虽然起得早 但是整体状态不佳！明天通过多喝点水+午睡来调节下试试！

晚间状态也较差，身体状态欠佳啊！碎觉！

```js
// 今日主要收获 & 学习时间
Totally 570min
1.前端基础知识
    1.1 前端基础学习 160min 
		/* JS基础的内容学习了一下！
        看了一下面经，完善下自我介绍~*/

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 网络安全 60min
		/* 折腾一下操作系统实验二-linux虚拟机上的操作
        */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 150min	
    	/* 掘金小册 18/28
        	数组打乱&设计题结构理解 主要时间用在数组乱序算法的研究上 那个洗牌法真的很惊艳！
           	*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 150min
    	/* 更新一些细节，明天任务还是有点重的-完成地图聚焦功能 */
5.其他 
	折腾了一下浏览器的配置问题 换到edge了 20min
    和学长还有前辈讨论下未来发展的问题，打一针鸡血继续努力！30min
```

> 学习顺序预告

- [x] JS基础复习
- [x] 看看面经，自我介绍完善一下~
- [x] 项目肝进度 发布新版本
- [x] 刷题
- [x] 项目版本汇总
- [ ] 睡前复习

## 1.前端基础

#### 利用splice(start, deleteCount)与额外空间进行暴力遍历打乱数组

【1】

splice方法中的start会做一步向下取整！！

**做力扣时发现的点**

```js
let index = Math.random()*list.length// 小数
shuffled[i] = list.splice(index, 1);// 返回对应元素并进行对应索引删除！
```

【2】暴力打乱数组法

```js
let arr = [1,2,3,4,5,6]
function getRandomArrElement(arr, count) {
    let res = []
    while (res.length < count) {
        // 生成随机 index
        let randomIdx = (Math.random() * arr.length) >> 0;// 涨知识 小数右移0位直接向下取整勒
        // 位运算符的特性：后面的操作数是 0 的时候，该语句的结果就和 Math.floor() 一样，是向下取整
        // splice 返回的是一个数组
        res.push(arr.splice(randomIdx, 1)[0]);
    }
    return res
}
getRandomArrElement(arr, 3)
```

#### [前端面试(算法篇) - 数组乱序](https://www.cnblogs.com/wisewrong/p/10517532.html)

> 写得挺好的 搭配 [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/) 食用更佳
>
> 首先是伪随机的两种方法

- **随机取数**

从原数组中随机抽取一个数，然后使用 splice 删掉该元素

```js
function getRandomArrElement(arr, count) {
    let res = []
    while (res.length < count) {
        // 生成随机 index
        let randomIdx = (Math.random() * arr.length) >> 0;
        // splice 返回的是一个数组
        res.push(arr.splice(randomIdx, 1)[0]);
    }
    return res
}
```

上面生成随机 index 用到了按位右移操作符 >> 

当后面的操作数是 0 的时候，该语句的结果就和 Math.floor() 一样，是向下取整

但位操作符是在数值表示的最底层执行操作，因此速度更快

```js
// 按位右移
(Math.random() * 100) >> 0

// Math.floor
Math.floor(Math.random() * 100)
/* 这两种写法的结果是一样的，但位操作的效率更高 */
```



- **通过 sort 乱序**

首先认识一下 [`Array.prototype.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 不了解的查看下 这个必须滚瓜烂熟

```js
let arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
arr.sort((a, b) => 0.5 - Math.random());
```

**但这并不是真正的乱序**，计算机的 random 函数因为循环周期的存在，无法生成真正的随机数（力扣那题用这个方法也跑不通XD）

- **Fisher–Yates shuffle 洗牌算法**

洗牌算法的思路是：

【1】**先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置**

【2】**然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换**

以此类推，打乱整个数组的顺序

```js
function shuffle(arr) {
  let len = arr.length;

  while (len) {
    let i = (Math.random() * len--) >> 0;// 获得随机数
    // 交换位置
    let temp = arr[len];
    arr[len] = arr[i];
    arr[i] = temp;
  }
  return arr;
}
```

再结合 ES6 的解构赋值，使用洗牌算法就更方便了：

```js
Array.prototype.shuffle = function() {
    let m = this.length, i;
    while (m) {
        i = (Math.random() * m--) >>> 0;
        [this[m], this[i]] = [this[i], this[m]]
    }
    return this;
}
```





#### [Document.createTextNode()](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createTextNode)

创建一个新的[`文本`](https://developer.mozilla.org/zh-CN/docs/Web/API/Text)节点。这个方法可以用来转义 HTML 字符。

##### [语法](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createTextNode#语法)

```
var text = document.createTextNode(data);
```

- *`text`* 是一个文本节点。
- *`data`* 是一个字符串，包含了要放入文本节点的内容。

![img](https://gitee.com/su-fangzhou/blog-image/raw/master/202111221537689.png)



#### 判断数组的方式

- 通过`Object.prototype.toString.call()`做判断

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

![image-20211122085928813](https://gitee.com/su-fangzhou/blog-image/raw/master/202111220859922.png)

- 通过原型链做判断

```js
obj.__proto__ === Array.prototype;
```

- 通过ES6的Array.isArray()做判断

```js
Array.isArray(obj);
```

- 通过instanceof做判断

```js
obj instanceof Array
```

- 通过Array.prototype.isPrototypeOf

```js
Array.prototype.isPrototypeOf(obj)
```

#### instanceof的使用

**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

`instanceof` 运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

> `a instanceof A`
>
> 如果 `a.__proto__ = A.prototype` 则返回true

```js
// 定义构造函数
function C(){}
function D(){}

var o = new C();

o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype

o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上
```



#### isPrototypeOf的使用

`isPrototypeOf()` 方法用于测试**一个对象**是否存在于**另一个对象的原型链**上。

`isPrototypeOf()` 与 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 运算符不同。在表达式 "`object instanceof AFunction`"中，`object` 的原型链是针对 `AFunction.prototype` 进行检查的，而不是针对 `AFunction` 本身。

##### [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#语法)

```
prototypeObj.isPrototypeOf(object)
```

##### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#参数)

- `object`

  在该对象的原型链上搜寻

##### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#返回值)

[`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示调用对象是否在另一个对象的原型链上。

本示例展示了 `Baz.prototype`, `Bar.prototype`, `Foo.prototype` 和 `Object.prototype` 在 `baz` 对象的原型链上：

```js
function Foo() {}
function Bar() {}
function Baz() {}

Bar.prototype = Object.create(Foo.prototype);
Baz.prototype = Object.create(Bar.prototype);

var baz = new Baz();

console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true
```

如果你有段代码只在需要操作继承自一个特定的原型链的对象的情况下执行，同 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 操作符一样 `isPrototypeOf()` 方法就会派上用场，例如，为了确保某些方法或属性将位于对象上。

例如，检查 `baz` 对象是否继承自 `Foo.prototype`：

```js
if (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}
```

#### JS数据结构与JSON格式的转换

- `JSON.stringify(obj)` 数据对象->JSON格式的字符串
- `JSON.parse()` JSON格式的字符串->数据对象

常见的对象深拷贝的方式就是

```js
obj = {a: 6, child: {b: 66}}
let copy = JSON.parse(JSON.stringify(obj))
copy.child.b = 888
console.log(obj)// {a: 6 child:{b: 66}}
```

#### 类数组对象转化为数组

> 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象

常见的类数组转换为数组的方法有这样几种：

- 通过 call 调用数组的 slice 方法来实现转换

```js
Array.prototype.slice.call(arrayLike);
```

- 通过 call 调用数组的 splice 方法来实现转换

```js
Array.prototype.splice.call(arrayLike, 0);
```

- 通过 apply 调用数组的 concat 方法来实现转换

```js
Array.prototype.concat.apply([], arrayLike);
```

- 通过 Array.from 方法来实现转换

```js
Array.from(arrayLike);
```

##### 遍历类数组的方法

有三个方法：

（1）将数组的方法应用到类数组上，这时候就可以使用`call`和`apply`方法，如：

```js
function foo(){ 
  Array.prototype.forEach.call(arguments, a => console.log(a))
}
```

（2）使用Array.from方法将类数组转化成数组：‌

```js
function foo(){ 
  const arrArgs = Array.from(arguments) 
  arrArgs.forEach(a => console.log(a))
}
```

（3）使用展开运算符将类数组转化成数组

```js
function foo(){ 
    const arrArgs = [...arguments] 
    arrArgs.forEach(a => console.log(a)) 
}
```

#### JavaScript进行变量提升的本质原因

 js 引擎在代码执行前有一个解析的过程，**创建了执行上下文**，初始化了一些代码执行时需要用到的对象

当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象 这个对象的是在**代码解析的时候创建的**。

#### `Object.prototype.toString.call()` 方法来打印对象的[[Class]] 属性

```js
Object.prototype.toString.call(null);//”[object Null]”
Object.prototype.toString.call(undefined);//”[object Undefined]”
Object.prototype.toString.call(“abc”);//”[object String]”
Object.prototype.toString.call(123);//”[object Number]”
Object.prototype.toString.call(true);//”[object Boolean]”
```

#### 判断对象属于某个类

```js
function Fn(){}
let func = new Fn()
console.log(Fn.prototype.constructor === Fn)// true
console.log(func.constructor === Fn)// true
```

#### 强类型语言和弱类型语言的区别

- **强类型语言**：要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的
  - 一旦一个变量被指定了某个数据类型，如果**不经过强制转换**，那么它就**永远是这个数据类型了**。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
- **弱类型语言**：与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。
  - 在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在**相加的时候会进行强制类型转换**。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的**严谨性可以有效地帮助避免许多错误**。

## 2.计网



## 3.Vue



## 4.LeetCode

####  [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/) 

好题！

# 11.23 

七点成功起床 哦耶~

白天效率还可以的说~午睡再早一些 换下午的高效率就更好了！

```js
// 今日主要收获 & 学习时间
Totally 630min
1.前端基础知识
    1.1 前端基础学习 140min 
		/* 复习下原型的概念~又了解了很多API 
        复习下闭包的概念 学习下作用域 执行上下文的概念要贯彻JS学习！ 
        事件循环 执行上下文 作用域的概念 */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 网络安全 140min
		/* 操作系统作业 内存管理作业写一写~
        网安复习 复习！！ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 80+150min	
    	/* 掘金小册 18/28
    	听了下字节前端工程师讲的算法课~了解下面试难度以及面试官想听到的内容，最重要的是 被大佬们吊打一下！XD
        见识一下A*算法解决8数码问题，搞了个简单的可视化，虽说是借鉴的 但是也学习了大佬的思路~
           	*/   
    	// 每个阶段结束后 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 120min
    	/* 了解下跨域 诱导屏详情的页面效果搞出来了 读一下代码！完成登陆验证的内容 地图聚焦算法的研究 */
5.其他 
```

> 学习顺序预告

- [x] JS基础、进阶内容复习
- [x] 操作系统作业
- [x] 力扣每日一题
- [x] 力扣数组、字符串、排序算法专题学习
- [x] 网安复习
- [x] 项目功能实现

## 1.前端基础

#### 今日最佳-JS引擎的执行机制——事件循环 Event Loop

> 看了下这篇文章 简单入门[10分钟理解JS引擎的执行机制](https://segmentfault.com/a/1190000012806637)
>
> 注意本文中所有执行流程是基于浏览器环境，而不是node环境
>
> > node轮询有phase（阶段）的概念
> > [浏览器和NodeJS中不同的Event Loop ](https://link.segmentfault.com/?enc=6x5T1cZ7jDAzqHVEmBhr0g%3D%3D.9kALuwmRprTk9xaL8P54pEg9Lt6E59fqqaQHd1Q%2Bi40a3%2FUE9nwFb8wOUfv%2FgmQu)

> 事件循环的核心机制是：**宏任务、微任务及其相关队列的执行流程**

单线程的JS通过事件循环 Event Loop 实现异步

JS的执行机制是

- 首先判断JS是同步还是异步,同步就进入主线程,异步就进入**event table**
- 异步任务在event table中注册函数,当满足触发条件后,被推入**event queue**
- 同步任务进入主线程后一直执行,直到**主线程空闲**时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中

以上三步循环执行,这就是event loop

> 举个例子
>
> ```js
> console.log(1)
> 
> setTimeout(function(){
>     console.log(2)
> },0)
> 
> console.log(3)
> ```
>
> ```js
> 1.console.log(1) 是同步任务,放入主线程里
> 2.setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里
> 3.console.log(3) 是同步任务,放到主线程里
> 
> // 当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数
> ```

但这还不够！

##### 微任务、宏任务的概念

如果有多个任务在event queue里呆着呢？谁先？谁后？上新概念！

上道题

```js
setTimeout(function(){
    console.log('定时器开始啦')
});

new Promise(function(resolve){
    console.log('马上执行for循环啦');
    for(var i = 0; i < 10000; i++){
        i == 99 && resolve();
    }
}).then(function(){
    console.log('执行then函数啦')
});

console.log('代码执行结束');
```



尝试按照,上文我们刚学到的JS执行机制去分析

```javascript
【1】setTimeout 是异步任务,被放到event table

【2】new Promise 是同步任务,被放到主线程里,直接执行打印 console.log('马上执行for循环啦')

【3】.then里的函数是 异步任务,被放到event table

【4】 console.log('代码执行结束')是同步代码,被放到主线程里,直接执行
```

所以,结果是 【马上执行for循环啦 --- 代码执行结束 --- 定时器开始啦 --- 执行then函数啦】吗?

亲自执行后,结果居然不是这样,而是【马上执行for循环啦 --- 代码执行结束 --- **执行then函数啦 --- 定时器开始啦**】

> 欸？不是setTimeout这个任务先进的event table麽？
>
> 并不是！上述根据异步同步一股脑划分的方法不对！

而准确的划分方式是:

- macro-task(**宏任务**)：包括`整体代码script`，`setTimeout`，`setInterval`
- micro-task(**微任务)**：`Promise`，`process.nextTick`（Node独有）

![clipboard.png](https://segmentfault.com/img/bV1TKz?w=879&h=723)

按照这种分类方式:JS的执行机制是

- 【1】执行一个**宏任务**(JS脚本中的内容都是宏任务~),过程中如果【2】遇到微任务,就将其【3】放到微任务的【事件队列】里
- 当前【4】宏任务执行完成后,会查看微任务的【事件队列】,并【5】将里面全部的微任务依次执行完

重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。

尝试按照刚学的执行机制,去分析例2:

```js
1.首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里

2.遇到 new Promise直接执行,打印"马上执行for循环啦"

3.遇到then方法,是微任务,将其放到微任务的【队列里】

4.打印 "代码执行结束"

5.本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印"执行then函数啦"

6.到此,本轮的event loop 全部完成。


7.下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印"定时器开始啦"
```

所以最后的执行顺序是【马上执行for循环啦 --- 代码执行结束 --- 执行then函数啦 --- 定时器开始啦】

##### 谈谈setTimeout

这段setTimeout代码什么意思? 我们一般说: 3秒后,会执行setTimeout里的那个函数

```javascript
 setTimeout(function(){
    console.log('执行了')
 },3000)    
```

但是这种说并不严谨,准确的解释是: 3秒后,setTimeout里的函数会**被推入event queue**,而event queue(事件队列)里的任务,只有在**主线程空闲时才会执行**。

**所以只有满足 (1)3秒后 (2)主线程空闲,同时满足时,才会3秒后执行该函数**

如果主线程执行内容很多,执行时间超过3秒,比如执行了10秒,那么这个函数只能10秒后执行了

##### 图解Event Loop

[![eventloop](https://raw.githubusercontent.com/aooy/aooy.github.io/master/blog/issues5/img/eventLoop.jpg)](https://raw.githubusercontent.com/aooy/aooy.github.io/master/blog/issues5/img/eventLoop.jpg)

- 同步任务直接进入主执行栈（call stack）中执行
- 等待主执行栈中任务执行完毕，由EL将异步任务推入主执行栈中执行

#### CORS 跨域资源共享

> 阮大的[CORS详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)
>
> [MDN官方文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E8%B0%81%E5%BA%94%E8%AF%A5%E8%AF%BB%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%9F)

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

#### [for…in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) [for…of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)的用法

- for in 遍历对象 而不是数组

![](https://gitee.com/su-fangzhou/blog-image/raw/master/202111230949518.png)

- for of 遍历可迭代对象 Array Map Set

![image-20211123095042012](https://gitee.com/su-fangzhou/blog-image/raw/master/202111230950252.png)

这个好用欸！

![image-20211123095138548](https://gitee.com/su-fangzhou/blog-image/raw/master/202111230951802.png)

#### 获取对象原型的方法

每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。

当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个**指针**<u>指向构造函数的 prototype 属性对应的值</u>，在 ES5 中这个指针被称为对象的原型。

浏览器中实现了 `__proto__` 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。

ES5 中**新增了一个 `Object.getPrototypeOf()` 方法，可以通过这个方法来获取对象的原型**。

#### 判断属性是否属于原型链的属性

使用[`hasOwnProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)方法来判断属性是否属于原型链的属性：

> `hasOwnProperty()` 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的**键**）。

```js
function iterate(obj){
   var res=[];
   for(var key in obj){
        if(obj.hasOwnProperty(key))
           res.push(key+': '+obj[key]);
   }
   return res;
} 
```

这不比判断原型链啥的省脑子hh（当然方法还是得顺着原型链找咯）

#### 对闭包[Scope](https://developer.mozilla.org/zh-CN/docs/Glossary/Scope)的理解

闭包是指**有权访问另一个函数作用域中变量**的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

- 比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1
```

在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。

![image-20211123091543037](https://gitee.com/su-fangzhou/blog-image/raw/master/202111230915179.png)

- 经典面试题：循环中使用闭包解决 var 定义函数的问题

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

首先因为 `setTimeout` 是个异步函数，所以会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。解决办法有三种：

- 第一种是使用闭包的方式

```js
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

在上述代码中，首先使用了立即执行函数将 `i` 传入函数内部，这个时候值就被固定在了参数 `j` 上面不会改变，当下次执行 `timer` 这个闭包的时候，就可以使用外部函数的变量 `j`，从而达到目的。

- 第二种就是使用 `setTimeout` 的第三个参数，这个参数会被当成 `timer` 函数的参数传入。

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
```

- 第三种就是使用 `let` 定义 `i` 了来解决问题了，这个也是最为推荐的方式

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

#### 对作用域、作用域链的理解

##### 1）全局作用域和函数作用域

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有**很大的弊端**，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

##### 2）块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。



##### 3）**作用域链：**

在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。



作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**



作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。



当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

####  对执行上下文的理解

##### 1. 执行上下文类型

**（1）全局执行上下文**

任何**不在函数内部的**都是全局执行上下文，它首先会**创建一个全局的window对象**，并且**设置this的值等于这个全局对象**，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

##### 2. 执行上下文栈

- **JavaScript引擎**使用执行上下文栈来管理执行上下文
- 当JavaScript执行代码时，首先遇到全局代码，会【1】创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会【2】为该函数创建一个新的执行上下文并压入栈顶，**引擎会执行位于执行上下文栈顶的函数**，当函数执行完成之后，【3】执行上下文从栈中弹出，【4】继续执行下一个上下文。当所有的代码都执行完毕之后，从【5】栈中弹出全局执行上下文。

```js
let a = 'Hello World!';
function first() {
  console.log('Inside first function');// 1
  second();// 2
  console.log('Again inside first function');// 3
}
function second() {
  console.log('Inside second function');
}
first();
//执行顺序
//先执行second(),再执行first()-这里存疑 虽说second函数确实是在栈顶吧！
```

##### 3. 创建执行上下文

创建执行上下文有两个阶段：**创建阶段**和**执行阶段**

**1）创建阶段**

（1）**this绑定**

- 在全局执行上下文中，this指向全局对象（window对象）
- 在函数执行上下文中，**this指向取决于函数如何调用**。如果它**被一个引用对象调用，那么 this 会被设置成那个对象**（`let func = new Fn()`这里构造函数中的this就被设置为这个实例对象了！），否则 this 的值被设置为全局对象或者 undefined

> 下面这俩没听说过的说
>
> （2）**创建词法环境组件**
>
> - 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
> - 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域
>
> （3）**创建变量环境组件**
>
> - 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。
>

**2）执行阶段**

此阶段会**完成对变量的分配**，最后执行完代码。



**简单来说执行上下文就是指：**

在执行一点JS代码之前，需要先**解析代码**。解析的时候会【1】先创建一个全局执行上下文环境，先【2】把代码中即将执行的变量、函数声明都拿出来，【3】变量先赋值为undefined，【4】函数先声明好可使用。这一步执行完了，才【5】开始正式的执行程序。



在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

- 全局上下文：变量定义，函数声明
- 函数上下文：变量定义，函数声明，`this`，`arguments`



#### 判断数组的方式

- 通过`Object.prototype.toString.call()`做判断

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
```

![image-20211122085928813](https://gitee.com/su-fangzhou/blog-image/raw/master/202111220859922.png)

- 通过原型链做判断

```js
obj.__proto__ === Array.prototype;
```

- 通过ES6的Array.isArray()做判断

```js
Array.isArray(obj);
```

- 通过instanceof做判断

```js
obj instanceof Array
```

- 通过Array.prototype.isPrototypeOf

```js
Array.prototype.isPrototypeOf(obj)
```

#### instanceof的使用

**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

`instanceof` 运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

> `a instanceof A`
>
> 如果 `a.__proto__ = A.prototype` 则返回true

```js
// 定义构造函数
function C(){}
function D(){}

var o = new C();

o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype

o instanceof D; // false，因为 D.prototype 不在 o 的原型链上

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上
```



#### isPrototypeOf的使用

`isPrototypeOf()` 方法用于测试**一个对象**是否存在于**另一个对象的原型链**上。

`isPrototypeOf()` 与 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 运算符不同。在表达式 "`object instanceof AFunction`"中，`object` 的原型链是针对 `AFunction.prototype` 进行检查的，而不是针对 `AFunction` 本身。

##### [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#语法)

```
prototypeObj.isPrototypeOf(object)
```

##### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#参数)

- `object`

  在该对象的原型链上搜寻

##### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf#返回值)

[`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示调用对象是否在另一个对象的原型链上。

本示例展示了 `Baz.prototype`, `Bar.prototype`, `Foo.prototype` 和 `Object.prototype` 在 `baz` 对象的原型链上：

```js
function Foo() {}
function Bar() {}
function Baz() {}

Bar.prototype = Object.create(Foo.prototype);
Baz.prototype = Object.create(Bar.prototype);

var baz = new Baz();

console.log(Baz.prototype.isPrototypeOf(baz)); // true
console.log(Bar.prototype.isPrototypeOf(baz)); // true
console.log(Foo.prototype.isPrototypeOf(baz)); // true
console.log(Object.prototype.isPrototypeOf(baz)); // true
```

如果你有段代码只在需要操作继承自一个特定的原型链的对象的情况下执行，同 [`instanceof`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) 操作符一样 `isPrototypeOf()` 方法就会派上用场，例如，为了确保某些方法或属性将位于对象上。

例如，检查 `baz` 对象是否继承自 `Foo.prototype`：

```js
if (Foo.prototype.isPrototypeOf(baz)) {
  // do something safe
}
```

#### JS数据结构与JSON格式的转换

- `JSON.stringify(obj)` 数据对象->JSON格式的字符串
- `JSON.parse()` JSON格式的字符串->数据对象

常见的对象深拷贝的方式就是

```js
obj = {a: 6, child: {b: 66}}
let copy = JSON.parse(JSON.stringify(obj))
copy.child.b = 888
console.log(obj)// {a: 6 child:{b: 66}}
```

#### 类数组对象转化为数组

> 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象

常见的类数组转换为数组的方法有这样几种：

- 通过 call 调用数组的 slice 方法来实现转换

```js
Array.prototype.slice.call(arrayLike);
```

- 通过 call 调用数组的 splice 方法来实现转换

```js
Array.prototype.splice.call(arrayLike, 0);
```

- 通过 apply 调用数组的 concat 方法来实现转换

```js
Array.prototype.concat.apply([], arrayLike);
```

- 通过 Array.from 方法来实现转换

```js
Array.from(arrayLike);
```

##### 遍历类数组的方法

有三个方法：

（1）将数组的方法应用到类数组上，这时候就可以使用`call`和`apply`方法，如：

```js
function foo(){ 
  Array.prototype.forEach.call(arguments, a => console.log(a))
}
```

（2）使用Array.from方法将类数组转化成数组：‌

```js
function foo(){ 
  const arrArgs = Array.from(arguments) 
  arrArgs.forEach(a => console.log(a))
}
```

（3）使用展开运算符将类数组转化成数组

```js
function foo(){ 
    const arrArgs = [...arguments] 
    arrArgs.forEach(a => console.log(a)) 
}
```

#### JavaScript进行变量提升的本质原因

 js 引擎在代码执行前有一个解析的过程，**创建了执行上下文**，初始化了一些代码执行时需要用到的对象

当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象 这个对象的是在**代码解析的时候创建的**。

#### `Object.prototype.toString.call()` 方法来打印对象的[[Class]] 属性

```js
Object.prototype.toString.call(null);//”[object Null]”
Object.prototype.toString.call(undefined);//”[object Undefined]”
Object.prototype.toString.call(“abc”);//”[object String]”
Object.prototype.toString.call(123);//”[object Number]”
Object.prototype.toString.call(true);//”[object Boolean]”
```

#### 判断对象属于某个类（判断其构造函数是谁）

```js
function Fn(){}
let func = new Fn()
console.log(Fn.prototype.constructor === Fn)// true
console.log(func.constructor === Fn)// true
```



## 2.计网



## 3.项目开发-Vue

更改vue.config.js中使用代理proxy解决跨域问题

/api表示需要去匹配请求时的url，然后替换成target的值

比如你页面里是写的

```js
axios.post('/api/list/gd')
```

最终node去请求后台的地址是：http://183.221.84.110:9090/api/list/gd

> 但是你在浏览器里看到的还是：http://localhost:8888/api/list/gd，这时候就不存在跨越的问题的，node服务已经代理拿到数据了
>
> 其实真正引起跨越问题是浏览器的安全机制

![image-20211123134530839](https://gitee.com/su-fangzhou/blog-image/raw/master/202111231345086.png)



## 4.LeetCode

#### [859. 亲密字符串](https://leetcode-cn.com/problems/buddy-strings/)

考察我们思考问题的全面性！

写了篇[题解 反思一下为啥面试/解题时会陷入因考虑不全而无法解决所有用例的怪圈](https://leetcode-cn.com/problems/buddy-strings/solution/javascriptsan-chong-qing-kuang-pan-duan-ozo1z/)

# 11.24

继续早起打卡！🧑‍💻

疯狂复习阿巴阿巴

```js
// 今日主要收获 & 学习时间
Totally 740min
1.前端基础知识
    1.1 前端基础学习 100+140min 
		/* JS进阶看了下 另外做了个很有趣的需求 见 今日最佳 */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 网络安全 490min
		/* 网安复习继续~ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 10min	
    	/* 掘金小册 18/28
           	复习下最小栈*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] JS进阶内容简单复习
- [x] 网安复习

## 1.前端基础

#### 今日最佳-使用`JSON.stringify()`实现对象->JSON格式

> `JSON.stringify()` 方法将一个 JavaScript 对象或值转换为 JSON 字符串
>
> `JSON.parse()` 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象

有这么个需求

![image-20211124112202937](https://gitee.com/su-fangzhou/blog-image/raw/master/202111241122110.png)

要求 cities数组中的py属性的首字母 根据 letter中的内容一一映射

【1】方法1

![image-20211124131512343](https://gitee.com/su-fangzhou/blog-image/raw/master/202111241315540.png)

【2】方法二

![image-20211124131542580](https://gitee.com/su-fangzhou/blog-image/raw/master/202111241315840.png)

#### Promise的基本用法

使用resolve方法和reject方法：

```js
function testPromise(ready) {
  return new Promise(function(resolve,reject){
    if(ready) {
      resolve("hello world");
    }else {
      reject("No thanks");
    }
  });
};
// 01 
testPromise(true).then(function(msg){
  alert(msg);// 调用这句 hello world
},function(error){
  console.log(error);
});
// 02
testPromise(false).then(function(msg){
  alert(msg);
},function(error){
  console.log(error);// 调用这句 输出No thanks
});
```

上面的代码的含义是给`testPromise`方法传递一个参数，返回一个promise对象，如果为`true`的话，那么调用promise对象中的`resolve()`方法，并且把其中的参数传递给后面的`then`第一个函数内，因此打印出 “`hello world`”, 如果为`false`的话，会调用promise对象中的`reject()`方法，则会进入`then`的第二个函数内，会打印`No thanks`；

##### Promise方法

Promise有五个常用的方法

- **then()**

`then`方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为`resolved`时调用，第二个回调函数是Promise对象的状态变为`rejected`时调用。其中第二个参数可以省略。

`then`方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即`then`方法后面再调用另一个then方法。

- catch()

该方法相当于`then`方法的第二个参数，指向`reject`的回调函数。不过`catch`方法还有一个作用，就是在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中。

```js
p.then((data) => {
     console.log('resolved',data);
},(err) => {
     console.log('rejected',err);
     }
); 
p.then((data) => {
    console.log('resolved',data);
}).catch((err) => {// 出现错误则进入这里
    console.log('rejected',err);
});
```



- all()
- race()
- finally()

#### Promise解决了什么问题

在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：

```js
let fs = require('fs')
fs.readFile('./a.txt','utf8',function(err,data){// 发送A请求
  fs.readFile(data,'utf8',function(err,data){
    fs.readFile(data,'utf8',function(err,data){
      console.log(data)
    })
  })
})
```

上面的代码有如下缺点：

- 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
- 如果**前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作**，这种情况下，那么也需要如上编写代码，导致代码不够直观。



用`Promise`封装一下这个请求~，代码变成这样：

```js
let fs = require('fs')
function read(url){
  return new Promise((resolve,reject)=>{
    fs.readFile(url,'utf8',function(error,data){
      error && reject(error)
      resolve(data)
    })
  })
}
read('./a.txt').then(data=>{// 发送A请求
  return read(data) 
}).then(data=>{// 这两个操作可以根据所需进行执行~
  return read(data)  
}).then(data=>{
  console.log(data)
})
```

这样代码看起了就简洁了很多，解决了地狱回调的问题。

#### async 函数返回的是一个 Promise 对象

所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样：

```js
async function testAsy(){
   return 'hello world'
}
let result = testAsy() 
console.log(result)
// then()链处理Promise对象~
result.then(v=>{
    console.log(v)   // hello world
})
```

那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。

**注意：**`Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。

#### 构造函数模式相对于工厂模式的优点

所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型

构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含**函数**的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。（所以如果这个**函数**在对象中用得较多 建议定义在原型上！）

#### 微任务、宏任务的概念

如果有多个任务在event queue里呆着呢？谁先？谁后？上新概念！

上道题

```js
setTimeout(function(){
    console.log('定时器开始啦')
});

new Promise(function(resolve){
    console.log('马上执行for循环啦');
    for(var i = 0; i < 10000; i++){
        i == 99 && resolve();
    }
}).then(function(){
    console.log('执行then函数啦')
});

console.log('代码执行结束');
```



尝试按照,上文我们刚学到的JS执行机制去分析

```javascript
【1】setTimeout 是异步任务,被放到event table

【2】new Promise 是同步任务,被放到主线程里,直接执行打印 console.log('马上执行for循环啦')

【3】.then里的函数是 异步任务,被放到event table

【4】 console.log('代码执行结束')是同步代码,被放到主线程里,直接执行
```

所以,结果是 【马上执行for循环啦 --- 代码执行结束 --- 定时器开始啦 --- 执行then函数啦】吗?

亲自执行后,结果居然不是这样,而是【马上执行for循环啦 --- 代码执行结束 --- **执行then函数啦 --- 定时器开始啦**】

> 欸？不是setTimeout这个任务先进的event table麽？
>
> 并不是！上述根据异步同步一股脑划分的方法不对！

而准确的划分方式是:

- macro-task(**宏任务**)：包括`整体代码script`，`setTimeout`，`setInterval`
- micro-task(**微任务)**：`Promise`，`process.nextTick`（Node独有）

![clipboard.png](https://segmentfault.com/img/bV1TKz?w=879&h=723)

按照这种分类方式:JS的执行机制是

- 【1】执行一个**宏任务**(JS脚本中的内容都是宏任务~),过程中如果【2】遇到微任务,就将其【3】放到微任务的【事件队列】里
- 当前【4】宏任务执行完成后,会查看微任务的【事件队列】,并【5】将里面全部的微任务依次执行完

重复以上2步骤,结合event loop(1) event loop(2) ,就是更为准确的JS执行机制了。

尝试按照刚学的执行机制,去分析例2:

```js
1.首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里

2.遇到 new Promise直接执行,打印"马上执行for循环啦"

3.遇到then方法,是微任务,将其放到微任务的【队列里】

4.打印 "代码执行结束"

5.本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印"执行then函数啦"

6.到此,本轮的event loop 全部完成。


7.下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印"定时器开始啦"
```

所以最后的执行顺序是【马上执行for循环啦 --- 代码执行结束 --- 执行then函数啦 --- 定时器开始啦】



##### 图解Event Loop

[![eventloop](https://raw.githubusercontent.com/aooy/aooy.github.io/master/blog/issues5/img/eventLoop.jpg)](https://raw.githubusercontent.com/aooy/aooy.github.io/master/blog/issues5/img/eventLoop.jpg)

- 同步任务直接进入主执行栈（call stack）中执行
- 等待主执行栈中任务执行完毕，由EL将异步任务推入主执行栈中执行



## 2.计网

### 什么是TCP连接？

我们来看看 RFC 793 是如何定义「连接」的：

> *Connections:* 
>
> *The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.*  
>
> *The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.*

简单来说就是，**用于保证可靠性和流量控制维护的某些状态信息**，这些信息**的组合**（<u>包括Socket、序列号和窗口大小</u>） **称为连接**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843wVoVXxKKTibcN9sLAuSgibkDfV2X8LH8eicpV1yAJ1uffibGqAuWShXibYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

所以我们可以知道 **建立一个TCP连接**是需要 客户端&服务端 **达成上述三个信息的共识**（sockets套接字、sequence numbers序列号、window sizes窗口大小）

- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

后面我们还会详细了解这里的细则 啥滑动窗口啥的 

因为本题就是问“什么是TCP连接” 答出==建立TCP连接就是需要客户端&服务端达成socket 序列号 窗口大小这三个信息的共识==即可

## 3.项目开发-Vue



## 4.LeetCode

# 11.25

继续早起打卡！🧑‍💻

继续疯狂复习

```js
// 今日主要收获 & 学习时间
Totally 780min
1.前端基础知识
    1.1 前端基础学习 40min 
		/* 复习下闭包 学习async await搭配返回一个promise对象以及执行机制的内容 */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 网络安全 710min
		/* 肝掉网络安全的内容QAQ 太难了 老师这个重点画的太有问题了啊。。。晚上还要写作业~ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 10min	
    	/* 掘金小册 18/28
           	听了下字节的算法课 又去了解了下ACM模式*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
	4.1 Vue学习 min
		/*  */
    4.2 项目开发 20min
    	/* 整合代码 */
5.其他 
```

> 学习顺序预告

- [x] 网安复习+完成网安作业

## 1.前端基础



## 2.计网



## 3.项目开发-Vue



## 4.LeetCode



# 11.26 *二面被血虐~反思下吧XD

继续早起打卡！🧑‍💻

痛但是很快乐的字节二面XD，认识到自身的问题然后不要急躁，慢慢去弥补吧~！

```js
// 今日主要收获 & 学习时间
Totally 520min
1.前端基础知识
    1.1 前端基础学习 90+190min 
		/* 复习下HTML CSS基础
        面试被吊打一个小时+总结了俩小时，代码能力暴露得一览无余！ */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 20min
		/* 复习下数据库 明天要实验了！ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 90min	
    	/* 掘金小册 18/28
        刷一刷二叉树*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 100min
    	/* 调了一些bug 地图功能开发了解了下 难度有点大！ 
    	总结下接下来要完成的内容*/
5.其他 
	上周总结+总结下近期学习规划+小修下自我介绍 30min
```

> 学习顺序预告

- [x] 小结下近期学习任务
- [x] 前端复习
- [x] 二叉树刷一下专题+每日一题
- [x] 项目开发
- [x] 面试 + 总结
- [x] 项目进度继续推进
- [ ] 总结接下来的学习内容与时间分配！

## 1.前端基础

#### 今日最佳 [字节日常实习二面](https://blog.csdn.net/qq_45704942/article/details/121569141)

被摁在地上问😢

但是！反思了下自己现有得问题——

- 代码能力不行！
- 思考问题不够深入！抓重点的能力不够！
- 手撕算法时抗压能力弱！

#### 今日第二佳 垃圾回收机制

昨天研究闭包的时候很好奇，啥时候闭包被销毁？

最终结论-如果没有特殊的垃圾回收算法（暂时没有搜索到有这种算法）会造成闭包常驻！除非手动设置为null 否则就会造成内存泄露！

 查阅官方文档——

> 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是[无法判定的](http://en.wikipedia.org/wiki/Decidability_(logic))（无法通过某种算法解决）。
>
> “垃圾回收实现只能有限制的解决一般问题，垃圾回收算法主要依赖于引用的概念。”

举个例子

```js
var o = {
  a: {
    b:2
  }
};
// 下面提到的"这个对象" 即为 {a:{b:2}}
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集

var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o（原来是对象{a:{b:2}}，现在是个数值型，直接扔栈里就可以了！）已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```

#### href&src

- href 超文本引用

  > href 用于**建立标签和外部资源的关系**

- src是资源的意思

  > src 表示**资源替代这个元素**。

##### 区别

这个点还是比较重要的！

- 浏览器遇到href会**并行下载资源**，但是不会停止对文档进行解析。
- 浏览器遇到src会暂停其它**资源的下载和文档解析**，直到资源加载完毕。（这就是script标签不能放在头部的原因）

 这张图拿出来看下 更有感觉了！！

很明显！脚本的加载（也可以称作下载）（蓝色那部分）在defer、async两个属性的作用下，是并行（可以和其他进程 比如文档渲染一起~）的！

而脚本的执行是并发的（需要阻塞掉其他进程~）

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png)

#### 伪类 伪元素

**伪类：**

伪类是以`:`作为**前缀**的

伪类是附加在**选择器末**的**关键字**

伪类元素可以让**指定的元素**，在**指定的状态**，呈现特点样式的关键字。

**伪元素：**

伪元素是以`::`作为**前缀**的

伪元素是附加在**选择器末**的**关键字**

伪元素可以**添加元素**，虽然可以**显示元素**，但是创建元素**不会在DOM树**中存在。

## 2.计网



## 3.项目开发-Vue



## 4.LeetCode

写了下二叉树，对递归理解更深刻了~

# 11.27 

继续早起打卡！🧑‍💻

蚂蚁前端校园行的Node课程，工程师大大费半天劲跑到校园里发现没法投屏😂线材的问题 只能原路返回，带着不能让老师白来的想法，我找老师聊了聊，聊了聊技术体验部对新人的培养和技术的强大性，对阿里的好感又++了，想去实习啊！！！

做了一天的实验，人傻了

```js
// 今日主要收获 & 学习时间
Totally 540min
1.前端基础知识
    1.1 前端基础学习 40min 
		/* 回顾了一下一面 复习下基础知识咯~渲染节点啥的 */

2.核心基础知识 下午开始学计网 + 刷题
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 260+120min
		/* 学习SQL 做大实验
        做实验*/

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 120min	
    	/* 掘金小册 18/28
        又被ACM模式给吊打了一下 有效括号序列 学习了ACM模式 收获颇丰！*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] 每日刷题 
- [x] 数据库复习-SQL&完成作业
- [x] 去品C114复习数据库并完成实验课
- [x] 人工智能实验
- [x] 算法笔试

## 1.前端基础

#### 浏览器的渲染过程

【1】解析 HTML 构建DOM树

【2】解析CSS 构建CSSOM树

【3】利用上面两个树构建渲染树（渲染树的节点即为“渲染对象”）

【4】渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以被称作“回流”）这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

【5】上述几步过后，布局结束；最后进行绘制，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

记住这张图：

![image](https://img-blog.csdnimg.cn/img_convert/6709fb5182ff25591ae5d88ed70771df.png)

## 2.计网



## 3.项目开发-Vue



## 4.LeetCode

#### ACM模式-有效括号序列

```js
function judgeValid(str) {
    let map = new Map([
        ["{", "}"],
        ["(", ")"],
        ["[", "]"],
    ])
    let stack = []
    for(let i = 0; i < str.length; i++){
        if(map.has(str[i])) {
            stack.push(str[i])
        }
        else {
            if(str[i] !== map.get(stack.pop())) {
                return false
            }
        }
    }
    return !stack.length
}
// 上面的核心代码没有问题，力扣上是可以A的
// 主要的时间都扔在下面的ACM模式读数据了 自测输出是没错的 但是就是通过率0%...难过
var n = parseInt(readline());
let isValid = "True";
var ans = 0;
for(var i = 0;i < n; i++){
    // 还是对readline()的理解不行！就是读一行中的内容！
    let lines = readline().split(" ")
    if(!judgeValid(lines)){
        isValid = "False";
        break;
    }
}
print(isValid)
```



# 11.28 

早起打卡！🧑‍💻

久违的沙河校区半日游~快乐😄

今天开始12点前早睡了！头发！

```js
// 今日主要收获 & 学习时间
Totally 420min
1.前端基础知识
    1.1 前端基础学习 40min 
		/* 简单总结下阶段学习内容，明早起来继续做个小结 今天早睡了！ */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 30min
		/* 实验报告 */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 170min	
    	/* 掘金小册 18/28
       	题都很简单的周赛 中等题花了五十分钟，，，各种考虑问题不全面！下次做题前记得把情况想全了！！
       	下周开始看JS数据结构与算法第三版+继续刷专题！*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 180min
    	/* 推进度咯！连接口！
        重构了一下项目 回头还要调整一些细节 */
5.其他 
```

> 学习顺序预告

- [x] 人工智能实验一报告写完
- [x] 力扣周赛+每日一题尝试
- [x] 项目进度推进
- [x] 每日一题完成+周赛小结+算法小册进度小结（明天开始新篇章！）

## 1.前端基础

#### `str.charCodeAt(index)`与`str.charAt(index)`

```js
const sentence = 'The quick brown fox jumps over the lazy dog.';

const index = 4;

console.log(`The character code ${sentence.charCodeAt(index)} is equal to ${sentence.charAt(index)}`);
// expected output: "The character code 113 is equal to q"
```

- `str.charCodeAt(index)`返回值

指定 `index` 处字符的 UTF-16 代码单元值的一个数字（就是ASCII码值~）；如果 `index` 超出范围，`charCodeAt()` 返回 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。

**如果没有提供索引，`charCodeAt()` 将使用0**

- `str.charAt(index)`

从一个字符串中返回指定的字符。

index是一个介于0 和字符串长度减1之间的整数。 (0~length-1)

**如果没有提供索引，`charAt()` 将使用0**，也就是返回字符串中第一个字符~

> 值得注意的是 算法题中经常使用`str.charCodeAt()-‘a’.charCodeAt()`即为字符str与‘a’的ASCII码值之差来获取当前字符所处的独一无二的位置（即为哈希表中的“键”）
>
> 例如 ‘b’就位于索引1处 ‘z’位于索引25处

#### [JS毒瘤](https://github.com/hstarorg/HstarDoc/blob/master/JS%E6%9C%AD%E8%AE%B0/JavaScript%E4%B9%8B%E6%AF%92%E7%98%A4.md)——列举一些在JavaScript中难以避免的问题特性

#### [JS糟粕](https://github.com/hstarorg/HstarDoc/blob/master/JS%E6%9C%AD%E8%AE%B0/JavaScript%E4%B9%8B%E7%B3%9F%E7%B2%95.md)——解决前面所说得JavaScript中有问题的特性

两篇放一起看 很不错！

## 2.计网



## 3.LeetCode

周赛两题，每日一题

第一题过于简单 一分多钟出来了

跳过第二题直接写得第三题（看起来比较好欺负一些？） 超级暴力解法 回头再试试怎么精简一下/尝试更优解法

#### 每日一题 [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

好题！真的很好！

![image-20211128220400103](https://gitee.com/su-fangzhou/blog-image/raw/master/202111282204196.png)

> 非常棒的一题
>
> - 很明显的（第一次做完全没看出来，惭愧！）滑动窗口的思想
> - 利用一维数组模拟哈希表（之前我一看见哈希表二话不说直接new Map()…）

来看个图 很清晰了就 [来源](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/tong-ge-lai-shua-ti-la-hua-dong-chuang-k-xgkv/)

![image-20211128090548278](https://pic.leetcode-cn.com/1638063958-WzvElV-file_1638063958629)

注释齐全，这个方法是最最基础的固定窗口大小的滑动窗口，再困难一些的有窗口大小变动的[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)，嗯是个hard🥺

```js
var findAnagrams = function(s, p) {
    // 在滑动窗口中维护每种字母的数量（通过哈希表，注意哈希表不一定用Map数据结构哈，一维数组也ok 如本题经典的26个坑的哈希表——数组索引即为“键”，对应数组值即为“值”）
    const sLen = s.length, pLen = p.length;
    if(sLen < pLen) {
        return [];// 这个判空一下子没想到XD
    }
    const ans = [];
    // 一维哈希表初始化下,初始化值为0
    const hashS = new Array(26).fill(0);
    const hashP = new Array(26).fill(0);
    // 01 先建立起第一个窗口，顺便将hashP这个哈希表建立好
    for(let i = 0; i < pLen; i++) {
        hashS[s[i].charCodeAt() - 'a'.charCodeAt()]++;
        hashP[p[i].charCodeAt() - 'a'.charCodeAt()]++;
    }
    if(hashS.toString() === hashP.toString()) {
        ans.push(0)
    }
    // 02 将滑窗往后推，每轮推动将滑窗第一个位置的元素值-1，将滑窗末端下一个位置的元素值+1
    for(let i = 0; i < sLen - pLen; i++) {
        // 滑动窗口的推动
        hashS[s[i].charCodeAt() - 'a'.charCodeAt()]--;
        hashS[s[i + pLen].charCodeAt() - 'a'.charCodeAt()]++;
        if(hashS.toString() === hashP.toString()) {
            ans.push(i + 1)
        }
    }
    return ans;
};
```



#### 5940.从数组中移出最大值和最小值

![image-20211128113133788](https://gitee.com/su-fangzhou/blog-image/raw/master/202111281131914.png)

##### 暴力解&经验教训

> 看了看大家得方法 就是一道模拟题~
>
> 可以用贪心得算法去想 

> 使用暴力解且分情况较多时可以在每种情况那里举1-2个例子看看逻辑是否通顺，并且代码处可以console.log一下标记，方便根据错误提示debug（其实就是找全所有情况）



这题我最初得方法就是一个超级无敌复杂的模拟 一大一小两个值有贼多种情况 根据那些情况来计算对应得值（要删除哪些节点） 但是其实并不需要这样列啊！一共有三种计算值得情况 列出来然最小值就行了。。。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minimumDeletions = function(nums) {
    if(nums.length === 1) {
        return 1
    }
    let middle = nums.length >> 1
    let max = nums[0], min = nums[0]
    let maxIndex=0, minIndex = 0
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] > max) {
            maxIndex = i;
            max = nums[i]
        }
        if(nums[i] < min){
            minIndex = i;
            min = nums[i]
        }
    }
    let bigger = Math.max(maxIndex, minIndex)
    let smaller = Math.min(maxIndex, minIndex)
    if(min === max) {
         return 2;
    }
    if(countPosition(minIndex, middle) === countPosition(maxIndex, middle)){
//         在同侧
        console.log("tongce")
        // console.log(minIndex,maxIndex,middle)
        // console.log(countPosition(minIndex, middle),countPosition(maxIndex, middle))
        if(smaller > middle) {
            return nums.length - smaller
        }
        else {
            return bigger + 1
        }
    }
    else if(countPosition(minIndex, middle) === "middle" || countPosition(maxIndex, middle) === "middle") {
//         在中心
        // console.log(bigger)
        console.log("zhongxin")
        if(bigger > middle) {
            return nums.length - smaller
        }
        else{
            return bigger + 1
        }
        
    }
    else{
//         在异侧
        console.log(minIndex,maxIndex)
        console.log(bigger,smaller)
        let sumYice = smaller + 1 + nums.length - bigger
        let sumTongce = bigger + 1
        let sumTongceS = nums.length - smaller
        // console.log(start,end)
        console.log("yice")
        let s = sumYice > sumTongce ? sumTongce : sumYice
        return s > sumTongceS ? sumTongceS : s
    }
};
function countPosition(index, middle){
    if(index === middle) {
        return "middle"
    }
    if(index < middle){
        return "left"
    }
   
    else {
        return "right"
    }
}
```

#### 简单一些的模拟解法

一共有三种计算值得情况 列出来然最小值就行了。。。算是个贪心的方法吧！

```js
const minimumDeletions = nums => {
    const len = nums.length;
    // 特殊情况
    if (len === 1) return 1;
    // 找到最大值，最小值，以及索引
    let [max, min] = [-Infinity, Infinity];
    let [maxIndex, minIndex] = [-1, -1];
    for (let i = 0; i < len; i++) {
        if (nums[i] > max) {
            max = nums[i];
            maxIndex = i;
        }
        if (nums[i] < min) {
            min = nums[i];
            minIndex = i;
        }
    }
    // 有3种操作方式
    let count1, count2, count3;
    // 判断两个索引的大小
    if (maxIndex < minIndex) {
        count1 = maxIndex + 1 + len - minIndex;
        count2 = minIndex + 1;
        count3 = len - maxIndex;
    } else {
        count1 = minIndex + 1 + len - maxIndex;
        count2 = maxIndex + 1;
        count3 = len - minIndex;
    }
    // 返回3种方式的最小值
    return Math.min(count1, count2, count3);
};
```

# 11.29

早起打卡！🧑‍💻

```js
// 今日主要收获 & 学习时间
Totally 560min
1.前端开发学习
    1.1 前端基础学习 80min 
		/* 80min过了一下JS基础 感觉不错！ */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 480min
		/* sql作业+期中考试 */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 min	
    	/* 掘金小册 18/28
        */   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue min
    	/*  */
5.其他 
```

> 学习顺序预告

- [x] JS数据结构与算法看书
- [x] 课内知识学习-数据库

## 1.前端基础

#### 模板字符串两个好处

![image-20211129085641433](https://gitee.com/su-fangzhou/blog-image/raw/master/202111290856603.png)

#### 数组中的[arguments对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)用法之一

**`arguments`** 是一个对应于传递给函数的参数的**类数组对象**。

![image-20211129090711315](https://gitee.com/su-fangzhou/blog-image/raw/master/202111290907451.png)

#### 学习了下导出export导入import的内容



## 2.计网



## 3.LeetCode

# 11.30

过生日辽！21岁辽~🧑‍💻

过生日也要晚上爆肝人工智能实验然后肝外包项目 emo了🥺

```js
// 今日主要收获 & 学习时间
Totally 310min
1.前端开发学习
    1.1 前端基础学习 min 
		/*  */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 220min
		/* 狂肝人工智能实验 */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 50min	
    	/* 掘金小册 18/28
        */   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 20min
    	/* 商讨下接口相关的问题 */
5.其他 
	今日小结~ 20min
```

> 学习顺序预告

- [x] 每日刷题
- [x] 做实验 决策树+强化学习 Q-learning
- [x] 项目进度稍微推进
- [ ] 做总结+规划接下来一段时间的学习路径！

## 1.前端基础

#### 编程获得一个idx+1位数字num索引为i的数

```
num=16 i=1 idx=1 ---> 6
num=139 i=1 idx=2 ---> 3
```

在数学题中遇到要会用个简单操作完成

```js
const res = Math.floor(num / i**(idx -i)) % 10
```

nice!

## 2.计网



## 3.LeetCode

#### [400. 第 N 位数字](https://leetcode-cn.com/problems/nth-digit/)

好题！数学题 比较考验思维能力

```js
//  2位数共有数字90*2个 3位数有900*3个
//  i+1位数有9 * 10 ** i 个 一共有的数字为9 * 10 ** i * (i + 1)
var findNthDigit = function(n) {
    // 假设n为17
    if(n < 10) {
        return n;
    }
    let count = 0;// 用于定位n所处的数一共有多少位 17就位于10-180中
    let i = 0;// 表示n是一个i+1位的数
    while(count + 9 * 10**i * (i + 1) <= n){
        count += 9 * 10**i * (i + 1);
        i++;
    }
    // i=1，count=9
    count = n - count;// 3.得到n（17）在i+1位数中的位置 即为8 count=8
    const num = 10**i + Math.ceil(count / (i + 1)) - 1;// 找出该数字所在的那个大的数 num=10+3=13
    const idx = (count - 1) % (i + 1);// idx=7%2=1->位于所在大数的第1位 即为13中的3 n为16的话就位于第0位 即为13中的1
    console.log(num,idx)
    const res = Math.floor(num / 10**(i - idx)) % 10
    return res
};
```

# 12.1

12月第一天哦~加油加油！

早起被中断了有点可惜😢明天要坚持哦！

跟朋友们对赌了早睡早起就要做到嘛！

```js
// 今日主要收获 & 学习时间
Totally 460min
1.前端开发学习
    1.1 前端基础学习 100min 
    // 红宝书11 20 21-25 复习前面的内容
		/* 数组的那些个方法复习一下 小结了一下 另外明天开始要看红宝书了！ */

2.核心基础知识
	2.1 计网 20min
		/* CORS(Cross-origin resource sharing)复习了一下 允许浏览器向跨源服务器,发出XMLHttpRequest请求,从而克服了AJAX只能同源使用的限制 */
	2.2 操作系统 & 数据库 & 人工智能 min
		/*  */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 190min	
    	/* 掘金小册 18/28
        深挖了两道简单的数组经典题 分别深挖了快速排序、动态规划这两个点，收获颇丰但还不够！继续努力！*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 150min
    	/* 推进下项目进度 研究了下接口请求的实践，绿波带的一些交互性功能暂时写死在本地了，等熟悉了我们这边的后端接口再去发送请求到那边获得数据 */
5.其他 
	今日小结~ min
```

> 学习顺序预告

- [x] JS数据结构与算法
- [x] 计网学习
- [x] 每日刷题计划
- [x] 项目进度推进
- [x] 总结今日前端知识点 看看红宝书之后要学哪部分内容

## 1.前端基础

#### 任意位置添加/删除元素

![image-20211201095959983](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011000116.png)

#### 用[concat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)合并多个数组 返回新数组

```js
var alpha = ['a', 'b', 'c'];

var alphaNumeric = alpha.concat(1, [2, 3]);

console.log(alphaNumeric);
// results in ['a', 'b', 'c', 1, 2, 3]
// 可以用来连接数字/数组
```

#### 浅复制数组的一部分到同一数组的另一位置 [copyWithin()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)

`copyWithin()` 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。

```js
const array1 = ['a', 'b', 'c', 'd', 'e'];

// copy to index 0 the element at index 3
console.log(array1.copyWithin(0, 3, 4));
// expected output: Array ["d", "b", "c", "d", "e"]

// copy to index 1 all elements from index 3 to the end
console.log(array1.copyWithin(1, 3));
// expected output: Array ["d", "d", "e", "d", "e"]
```

神奇的方法~

为啥用呢 看看JS数据结构与算法中怎么说~

![image-20211201112543252](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011125372.png)

#### 用for of遍历数组元素 for in遍历对象属性

![image-20211201110959606](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011109711.png)

#### [Array.of()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of)创建新数组，复制一维数组的方法

`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。

 `Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：`Array.of(7)` 创建一个具有单个元素 **7** 的数组，而 **`Array(7)`** 创建一个长度为7的空数组（**注意：**这是指一个有7个空位(empty)的数组，而不是由7个`undefined`组成的数组）。

```js
Array.of(7);       // [7]
Array.of(1, 2, 3); // [1, 2, 3]

Array(7);          // [ , , , , , , ]
Array(1, 2, 3);    // [1, 2, 3]
```

可以用来浅复制一个数组![image-20211201112108110](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011121232.png)

官方文档中没有提到用of方法进行复制的操作

但是雀氏可以~ 下面的尝试可以清楚看出来复制为浅复制！

![image-20211201112428211](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011124307.png)

#### JS对字符串的比较 根据ASCII码值

![image-20211201112720327](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011127503.png)

## 2.计网

#### [CORS复习](http://www.ruanyifeng.com/blog/2016/04/cors.html)

> 有个学弟问这块儿来着 找来阮大的文章读读学习一下
>
> 另外 MDN对[跨域资源共享CORS的解释](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

本文详细介绍CORS的内部机制。

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求（确定是否同源的请求），但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

##### 两种请求

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

凡是不同时满足上面两个条件，就属于非简单请求。

##### 简单请求的流程

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次**跨源AJAX请求是简单请求**，就自动在头信息之中，添加一个`Origin`字段。

> ```http
> GET /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息**没有包含**`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段，如下的123行

> ```http
> Access-Control-Allow-Origin: http://api.bob.com  该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。
> Access-Control-Allow-Credentials: true 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie 设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。
> Access-Control-Expose-Headers: FooBar  如果想拿到其他字段，就必须在这里面指定
> // 上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。
> Content-Type: text/html; charset=utf-8
> ```

上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。







## 3.LeetCode

#### [【数据结构入门每日刷题打卡1/33】暴力遍历、哈希表、排序（拓展了下手写快排 注释贼清楚！）](https://leetcode-cn.com/problems/contains-duplicate/solution/xue-xi-ji-hua-shu-ju-jie-gou-ru-men-mei-ho9wm/)

#### [【数据结构入门每日刷题打卡2/33】贪心算法、动态规划](https://leetcode-cn.com/problems/maximum-subarray/solution/shu-ju-jie-gou-ru-men-mei-ri-shua-ti-da-ejjqt/)

# 12.2

早睡早起打卡 十二点睡觉 六点半自然醒睁眼七点半下床😢😢😢明天不要酱紫了

状态血崩的一天

主要是因为身体不太舒服QAQ

事儿感觉很多 但都有些无从下手 唉~明天抓紧时间 提高效率肝掉一部分！

```js
// 今日主要收获 & 学习时间
Totally 260min
1.前端开发学习
    1.1 前端基础学习 30min 
    // 红宝书11 20 21-25 复习前面的内容
		/* 复习下栈这个有用的数据结构 遵循FILO first in last out
        */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 80min
		/* 虚拟内存部分的作业 */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 90min	
    	/* 掘金小册 18/28
        两道经典题 前两天用来熟悉发文章格式 之后要加速了哈！*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 30min
    	/* 继续熟悉代码＋完成开发任务 */
5.其他 
	金融作业 30min
```

> 学习顺序预告

- [x] 操作系统作业 虚拟内存 内存管理的内容好复杂阿巴阿巴 底层得一批哦
- [x] 学习JS数据结构与算法
- [x] 每日刷题
- [x] 项目进度推进
- [x] 金融作业

## 1.前端基础



## 2.计网



## 3.LeetCode

#### [【数据结构入门每日刷题打卡3/33】暴力遍历双层遍历、哈希表单层遍历](https://leetcode-cn.com/problems/two-sum/solution/shu-ju-jie-gou-ru-men-mei-ri-shua-ti-da-6it2f/)

#### [【数据结构入门每日刷题打卡4/33】全体排序、两种双指针法（无空间优化&空间优化）](https://leetcode-cn.com/problems/merge-sorted-array/solution/shu-ju-jie-gou-ru-men-mei-ri-shua-ti-da-spe2p/)

# 12.3

早睡早起打卡 十二点睡觉 六点五十被闹钟搞起来七点四十下床 好家伙比昨天还过分是吧 主要是因为身体不太舒服 唉~

出去玩耍的一天~放松下咯

```js
// 今日主要收获 & 学习时间
Totally 300min
1.前端开发学习
    1.1 前端基础学习 10min 
    // 红宝书11 20 21-25 复习前面的内容；看《学习JavaScript数据结构与算法第三版》
		/*  */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 80+140min
		/* 狂补人工智能实验-强化学习那个有点让人头疼呐！ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 20min	
    	/* 掘金小册 18/28
        股票价格 */   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 20min
    	/* 开会定了下进度 */
5.其他 
	金融作业 30min
```

> 学习顺序预告

- [x] 金融作业
- [x] 人工智能实验
- [x] 每日刷题
- [x] 项目进度推进

## 1.前端基础

#### 运算符优先级~

> 从这么个问题引出的
>
> ![image-20211203113518041](https://gitee.com/su-fangzhou/blog-image/raw/master/202112031135111.png)
>
> 因为要先执行关系运算符——小于、大于、小于等于、大于等于、等于、不等于！
>
> 再执行与、或位运算
>
> 再执行短路运算符

![img](https://bkimg.cdn.bcebos.com/pic/63d9f2d3572c11df57c9a205612762d0f703c2f8?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto)

## 2.计网



## 3.LeetCode

做了一个买卖股票最佳时机，题解没太来得及写，明天都补上~

# 12.4

上午在外放松下，下午集中注意力把课上好，把实验报告肝掉！

停止刷题的第二天 事儿忒多了唉~~ 明天得刷六道+写六篇题解😂

```js
// 今日主要收获 & 学习时间
Totally 520min
1.前端开发学习
    1.1 前端基础学习 260min 
    // 红宝书11 20 21-25 复习前面的内容；看《学习JavaScript数据结构与算法第三版》
		/* 蚂蚁前端node学习-写下服务端代码，了解socket.io 重新开始试着写一些简单页面，多写代码很重要呐！ */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 210min
		/* 终于干掉了人工智能的实验+实验报告了！ */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 min	
    	/* 掘金小册 18/28
         */   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 50min
    	/* 继续开会确定进度 */
5.其他 
```

> 学习顺序预告

- [x] 蚂蚁前端基础课
- [x] 人工智能实验
- [x] 项目进度推进

## 1.前端基础

#### 通过JS操控CSS的方法

实践表明 `页面元素.style.属性名=“”` 很好用~

如果想避免改变多个CSS属性的过程中导致的回流和重绘 可以使用

`页面元素.style.cssText="background:red; font-size: 24;"`

![image-20211204161556284](https://gitee.com/su-fangzhou/blog-image/raw/master/202112041615681.png)

## 2.计网



## 3.LeetCode



# 12.5

快八点睁眼——不应该（睡晚了也是一个原因）！

快十点才下床——更不应该了！早上请锁手机！！

今天终于是肝掉了蚂蚁前端校园行的最终项目，虽然只是个初级版本 但还是受益匪浅！感谢成都蚂蚁技术体验部的工程师们

这周结束之后，要进入全新阶段了——重要学科的复习+步步为营的刷题训练+前端基础知识的扎实学习+项目进度的推进

```js
// 今日主要收获 & 学习时间
Totally 530min
1.前端开发学习
    1.1 前端基础学习 330min 
    // 红宝书11 20 21-25 复习前面的内容；看《学习JavaScript数据结构与算法第三版》
		/* 蚂蚁前端基础课程完结~简单的聊天室出炉了！ */

2.核心基础知识
	2.1 计网 min
		/*  */
	2.2 操作系统 & 数据库 & 人工智能 min
		/*  */

3.现在不刷题 面试懵个逼
	3.1 刷算法 刷力扣 50min	
    	/* 掘金小册 18/28
        补完前天的题解*/   
    	// 简单总结下应对某种数据结构/对应类型的题目 应该怎么去想 遇到题脑海里要快速地涌现出解决方案
        1.数组 + 字符串 + 链表 + 二叉树 + 栈/队列 熟练掌握这些数据结构
        2.双指针 + 遍历专题DFS BFS（递归/迭代）
        3.回溯算法 + 贪心算法 + 动态规划
        4.了解下前缀和方法 熟练使用哈希表（解决数组问题） 

4.做项目
    4. 项目开发-Vue 150min
    	/* 与后端交互内容的进一步研究 */
5.其他 
```

> 学习顺序预告

- [x] 蚂蚁前端基础课-结课项目~
- [x] 补前天的每日刷题
- [x] 项目进度推进

## 1.前端基础

#### [蚂蚁前端基础课-结课项目](https://github.com/FangzhouSu/chatRoom)



## 2.计网&计算机基础知识



## 3.LeetCode
