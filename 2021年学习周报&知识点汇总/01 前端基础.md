> 主要为
>
> - HTML
> - CSS
> - JavaScript
>
> 基础知识 与 高频面试题
>
> 节选自每日学习笔记



```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
1.SGML HTML HTML
2.数据类型的分类与各自可以使用的判断方式
	基本（数值）类型
    对象（引用）类型
    == 与 === 的区别
3.undefined与null的区别？
4.什么时候给变量赋值为null呢？
5.不同变量内存值的类型
	数值类型&引用类型
6.包装对象的自定义方法
```

#### 1.SGML

可以看下这篇文章 简洁明了

[SGML、HTML、XML、XHTML、HTML5](https://www.cnblogs.com/huanqna/p/8178057.html)

![img](https://images2017.cnblogs.com/blog/1288677/201801/1288677-20180102165648440-35197995.png)

“ML”即 “Markup language(标记语言)”

GML 是第一代标记语言，使文档能明确将标示和内容分开，所以文件使用同样的标示方法。



#### 2.数据类型的分类与判断

【1】基本类型

最后面的就是用于判断的运算符

* Number ----- 任意数值 ----- `typeof`
* String ----- 任意字符串 ----- `typeof`
* Boolean ---- true/false ----- `typeof`
* **undefined** --- undefined ----- **`typeof/===`**

- **null** ----- null ----- **`===`**  —— 只能用全等判断null 而不可以用`typeof` （因为判断出来得object~）

【2】引用类型

* Object ----- typeof/instanceof
* Array（是一种特别的对象） ------ `instanceof` —— `instanceof`专门用于判断对象实例的类型哦！

```js
var arr=[6,6,6]
console.log(arr instanceof Array)// true
console.log(typeof arr)// object
```



* Function ---- `typeof`
  *  `typeof 一个函数 = Function` （输出等于Function）
  *  但是其实这个Function就是个字符串 因为 `typeof 一个函数 === ‘Function’` 为true

【3】=== 全等 & == 相等

=== 不会自动做数据类型的转换 所以这样得到的是“完全相等”的两个变量

== 会自动做数据类型的转换

#### 3.用作判断的三种运算符

- `typeof`

注意它的返回类型为字符串哦

```js
'undefined'
'number'
'string'
'boolean'
'object'//这里注意！JS的历史遗留问题导致 null array两种数据类型都会被typeof判断为'object'!!!
'function'
```

- `instanceof`

专门用于判断对象**具体类型**的运算符（比如数组这种特别的对象）

- `null`

专门用于判断null undefined这种“只有一种**固定值**的数据类型！”

```js
const a = null;
const b = undefined;
console.log(a === null);//true
console.log(b === undefined);//true
```



#### 4.undefined & null的区别

- undefined：变量未赋值
- null：变量定义并已经赋值了！只不过赋值为null了~



#### 5.什么时候给变量赋值为null？

- 初始赋值 表明将要赋值为对象！
- 结束前让对象成为垃圾对象

```js
let a = null;// 01 初始赋值为null 表明将赋值a为对象 
a = { //a指向这个对象！
    a1: [1,'abc',console.log],
    a2:function(){
        console.log('a2');
    }
}
a = null;// 02 使a指向的对象成为垃圾对象
```





#### 6.不同变量内存值的类型

- 基本类型

保存就是**基本类型的数据**

- 引用类型

保存的是**地址值** 



#### 7.包装对象的自定义方法

所谓包装对象 就是说 三种原始类型的值——数组、字符串、布尔值 在一定条件下也会自动转为对象 也就是原始类型的“包装对象”Wrapper

> 这个内容是红宝书的第五章《基本引用类型》的内容  

我们可以在这三个原生对象的原型链上定义自定义方法

```js
String.prototype.double = function(){
    return this.valueOf() + this.valueOf();
} 
'abc'.valueOf();//abcabc

Number.prototype.double = function() {
    return this.valueOf() + this.valueOf();
}
(123).valueOf();//246
```







```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
1-10 见红宝书——主要是数组的方法与Map集合类型、Set集合类型
```

#### 1.数组的栈方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/118c90aad04e420ea95dbe5868e2af8a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 2.数组的队列方式

就只有 入队列的方法与栈不同 其他方法是一样的

使用shift

插入到队头



#### 3.数组排序方法 sort

sort 这个sort有个坑 所以一般不直接用 

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4cb8f58a27f482ba15f6124bfaacb7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)



#### 4.数组的操作方法-增加元素 单独切一段元素 插入元素 concat slice splice

- `concat()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ae3411e563ea4818af0be79c79571d76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

- `slice()`

![请添加图片描述](https://img-blog.csdnimg.cn/72702c8f27664677964f4c08582cb9dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



- `splice()`

![请添加图片描述](https://img-blog.csdnimg.cn/562f8ba16eb742e39d20baafbd23ba49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

#### 5.搜索数组中元素的位置 indexOf

![在这里插入图片描述](https://img-blog.csdnimg.cn/80a68236760b480dbc2ddd50c896d519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 6.迭代方法 - 各种高级操作 filter map forEach

超级好用的几个方法！

- `every()`
- `some()`
- `filter()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca565154c7664d0a8c01b45a30397477.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)

- `map()`
- `forEach()`

![请添加图片描述](https://img-blog.csdnimg.cn/b16fc430c789416aaeb99134b28a7cd5.png)

#### 7.归并方法 reduce

- `reduce()`

这里的reduce的第一个参数 prev要注意

如果求和时  一般会给其起名为total 用于存储截至此时的和 

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ccc715666954883ad908dff58bff2a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 8.Map集合类型的基本API

明确Map实例的格式 为 键值对 

```js
const map = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])
```

- set() 添加键值对
- get() 获得某个键的值
- has() 查询是否有这个键
- `.size()` 获取键值对数量
- delete() 删除某个键值对
- clear() 清除映射实例中的所有键值对

举例：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a78321c557bb42b797bd84877bc5fe04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

另外 与Object只能使用数值、字符串、符号作为键不同

Map可以使用**任何JS数据类型**作为键！！（这也是为啥ES6要创键这个集合类型）



- 另外注意 Map实例对象2个有趣的特性：

  - 一个key放入多个value —— 覆盖原先的value

  ```js
  var m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam');//88
  ```

  可以看出 key是不允许重复的！这也符合哈希表特性

  但是重复了也不会出错 自动就覆盖掉了

  - 值重复就没啥事儿（那肯定的嘛）

  ![请添加图片描述](https://img-blog.csdnimg.cn/b7e9d37dcc56444085727559a46704ef.png)

#### 9.迭代Map实例（按照插入顺序）

p191

又看到了 .entries() 迭代器方法！

——可以返回key value

#### 10.Set集合类型的基本API 

跟Map的大多数API 和 行为 都是共有的

也是一组key的集合，但**不存储value**。                  

- 要创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
//其实跟map的初始化方法是一样的 就是初始化内容不同而已
```

由于key不能重复，所以，在`Set`中，key是无法像Map实例中一样 可以覆盖的！

- `.size`
- `has()` 判断有没有这个元素
- `clear()`
- `add()` 与map的set添加一组键值对不同 set添加个元素就好了





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// JS现代教程 这里内容还蛮难理解的！
1.利用箭头函数没有自己的this 可以用它来获取外部上下文的对象属性
2.this 的值是对于整个函数的，代码段和对象字面量对它都没有影响。 格局打开
3.丢失了对象的作用域（上下文）this就会“丢失”
4.this丢失的解决方案 出现了熟悉的bind方法
5.解构赋值 主要是看了下对象解构赋值 然后复习了下其他的
6.generator
7.布尔值与数值比较时的隐式转换 true/false与0比较时 会把true隐式转换成1 把false隐式转换成0 
8.JS规定非0数字是true 0是false
9.空字符串是false 
Boolean("") == false;//true
```

#### 1.[箭头函数没有自己的 “this”](https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this)

这里的 `arrow()` 使用的 `this` 来自于外部的 `user.sayHi()` 方法：

```javascript
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

这是箭头函数的一个特性，当我们并不想要一个独立的 `this`，反而**想从外部上下文中获取**时，它很有用。在后面的 [深入理解箭头函数](https://zh.javascript.info/arrow-functions) 一章中，我们将深入介绍箭头函数。



#### 2.this是被作为函数调用的，而不是通过点符号被作为方法调用

试一下：

```javascript
function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
```

这是因为设置 `this` 的规则不考虑对象定义。只有调用那一刻才重要。

这里 `makeUser()` 中的 `this` 的值是 `undefined`，因为它是被作为函数调用的，而不是通过点符号被作为方法调用。

`this` 的值是对于整个函数的，代码段和对象字面量对它都没有影响。

所以 `ref: this` 实际上取的是当前函数的 `this`。

这样就正常了：

```javascript
function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert( user.ref().name ); // John
```

现在正常了，因为 `user.ref()` 是一个方法。==`this` 的值为点符号 `.` 前的这个对象（实例）==。这个对象实例中有name这个属性！

#### 3.this丢失

一旦方法被传递到与对象分开的某个地方 —— `this` 就丢失。

下面是使用 `setTimeout` 时 `this` 是如何丢失的：

```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
```

正如我们所看到的，输出没有像 `this.firstName` 那样显示 “John”，而显示了 `undefined`！

这是因为 `setTimeout` 获取到了函数 `user.sayHi`，但它和对象分离开了。最后一行可以被重写为：

```javascript
let f = user.sayHi;
setTimeout(f, 1000); // 丢失了 user 上下文 只能输出Hello, undefined!
```



> 浏览器中的 `setTimeout` 方法有些特殊：它为函数调用设定了 `this=window`（对于 Node.js，`this` 则会变为计时器（timer）对象，但在这儿并不重要）。所以对于 `this.firstName`，它其实试图获取的是 `window.firstName`，这个变量并不存在。
>
> 在其他类似的情况下 通常 `this` 会变为 `undefined`。



那么想把一个对象方法传递到别的地方 然后在该位置调用它 

也就是如何确保在正确的上下文中调用它？

#### 4.this丢失的解决方法

##### [解决方案 1：包装器](https://zh.javascript.info/bind#jie-jue-fang-an-1-bao-zhuang-qi)

最简单的解决方案是使用一个包装函数：

```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);
```

现在它可以正常工作了，因为它==从外部词法环境中获取到了 `user`==，就可以正常地调用方法了。

相同的功能，但是更简短：

```javascript
setTimeout(() => user.sayHi(), 1000); // Hello, John!
```



但是有个小问题 

在 `setTimeout` 触发之前（有一秒的延迟！）`user` 的值改变了怎么办？那么，突然间，它将调用错误的对象！

```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// ……user 的值在不到 1 秒的时间内发生了改变
user = {
  sayHi() { alert("Another user in setTimeout!"); }
};

// Another user in setTimeout!
```

下一个解决方案保证了这样的事情不会发生。

##### [解决方案 2：bind](https://zh.javascript.info/bind#jie-jue-fang-an-2-bind)

函数提供了一个内建方法 [bind](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)，它可以绑定 `this`。

基本的语法是：

```javascript
// 稍后将会有更复杂的语法
let boundFunc = func.bind(context);
```

`func.bind(context)` 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 `func` 并==设定 `this=context`==。（这不就获取了本来不在作用域中的对象了么！）

换句话说，`boundFunc` 调用就像绑定了 `this` 的 `func`。

举个例子，这里的 `funcUser` 将调用传递给了 `func` 同时 `this=user`：

```javascript
let user = {
  firstName: "John"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // John
```

这里的 `func.bind(user)` 作为 `func` 的“绑定的（bound）变体”，绑定了 `this=user`。

所有的参数（arguments）都被“原样”传递给了初始的 `func`，例如：

```javascript
let user = {
  firstName: "John"
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// 将 this 绑定到 user
let funcUser = func.bind(user);

funcUser("Hello"); // Hello, John（参数 "Hello" 被传递，并且 this=user）
```



#### 5.解构赋值

##### [对象解构](https://zh.javascript.info/destructuring-assignment#dui-xiang-jie-gou)

解构赋值同样适用于对象。

- 【1】基本语法是：

```javascript
let {var1, var2} = {var1:…, var2:…}
```

在等号右侧有一个已经存在的对象，我们想把它拆开到变量中。等号左侧包含了对象相应属性的一个“模式（pattern）”。在简单的情况下，等号左侧的就是 `{...}` 中的变量名列表。

举个例子：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```

- 【2】属性 `options.title`、`options.width` 和 `options.height` 值被赋给了对应的变量。变量的顺序并不重要，下面这个代码也奏效：

```javascript
// 改变 let {...} 中元素的顺序
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
```



- 【3】等号左侧的模式（pattern）可以更加复杂，并且指定了属性和变量之间的映射关系。

如果我们想把一个属性赋值给另一个名字的变量，比如把 `options.width` 属性赋值给变量 `w`，那么我们可以使用冒号来指定：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```



- 【4】对于可能缺失的属性，我们可以使用 `"="` 设置默认值，如下所示：

```javascript
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```



- 【5】我们还可以将冒号和等号结合起来：

```javascript
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

- 【6】如果我们有一个具有很多属性的复杂对象，那么我们可以只提取所需的内容：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// 仅提取 title 作为变量
let { title } = options;

alert(title); // Menu
```

当时学习react的时候也是这个状态 需要哪个就提取哪个~

##### 解构赋值总结

- 解构赋值可以立即将一个对象或数组映射到多个变量上。

- **解构对象**的<u>完整</u>语法：

  ```javascript
  let {prop : varName = default, ...rest} = object
  ```

  这表示属性 `prop` 会被赋值给变量 `varName`，如果没有这个属性的话，就会使用默认值 `default`。

  没有对应映射的对象属性会被复制到 `rest` 对象。

  ==这是最全的一个用法 不写全是ok的！==

- **解构数组**的<u>完整</u>语法：

  ```javascript
  let [item1 = default, item2, ...rest] = array
  ```

  数组的第一个元素被赋值给 `item1`，第二个元素被赋值给 `item2`。

  剩下的所有元素被复制到另一个数组 `rest`（展开运算符来凑热闹了）。

- 从嵌套数组/对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。



##### 看几道对象解构例题

- easy

[解构赋值](https://zh.javascript.info/destructuring-assignment#jie-gou-fu-zhi)

我们有一个对象：

```javascript
let user = {
  name: "John",
  years: 30
};
```

写一个解构赋值语句使得：

- `name` 属性赋值给变量 `name`。
- `years` 属性赋值给变量 `age`。
- `isAdmin` 属性赋值给变量 `isAdmin`（如果属性缺失则取默认值 false）。

下面是赋值完成后的值的情况：

```javascript
let user = { name: "John", years: 30 };

// 等号左侧是你的代码
// ... = user

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
```

答：

```javascript
let user = {
  name: "John",
  years: 30
};
// 就是最基础的用法
let {name, years: age, isAdmin = false} = user;

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
```



- hard

[最高薪资](https://zh.javascript.info/destructuring-assignment#zui-gao-xin-zi)

这儿有一个 `salaries` 对象：

```javascript
let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};
```

新建一个函数 `topSalary(salaries)`，返回收入最高的人的姓名。

- 如果 `salaries` 是空的，函数应该返回 `null`。
- 如果有多个收入最高的人，返回其中任意一个即可。

P.S. 使用 `Object.entries` 和解构语法来遍历键/值对。

> entries()永远嘀神！

答：

```javascript
function topSalary(salaries) {

  let max = 0;
  let maxName = null;

  for(let [name, salary] of Object.entries(salaries)) {
    if (max < salary) {
      max = salary;
      maxName = name;
    }
  }

  return maxName;
}
```

#### 6.generator

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。

学习分为[**Generator函数的语法和API**](https://es6.ruanyifeng.com/#docs/generator)  和  **[它的异步编程应用](https://es6.ruanyifeng.com/#docs/generator-async)**

异步编程对 JavaScript 语言是很重要的！因为JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。





#### 7.数值型与布尔型的隐式转换

刷题的时候遇到的一个小点

![在这里插入图片描述](https://img-blog.csdnimg.cn/f968b88841e544e682b368df647237f7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_12,color_FFFFFF,t_70,g_se,x_16)

引出两个点——

- 隐式转换
- !0 == true;//true

先来看第一个

true 和false（布尔值）和数值比较， 会做一个隐式转换——

【1】true 隐式转换为1 

【2】false隐式转换为0。

见代码

```js
1 == true;//true
//要注意===是全等哦 不会做隐式转换
1 === true;//false
```

```js
0 == false;//true
```

#### 8.非0是true 0是false

再来看第二个

- !0代表true (因为0代表false)

```js
!0 == true;//true
```



- 非0实数代表false

```js
!1 == false;//true
```





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）
1.回忆一下JS中数据存储的底层知识——栈存储变量 堆存储变量的值（内存是用来存储数据的空间）
2.上个知识点的补充说明 var a =xxx a变量的内存中保存的是什么  保存的是xxx的内存内容（可能是基本数据数据也可能是地址值）
3.赋值的小问题 var obj1 = {name:"Tom"}; var obj2=obj1; 把obj1的内存内容赋给obj2 （在这里 obj1的内存内容是地址值）
针对上述内容 写了一篇文章
4.两个引用变量指向同一个对下给你 通过一个变量修改对象内部数据 另一个变量看到的是修改过后的数据
两个引用变量指向同一个对象 让其中一个变量指向另一个对象 另一个引用变量依然指向前一个对象啊~
5.JS调用函数时传递变量参数时 是值传递还是引用传递？（面试高频）
答：是值传递 不过也可以把“传递地址值”理解为“引用传递” 略有些不严谨而已
6.JS引擎如何管理内存？
```

#### 1.JS数据存储底层知识

一个变量对应一块小内存 变量的值保存在此内存中

- 一行代码 `var obj = { name: 'Tom' }` 的执行过程：

首先进入代码区（反正Java里是这么说）然后编译

因为变量=对象 我们把这个对象的内存内容（也就是它的地址值）赋给obj这个变量

内存图可以这么画——

- 栈：存储变量
- 堆：存储对象（实体）在Java 和C 中都这么说来着！

![请添加图片描述](https://img-blog.csdnimg.cn/671345cb9e6c46928bbd1619b3051f37.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_10,color_FFFFFF,t_70,g_se,x_16)

#### 2.【底层】给变量赋值时 赋的是什么？变量内存空间保存的是什么？

```js
// 01 给变量赋值基本数据 —— 保存的就是这个基本数据
var a = 666;
// 02 给变量赋值对象 —— 保存的是 【对象的地址值】 （如上图）
var obj = {name: "Bill"};
// 03 重要！给变量obj1 obj2赋变量a obj【的内存内容】 
// —— 内存空间保存的可以是基本数据（a）也可以是对象的地址（obj）
var obj1 = a;
var obj2 = obj;
```

这三种情况一定要完全掌握！

我们在给变量赋值时 其实发生的是这些事情！

掌握了这些 之后学习进阶知识 才会更加轻松！



[【JS底层知识】我们给变量赋值时 赋值内容是什么？变量内存空间保存的是什么？](https://blog.csdn.net/qq_45704942/article/details/120399845)







#### 3.引用变量赋值问题 var obj = {对象的属性&属性值}

同样的obj1 = obj2;

- 改变量指向的 **对象的内部数据** `obj2.name = xxx;` obj1的name也变了
- 改变量指向的**那个对象** `obj2={xxx};`  obj1变量指向的对象还是原来那个 不受影响

![请添加图片描述](https://img-blog.csdnimg.cn/37cd589be0184cc4a01540da12e54561.png)

上图例子中a b两变量指向的已经不是同一个对象了 

所以b在改变指向对象的属性时 已经不会影响a了哦！



#### 4.【面试高频】JS调用函数时传递变量参数 传递的是变量的值（是值传递 而不是引用传递）

其实有两种理解

- 【1】都是值（基本/**地址值**）传递 —— 这个更规范
- 【2】可能是值传递 也可能是引用传递（传的地址值 这块儿也可以像上面那样理解成值传递）





- 值为基本数据

举个例子 秒懂

```js
var a = 3;
function fn(a){
    a = a + 1;
    //a（这个a是局部的那个a变量（也就是形参变量）所以在外面输出的是全局变量3）=a（这个a是全局的那个a变量 值为3）+1
}
fn(a);//这里传递的不是a的地址 而是a的值——3
// 调用函数 将实参赋给形参
console.log(a);//3
```

传过去的是变量a的**值**

- 值为地址值

再举个例子

```js
function fn2(obj){
    obj.name = "change";// 这里修改了地址中对象的name属性
}
var obj = {name: "Bill"};
fn2(obj);// 调用函数 修改了地址中对象的name属性
console.log(obj.name);//change
```

这里 传过去的obj 就==是一个地址值== 

我们规范起见 还是把它称作 obj变量的值！而不是引用值（不过这么说也算是可以 有些不严谨）！



#### 5.JS引擎如何管理内存？垃圾回收机制

##### 【1】内存生命周期

- 分配小内存空间

- 分配数据 可以反复进行操作
- 释放小内存空间



##### 【2】释放内存

- 局部变量

函数执行完自动释放

- 对象

成为垃圾对象 等回头由垃圾回收器回收

##### 【3】垃圾回收

这个[垃圾回收的内容](https://zh.javascript.info/garbage-collection)（参考了现代JS教程） 回头可以再了解下

现阶段了解如下知识即可：

- 垃圾回收是**自动完成**的，我们**不能强制执行或是阻止执行**。
- 当对象是可达状态时，它一定是存在于内存中的。
- 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。

当你需要底层的优化时，对引擎有深入了解将很有帮助。在熟悉了这门编程语言之后，把熟悉引擎作为下一步计划是明智之选。





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）
1.对象中的方法 —— 之前没了解过竟然！hh
2.两种操作对象内部属性的方法（p.xxx的局限；p['xxx']全能）
3.JS可以让一个函数成为任意指定对象的方法 然后这个指定对象就可以调用这个函数了（只有JS可以 用call方法！）
4.使用函数之前 要注意 函数也是一个对象 它也有属性 prototype 也有方法！
5.LIFE(Immediately Invoked Function Expression) 立即调用函数表达式 也可以称作匿名函数自调用（这个好理解一些）
6.几种回调函数
7.this是啥？this的值要如何确定？
```

#### 1.对象中方法的创建-举例

```js
var obj = {
    name: "bill",
    age: 21,
    // 函数的形参都是对象中的属性
    setName: function(name){
      this.name = name;  
    },
    getName: function(name){
        console.log(name);
    },
	getAge: function(age){
         console.log(age);
    }
}
obj.getName("这个打印的内容没啥意义 就是证明下这个方法可以用~"); // 这个打印的内容没啥意义 就是证明下这个方法可以用~
obj.setName("gates");// 构造函数就是用来干这事儿的 之前Java经常使用
// 在这次调用中this的值是obj对象 —— 显然~
obj.name;// obj的name被上方的方法改变了 
调用对象中的方法 
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/0be239df62894fb6ad7fa04e2ef9132c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 2.两种操作对象内部属性的方法

```js
var obj = {
    name: "bill"
}
obj.name;// bill

obj.age = 21; // 01 第一种操作对象内部属性的方法

// obj.sleep-time = 7;// 报错 属性名带特殊字符是不可以 用于初始化对象/用于操作对象属性 的！
obj["sleep-time"] = 7; // 02 第二种操作对象内部属性的方法
// ~设置属性成功
```

通过 `.` 运算符来访问内部属性固然是可以 但是有局限性！

- 属性名包含特殊字符时 不能用

用这种方法 比较万能哈！

![在这里插入图片描述](https://img-blog.csdnimg.cn/2901ddf3114947a1a91f633343b175e3.png)

- 属性是个变量也不行！后续在框架中可能会这么用~！

```js
var obj2 = {
    name: "bill"
}
var propName = "age";
var value = 21;
// obj2.propName = value;// 这里会给obj2设置一个propName属性。。。
obj2[propName] = value;// 成功设置age属性
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d075ecba64864c4c89fbad1848773086.png)

#### 3.JS使用函数的call方法为指定对象调用一个方法~

这个方法obj是无法单独调用的~

只能让函数本身通过call方法来给这个对象做一个调用！ 如下

```js
var obj = {};
function fn(){
    this.slogan = 'fighting!';    
}
fn.call(obj);// 为obj调用fn方法
console.log(obj.slogan);// fighting!
```

其实这个call方法的作用应该是 用于**编写能够在不同对象上使用的方法**

具体内容看9.28的笔记



#### 4.函数也是个对象~有属性 有方法

复习下之前（13号）学习的数据类型的判断

![在这里插入图片描述](https://img-blog.csdnimg.cn/831e074788174122b896b1d7cd59a503.png)

- `instancof Function === true;// true`
- 函数有属性 prototype
- 函数有方法 call()/apply()
- 当然也可以添加新的属性/方法



#### 5.匿名函数自调用

LIFE(Immediately Invoked Function Expression) 立即调用函数表达式 

也可以称作匿名函数自调用（这个好理解一些）

##### 作用

- 隐藏实现（对程序隐藏）
- 不会污染外部（全局）命名空间（我个人认为在全局函数中可以使用let const来避免污染全局命名空间）

```js
(function(){
    var a = 6;// a不会污染全局变量 而且这个实现是隐藏的
    console.log(a);
})();
```



```js
(function(){
    var a = 6;
    function test(){
        console.log(++a);
    }
    // 向外暴露一个全局函数（类似导出模块）
    window.expose = function(){
        // 上面这里 写 window.$ 专业一些~（回头去看看$出现的场景）
        return{
            test:test // 暴露全局函数 不可有分号哈 
            // 这里有点懵 前提知识看来还是有没学到的 但是大体可以理解
        }
    }
})();
expose.test();
```



- 用来编码JS模块（ES6中的内容）



#### 6.几种回调函数

首先了解 

- 什么函数才是回调函数？
  - 你定义的
  - 你没有直接调用
  - 这个函数最终执行了（在一定条件下/某个时刻）



常用DOM函数

- DOM事件回调函数（与用户交互中的重点）

```js
document.getElementById('btn').onclick = function(){
    alert(this.innerHTML)
}
```



- 定时器回调函数

```js
setTimeout(function(){
    alert("干饭了！");
}, 2000)// 2s后执行函数
```



- AJAX请求回调函数（与后台交互的重点）
- 生命周期回调函数）



#### 7.this是啥？this的值要如何确定？

##### 【1】是啥？

首先明确——任何函数本质上都是通过某个对象来调用的（对象、函数联系起来了哈哈） 如果没有直接指定 那就是window调用的

- 所有函数内部都有一个this	
- this的值是调用函数的**当前对象**



##### 【2】如何确定？

- `obj.xxx()`  —— obj
- `xxx.call(obj) `  —— obj
- `xxx()` —— window
- 回调函数 `setTimeout(function(){}, 6666)` —— 看背后是通过谁来调用的 

其中回调函数的this比较有趣

```js
setTimeOut(() => {
    console.log(this);
}, 2000);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/fd9fb397b3174c56828619fd70bd5a9b.png)

其他情况回头遇到了再补充~





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）
复习一下原型的内容 貌似明白一些了！
0.所有实例对象都有 `__proto__`属性 创建实例对象时自动添加
每个函数都有`protoytype`属性 它默认指向一个Object空对象   原型对象都有个`constructor`属性 它默认指向函数对象
  构造函数与原型对象是相互引用的关系
1.隐式原型和显式原型的关系 p16
2.通过原型链获取对象内部的属性/方法 p17
3.原型链——函数、Function、Object之间的关系 p18 20
4.原型链面试题-属性问题 p21
5.原型链面试题-p21

6.JS中单引号与双引号的功能相同 
7./t 是制表符的意思 可以加一个缩进
8.数组的不同位置的插入移出
	头插unshift() 
	尾插push() —— 入栈 入队
	头出shift() —— 出队
	尾出pop() —— 出栈
9.不使用var 直接定义一个变量 隐式声明为全局变量
全局变量的优缺点 

10.删除数组中索引为index的元素 
	`slice + ...` （返回值为被切割的数组）
	/ `splice` （返回值为删除的元素）并删除掉数组中对应的元素
11.替换数组中的某个/某几个元素 `splice` 
```

#### 0.函数特别的属性`prototype`

- 每个函数都有个`protoytype`属性 在定义函数时 `function Foo(){}`被自动赋值（默认为{}）也就是 ==默认**指向一个Object空对象**==

- 构造函数与原型对象是相互引用的关系
  - 构造函数Foo()通过prototype属性找到原型对象Object
  - 原型对象Object通过constructor属性找到构造函数Foo()

![在这里插入图片描述](https://img-blog.csdnimg.cn/ed78cd2515db4456a7f5184cb739134d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)



#### 0‘.实例对象特别的属性`__proto__`

实例对象的`__proto__`（隐式原型）就是其构造函数的`prototype`（显式原型）

- 在创建实例对象 `var fn = new Fn()` 时被自动添加 并赋值为构造函数的prototype值
- 原型对象（默认的那个空Object对象）就是当前实例对象的父对象（见下方1.隐式原型和显式原型的关系 的图）

#### 1.隐式原型&显式原型的关系

见下图

![请添加图片描述](https://img-blog.csdnimg.cn/c1585360f0e745408d78845f6fb21954.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)

#### 2.通过原型链获取对象内部的属性/方法

顺着隐式原型属性找就行~

![在这里插入图片描述](https://img-blog.csdnimg.cn/ac15bad11c2c4e64a323d2143f687d47.png)

想要调用实例对象中的方法 顺着原型链寻找就可以了（就是蓝色箭头指出来的路径）

如果原型链上没有方法

```js
fn.test1();
fn.test2();
fn.toString();
// 以上三个方法都可以顺着原型链找到~
fn.test3();//TypeError: fn.test3 is not a function
```



#### 3.原型链 函数、Function、Object之间的关系（原型对象与实例对象的关系）

所有函数的隐式原型属性 `__proto__` 都是一样的 所以就有了下图这种情况

（Object也是由Function创建的 可以这么写

```js
var Foo = new Function();// 实际写的时候new会省去
Object = new Function();
Function = new Function();
```

）

![在这里插入图片描述](https://img-blog.csdnimg.cn/7817b937536c4edfb666347d1669272b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_10,color_FFFFFF,t_70,g_se,x_16)



#### 4.原型链属性问题 面试题

```js
function A(){}
A.prototype.n = 1;
var b = new A();
A.prototype = {
    n: 2,
    m: 3
}
var c = new A();

console.log(b.n, b.m, c.n, c.m)
```

> 提示：
>
> - 顺着原型链来找属性（方法同理）
> - 函数的prototype属性默认指向一个空对象
>   - 如果定义了新的prototype 比如上面4-7行 则指向新的空对象
>
> - 感觉比较乱的可以画个图

画个图就无比清晰了 如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2bb63294996f40769949f7754830cce6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

答案很清楚了 

b实例对象顺着原型链可以找到n=1 找不到m

c实例对象顺着原型链可以找到n=2 m=3

```js
// 1, undefined, 2, 3
```









#### 5.原型链属性问题（更深入） -面试题

这题明天晚上再研究下~

```js
function F(){}
Object.prototype.a = function(){
    console.log('a()')
}
Function.prototype.b = function(){
    console.log('b()')
}
var f = new F()
f.a()
f.b()
F.a()
F.b()
```



#### 6.全局变量的优缺点

来源 [JS中如何定义全局变量](https://www.cnblogs.com/keyi/p/6137259.html)

-  优点
   - 减少变量的个数
   - 减少由于实际参数和形式参数的数据传递带来的时间消耗
-  缺点
   - 全局变量保存在静态存贮区，程序开始运行时为其分配内存，程序结束释放该内存。与局部变量的动态分配、动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。
   - 全局变量破坏了函数的封装性能。函数象一个黑匣子，一般是通过函数参数和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量，那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。
   - 全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。

因此，如果不是万不得已，最好不要使用全局变量。

#### 7.删除数组中索引为index的元素 …配合slice & splice

- 利用展开运算符`…`和slice方法

```js
array = [0,1,2,3,4]
const index = 2
const newArray = [
    ...array.slice(0,index),
    ...array.slice(index+1)
]
console.log(newArray);// [0, 1, 3, 4]
```

这种方法在删除多个元素时很好用！

​	删除索引为2 4 6的元素

```js
array = [0,1,2,3,4,5,6]
const newArray = [
    ...array.slice(0,2),
    ...array.slice(3,4),
    ...array.slice(5,6)
]
console.log(newArray);// [0, 1, 3, 5]
```



- 使用splice进行连续地删除 返回值为被删除的那个元素

```js
array = [0,1,2,3,4]
// 从索引为2的位置开始 删除两个元素
array.splice(1,2);
console.log(array);// [0, 3, 4]
```



#### 8.替换数组中的某个元素 splice(index,number,用于替换的内容)

```js
array = [0,1,2,3,4]
// 从索引1开始 的两个元素 替换成"bill"
array.splice(1,2,"bill")
console.log(array)// [0, "bill", 3, 4]
```





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）
复习一下原型的内容 貌似明白一些了！
1.原型链面试题-p21
2.全局执行上下文和函数执行上下文的概念！
3.使用执行上下文栈解决递归！
```



#### 1.原型链属性问题（更深入） -面试题

```js
function F(){}
Object.prototype.a = function(){
    // Object的原型对象上增添了一个a方法
    console.log('a()')
}
Function.prototype.b = function(){
    console.log('b()')
}
var f = new F()
f.a()//【1】可以找到
f.b()//【2】报错 b不是一个函数
F.a()//【3】可以找到
F.b()//【4】可以找到
```

##### 【1】实例对象f 顺着原型链（的`__proto__`属性）

`->实例对象F()->空Object对象->Object对象的显式原型`

 可以在Object的显示原型上找到a方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/6bde9386d5414af2a21f8fad655e8424.png)

##### 【2】同理  顺着原型链找 

`->实例对象F()->空Object对象->Object对象的显式原型->null`

Object对象的显式原型就是原型链的尽头了！没法再找到Function的原型对象了！

![在这里插入图片描述](https://img-blog.csdnimg.cn/fed8f4e733fe486890b312bcd60bd4e7.png)

##### 【3】从函数对象 通过隐式原型属性（也是有的） 顺着原型链找

> 这里需要注意 直接打印F 是没有办法获得它的 `__proto__` 属性的 
>
> 可以通过其原型对象的constructor来获取（见下图）



`->Function对象的显式原型->Object对象的显式原型`

![在这里插入图片描述](https://img-blog.csdnimg.cn/98c5698e603342d5b916fdf65b25433f.png)

> 另外注意 函数F()的**隐式原型属性**是由Function创建的~

##### 【4】同理 

画图出来就很清楚了！

==这个图要记在脑子里！==

`->Function对象的显式原型`

![在这里插入图片描述](https://img-blog.csdnimg.cn/e95fa85193854c2393ae7a353d1d46a4.png)

#### 2.全局执行上下文和函数执行上下文的概念

首先明确 **执行上下文** 是啥

- 执行上下文

由JS引擎自动创建的对象

包含**对应作用域**中的<u>所有变量属性</u>

> 之前看红宝书的时候 里面提到 上下文就是对应作用域 
>
> 那么这个执行上下文就是个被JS引擎创建的对象 包含作用域中所有变量属性？
>
> - 回头看红宝书时/了解到这个知识之后 要能回忆起现在的疑惑哈哈哈

- 全局执行上下文

在==全局代码执行前==【1】最先创建一个全局执行上下文(window)

【2】注意 这个过程会**收集全局变量并初始化**

【3】这些变量会被设置为**window**的属性



- 函数执行上下文

在【1】==调用==函数时, 在执行函数体之前先创建一个函数执行上下文

【2】注意 这个过程会收集局部变量, 并初始化

【3】这些变量会被设置为**对应执行上下文**的属性



#### 3.使用执行上下文栈解决递归！

先明确下上下文**栈**的概念

这段代码——

```js
// 01 进入全局执行上下文
var a = 10;
var bar = function(x){
    var b = 5;
    // 03 进入foo函数执行上下文
    foo(x + b);
}
var foo = function(y){
    var c = 5;
    console.log(a + c + y);
}
bar(10);// 02 进入bar函数执行上下文
```

对应的入栈、出栈的操作如下

![在这里插入图片描述](https://img-blog.csdnimg.cn/a8e415aa4bb74309a5a68e12e4fba94e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_20,color_FFFFFF,t_70,g_se,x_16)

（图有点丑 见谅）



下面看看如何用执行上下文栈的思想解决递归（真的是可以想清楚的哦！）



```js
foo(1);
function foo(i) {
    if (i == 4) {
        return;
    }
    console.log('foo() begin:' + i);
    foo(i + 1);
    console.log('foo() end:' + i);
}
```

想一下 输出是什么呢？

来看看执行上下文栈

（具体流程就不画了 就是先入栈 再出栈嘛！ 其中foo(4)没有输出 因为直接返回结果了~

![在这里插入图片描述](https://img-blog.csdnimg.cn/2bb63294996f40769949f7754830cce6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

另外注意 整个过程产生了五个执行上下文哦！





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）刷freecodecamp
1.复习下执行上下文的三道面试题 不难 理解了全局上下文 函数上下文 变量提升 函数提升 可以快速理解
2.回忆了一下 真正开发中从没用过的switch语句
3.box-shadow 加阴影 
4.transform:uppercase; 变大写
5.line-height 复习一下 设置“行间”的距离 但是并不是两行之间距离的意思 而是这一行的“行高” 是”每行文字所占据的垂直空间“
6.相对定位一个有意思的用法
```

> 来复习三道面试题！

明天再看！今天没时间搞这个惹







#### 2.switch简单复习

```js
switch(val){
    case 1:
        xxx
       	break;
    case 2:
        xxx
        break;
}
```

还可以添加多个选项（这个还真没见过！）

```js
switch(val){
    case 1:
    case 2:
    case 3:
        answer = "Low";
        break;
    case 4:
    case 5:
    case 6:
        answer = "Mid";
        break;
    case 7:
    case 8:
    case 9:
        answer = "High";
        break;
}

```



#### 3.box-shadow加阴影

`box-shadow` 属性的阴影依次由下面这些值描述：

- `offset-x` 阴影的水平偏移量（水平阴影的位置）； 必需
- `offset-y` 阴影的垂直偏移量（垂直阴影的位置）； 必需
- `blur-radius` 模糊半径； 可选
- `spread-radius` 阴影扩展半径（也就是阴影的尺寸）；可选
- `color` 可选

- `inset` 可将外部阴影改为内部阴影 可选

```css
box-shadow: h-shadow v-shadow blur spread color inset;
```

注意：省略长度的值是 0。

#### 4.相对定位的用法

- 普通文档流

在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。 

块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。

元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了 position 属性来覆盖它。

##### 很有用的相对定位！

- 相对定位**不会导致元素脱离文档流** 可以方便地**向某个方位移动**某个元素

当元素的定位设置为 `relative` 时，它允许你通过 CSS 指定该元素在当前文档流页面下的*相对*偏移量。 CSS 里控制各个方向偏移量的属性是 `left`、`right`、`top` 和 `bottom`。 它们代表**从原来位置向远离该方向***偏移*指定的像素、百分比或者 em。 

```css
top:10px; /* 远离top的位置移动10px 也就是向下移动10px */
```

> 把元素的位置设置成相对，并**不会改变该元素在布局中所占的位置**（它不会脱离文档流 也就是不会被其他元素忽略），也不会对其它元素的位置产生影响。

##### 相对定位的一些有趣用法

定位可以使页面布局更灵活、高效。 不管元素的定位是怎样的，HTML 标记在从上到下阅读起来时应该是整洁的、有意义的。 

这样可以让视障人士（重度依赖辅助设备比如屏幕阅读软件的人们）也能够**无障碍**地浏览你的网页。





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）刷freecodecamp
1.复习下执行上下文的三道面试题 不难 理解了全局上下文 函数上下文 变量提升 函数提升 可以快速理解 这个在明天
2.for循环中一些神奇的效率问题
3.利用label标签绑定按钮~
4.利用css3 input:checked+label 做到“点击某个input框就赋予label属性”
5.很好的知识点 new操作符干了什么？
```







#### 2.for循环中 计算数组长度

```js
for(let i = 0; i < nums.length; i++){
    // 这样需要反复计算nums的长度 不好！
}
for(let i = 0,length = nums.length; i < length; i++){
    
}
```

因为事件的响应函数是点击的时候才触发调用的，在点击之前只是声明了但并没有调用过响应函数

而点击按钮的时候都能触发响应函数了，说明for循环已经执行完了，因为只有for循环执行完了才会给每个按钮都绑定上了响应函数



#### 3.闭包前瞻 按钮点击案例

![在这里插入图片描述](https://img-blog.csdnimg.cn/7c3499f59bae4a178a9067a87b5ccbd7.png)

```js
// 先获取模板
var btns = document.getElementsByTagName('button')
```

采用循环遍历 + 监听

```js
//有问题 点哪个按钮都输出“第4个” 
// 因为i是全局变量 一趟循环走完i=3 
// 在点击的时候i就是3了
// let i = 0就ok了 i变为局部作用域中的变量
for(var i=0,length=btns.length;i<length;i++) {
    var btn = btns[i]
    btn.onclick = function () {
        alert('第'+(i+1)+'个')
    }
}
```

保存一下 下标 可以解决这个

```js
//解决一: 保存下标
// JS基础 轮播图中 学过类似的用法 
for(var i=0,length=btns.length;i<length;i++) {
    var btn = btns[i]
    btn.index = i
    btn.onclick = function () {
      alert('第'+(this.index+1)+'个')
    }
}
```

另外就是采用 闭包 的方法

```js
//解决办法: 循环遍历 + 利用闭包
for(var i=0,length=btns.length;i<length;i++) {
    // LIFE立即执行函数
    // 函数中的i是局部的
    (function (i) {
        var btn = btns[i]
        btn.onclick = function () {
            alert('第'+(i+1)+'个')
        }
        // 下面那个i是全局的！
    })(i)
}
```

#### 4.利用label标签实现“点击标签也可以勾选input框“效果（绑定按钮~）

```html
<div class="item">
    <!-- input元素的这个属性checked="false" 代表被划掉 -->
    <input type="checkbox" id="check1">
    <label for="check1">This is an inbox layout.</label>
</div>
```

关键在于这个label的for属性



#### 5.`input:checked+label` 做到“点击某个input框就赋予label属性”

```css
/* 勾选某个input元素 就给label元素赋予这些属性 */
input:checked+label {
    background: #F9F9F9;
    text-decoration: line-through;
}
```



#### 6.new关键字都做了什么？

> 明天来总结下这里 写一篇文章~

在没有学习原型之前 我们可以这么给出定义——

- 【1】创建一个类（或者模拟类 比如说构造函数~）的实例对象

  

那么学过原型之后 我们知道 JS中的new关键字还背负着一些使命

这里涉及了原型、this指向、作用域、函数return的知识

举个例子来把内容串起来~

```js
function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.getName = function(){
    console.log(this);//
    return this.name;// 通过this调用新创建的对象实例中的属性
};

var person = new Person("bill",21);
console.log(person.name,person.age);// bill 21
person.getName();//"bill"
```

上面那些代码中是看不出来new关键字做了什么的！

我们用伪代码模拟下上述过程的执行过程 也就是这一句

```js
var person = new Person("bill",21);
```

等同于下面内容

```js
new Person('bill',21) = {
    var obj = {};
	obj.__proto__ = Person.prototype;
	var res = Person.call(obj, 'bill', 21);// 单独的方法也可以这么用 
// func.call(obj) 赋给obj对象func方法！
	return res;//这里先不考虑构造函数有return 毕竟比较少见
}
```



- 【1】创建了一个新的空对象 `{}`

```js
var obj = {};
```



- 【2】将新对象的 `__proto__` 指向构造函数的 `prototype` 属性
  - 也就是设置这个对象原型指向构造函数

```js
obj.__proto__ = Person.prototype;
```



- 【3】将构造函数的作用域赋值给新对象（this指向新创建的空对象）

> 这里注意 在执行构造函数中的代码时 会为这个新对象添加属性 同时this会指向新创建的对象
>
> 之后 this关键字被提及的时候 可以调用新创建的对象的属性/方法 `this.name`  `this.func()`

```js
var res = Person.call(obj, 'bill', 21);
```



- 【4】返回新对象（这里注意 如果构造函数中return一个对象 那么会返回return的内容 而不是创建的这个对象！！）

```js
return res;
```

##### 原型链必会概念

```js
// 要有顺着原型链找东西的技巧 
// 甭管是 常规的 找方法、找属性
// 还是面试中可能问的找构造函数 找Function Object的显式原型
/*（比如写一个 Function.prototype.func = function(){...} 
 要知道这个func方法 哪些实例对象可以调用（顺着原型链的隐式原型那条路线要能抵达Function的显式原型 那就能用那上面的方法！） */
var Foo = function(){...};
var foo = new Foo();                       
console.log(foo.__proto__.__proto__ === Object.prototype;)//true 
```





脑子里要有这幅图~

![在这里插入图片描述](https://img-blog.csdnimg.cn/fed8f4e733fe486890b312bcd60bd4e7.png)





另外这张图可以帮助理解一下~

可以看到实例对象的变量 顺着原型链可以找到Object的原型对象 

Object的原型对象上有很多定义好的方法~

> 另外Object的原型对象与Function的原型方法也有联系 看上图即可~

![在这里插入图片描述](https://img-blog.csdnimg.cn/ac15bad11c2c4e64a323d2143f687d47.png)





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）刷freecodecamp
1.复习下执行上下文的三道面试题 不难 理解了全局上下文 函数上下文 变量提升 函数提升 可以快速理解
2.掘金写文章总结 new操作符干了什么？
3.","运算符
```

> 来复习三道面试题！

#### 1.执行上下文面试题

- 面试题1

**先执行变量提升 再执行函数提升** —— 变量提升优先级高！(注意 如果在初始化变量中给变量赋初值 效果看起来会像先函数提升 之后变量才被提升一样 其实应该是函数先的！（本例就可以体现这一点）)

【1】变量提升 a为undefined

【2】函数提升 a为函数

```js
function a() {alert(666)}
var a;
console.log(typeof a)// 'function'
```

**如果在初始化变量中给变量赋初值 a重新变成number类型**

就像下面这题一样

- 面试题2

与上一题搭配使用

【1】变量提升 定义了c变量

【2】函数提升（比变量提升靠后）定义了函数

【3】在函数提升之后 给c再赋值为1

```js
var c = 1
function c(c) {
    console.log(c)
    var c = 3
}
c(2)//
```

这段代码相当于

```js
var c;//变量提升
function c(C){...}
c = 1;//最终c是Number类型的！
```



- 面试题3

这题相当有意思！哈哈

```js
if (!(b in window)) {
    // 变量提升 b是在window全局执行上下文中的 
    // 所以 if中的内容为false 无法给b赋值了！
	var b = 1;
}
console.log(b)// undefined
```





#### 2.new关键字都做了什么？

> 今天来总结下这里 写一篇文章~
>
> [JS小知识 new关键字都做了什么？](https://juejin.cn/post/7012887169878458404/)

在没有学习原型之前 我们可以这么给出定义——

- 【1】创建一个类（或者模拟类 比如说构造函数~）的实例对象

  

那么学过原型之后 我们知道 JS中的new关键字还背负着一些使命

这里涉及了原型、this指向、作用域、函数return的知识

举个例子来把内容串起来~

```js
function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.getName = function(){
    console.log(this);//
    return this.name;// 通过this调用新创建的对象实例中的属性
};

var person = new Person("bill",21);
console.log(person.name,person.age);// bill 21
person.getName();//"bill"
```

上面那些代码中是看不出来new关键字做了什么的！

我们用伪代码模拟下上述过程的执行过程 也就是这一句

```js
var person = new Person("bill",21);
```

等同于下面内容

```js
new Person('bill',21) = {
    var obj = {};
	obj.__proto__ = Person.prototype;
	var res = Person.call(obj, 'bill', 21);// 单独的方法也可以这么用 
// func.call(obj) 赋给obj对象func方法！
	return res;//这里先不考虑构造函数有return 毕竟比较少见
}
```



- 【1】创建了一个新的空对象 `{}`

```js
var obj = {};
```



- 【2】将新对象的 `__proto__` 指向构造函数的 `prototype` 属性
  - 也就是设置这个对象原型指向构造函数

```js
obj.__proto__ = Person.prototype;
```



- 【3】将构造函数的作用域赋值给新对象（this指向新创建的空对象）

> 这里注意 在执行构造函数中的代码时 会为这个新对象添加属性 同时this会指向新创建的对象
>
> 之后 this关键字被提及的时候 可以调用新创建的对象的属性/方法 `this.name`  `this.func()`

```js
var res = Person.call(obj, 'bill', 21);
```



- 【4】返回新对象（这里注意 如果构造函数中return一个对象 那么会返回return的内容 而不是创建的这个对象！！）

```js
return res;
```

##### 原型链必会概念

```js
// 要有顺着原型链找东西的技巧 
// 甭管是 常规的 找方法、找属性
// 还是面试中可能问的找构造函数 找Function Object的显式原型
/*（比如写一个 Function.prototype.func = function(){...} 
 要知道这个func方法 哪些实例对象可以调用（顺着原型链的隐式原型那条路线要能抵达Function的显式原型 那就能用那上面的方法！） */
var Foo = function(){...};
var foo = new Foo();                       
console.log(foo.__proto__.__proto__ === Object.prototype;)//true 
```





脑子里要有这幅图~

![在这里插入图片描述](https://img-blog.csdnimg.cn/fed8f4e733fe486890b312bcd60bd4e7.png)





另外这张图可以帮助理解一下~

可以看到实例对象的变量 顺着原型链可以找到Object的原型对象 

Object的原型对象上有很多定义好的方法~

> 另外Object的原型对象与Function的原型方法也有联系 看上图即可~

![在这里插入图片描述](https://img-blog.csdnimg.cn/ac15bad11c2c4e64a323d2143f687d47.png)

#### 3.神奇的“,”运算符

```js
// 顺带复习下LIFE立即执行函数
var fn = (
    function test1(){
        return 1;
    },
	function test2(){
        return '2';
    }
)();
var num = (1,2);
// 01 先来输出这个数值 输出的是逗号后面的值
// 另外 之前一直没见过这样子的数值~
console.log(num);// 2
console.log(typeof(num));// number
// 02 再来输出下立即执行函数 发现逗号后面那个才是本体~
console.log(typeof(fn));//
```



#### 4.call()方法

[JavaScript 函数 Call](https://www.w3school.com.cn/js/js_function_call.asp)

用于达到“**方法重用**”的效果

使用 call() 方法，您可以编写能够**在不同对象上使用的方法**。

简单来说就是这样——

```js
方法拥有者（对象）.方法.call(另一个对象)
```



##### 函数是对象的方法

在 JavaScript 中，函数是对象的方法。

**如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数**（这个结论妙啊！！）



下面的例子创建了带有三个属性的对象（`firstName、lastName、fullName`）。

```js
var person = {
    firstName:"Bill",
    lastName: "Gates",
    fullName: function () {
        return this.firstName + " " + this.lastName;
    }
}
person.fullName();// "Bill Gates"
```

==`fullName` 属性是一个*方法*。person 对象是该方法的*拥有者*==。



call() 方法是预定义的 JavaScript 方法。

它可以用来调用所有者对象作为参数的方法。

通过 call()，您能够使用属于另一个对象的方法。

本例调用 person 的 fullName 方法，并用于 person1：



```js
var person = {
    fullName: function() {
        return this.firstName + " " + this.lastName;
    }
}
var person1 = {
    firstName:"Bill",
    lastName: "Gates",
}
var person2 = {
    firstName:"Steve",
    lastName: "Jobs",
}
person.fullName.call(person1);  // 将返回 "Bill Gates"
// 方法拥有者（对象）.方法.call(另一个对象)
```



##### 同时call方法可以接受参数 

```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
person.fullName.call(person1, "Seattle", "USA");//Bill Gates,Seatle,USA

person.fullName.call(person1, "Seattle");//Bill Gates,Seatle,undefined
```





```js
//每日学到的知识点 可以写文章 可以记在心里 总结下来！
// 本阶段主要学习JS高级教程（尚硅谷）刷freecodecamp
1.创建数组副本的方式 arr.slice()
2.利用slice拼接字符串！！！
```



#### 1.arr.slice()创建数组副本

```js
constructor(props){
    super(props);
    this.state = {
        squares: Array(9).fill(null),
        xIsNext: true,// x为下一步 设置为true 棋子移动一步 xIsNext反转一下
    };
}

const squareArr = this.state.squares.slice();
```





#### 2.通过slice方法拼接字符串 来达到各种目的

在使用JS完成字符串的题目时 可以使用slice方法秒杀！！

比如

```js
// 输入ABCDE
// 输出ABCDE DEABC BCDEA EABCD CDEAB
// 这样拼接就好了！！！超级简单
```

```js
string = 'ABCDE';
for(let i = 0; i < string.length; i++){
    console.log(string);
    string = string.slice(string.length - 2) + 	string.slice(0,string.length - 2);
}
```

