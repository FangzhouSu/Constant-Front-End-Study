参考资料：

- [前端算法与数据结构面试：底层逻辑解读与大厂真题训练](https://juejin.cn/book/6844733800300150797)

提纲：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/24/171ac6e4faf30ecf~tplv-t2oaga2asx-watermark.awebp)

- [代码随想录](https://programmercarl.com/)

# 基础数据结构

# 01 数组















# 02 链表

数组、字符串若想往难了出，那一定是要结合一些超越数据结构本身的东西——比如排序算法、二分思想、动态规划思想等等

但是链表可不一样了。如果说在命题时，数组和字符串的角色往往是“算法思想的载体”，那么链表本身就可以被认为是“命题的目的”。

结合实际面试中的命题规律，我把这些题目分为以下三类：

- 链表的处理
  - 合并
  - **删除**（重点！）
- 链表的反转 以及 衍生题目
- 链表成环问题 以及 衍生题目

[快速上手——从0到1掌握算法面试需要的数据结构（二）-栈、队列、链表](https://juejin.cn/book/6844733800300150797/section/6844733800342093837)

[链表的应用——真题归纳与解读](https://juejin.cn/book/6844733800300150797/section/6844733800350498823)

### 【1】链表的合并

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)（递归法重要！）

这俩题一样哈——[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

##### 迭代法

```js
var mergeTwoLists = function(l1, l2) {
    let dummyHead = new ListNode(0, l1);
    let cur = dummyHead;
    while(l1 !== null && l2 !== null){
        if(l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        }
        else{
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    cur.next = l1 === null ? l2 : l1;
    return dummyHead.next;
};
```



##### 递归

```js
var mergeTwoLists = function(l1, l2){
    if(l1 === null){
        return l2;// 碰到一个链表走到null 就结束“递” 开始归
    }
    else if(l2 === null){
        return l1;
    }
    else if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next, l2);
    }
    else{
        l2.next = mergeTwoLists(l1, l2.next);
    }
}
```

[递归法图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)

递归就思考第一层第二层最好

每层不要忘了返回当层结果（执行这一次递归函数 返回的结果）！

以原始用例 [1,2] [1,3,4]

【1】**开始“递”** 一直到最里面那一层 

- l1小的时候 l1指向再里层一些的那个递归函数`mergeTwoLists()`别忘了l1要往前挪动一位 `mergeTwoLists(l1.next, l2)`
- l2小的时候同理

![img](https://pic.leetcode-cn.com/fe5eca7edea29a76316f7e8529f73a90ae4990fd66fea093c6ee91567788e482-%E5%B9%BB%E7%81%AF%E7%89%874.JPG)

【2】return l2 执行时

![img](https://pic.leetcode-cn.com/e59fd2981f3633cc70a90bd3136e07647ecf89c6f4eefb82159ea54db9772889-%E5%B9%BB%E7%81%AF%E7%89%875.JPG)

**这里结束了“递”** 

最里面那层的`mergeTwoLists()`执行完了

开始“归” —— 逐步执行外层的`mergeTwoLists()`函数

【3】最外面一层函数执行完 

![img](https://pic.leetcode-cn.com/e95ec0c841cfa308e5789eb1f9f214f785bc77d99214c01504b303939581eb07-%E5%B9%BB%E7%81%AF%E7%89%877.JPG)

就可以返回最终结果了~

![img](https://pic.leetcode-cn.com/c1687ef7811036b7b5e58e4882ed12e243f6a77ddb8077123f013ef094cafd73-%E5%B9%BB%E7%81%AF%E7%89%878.JPG)

小结一下——

- 想一下“哪个是最里层被调用的函数” 在那里返回对应结果
  - 也就是主要想**第一层**

### 【2】链表的删除

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)



```js
var deleteDuplicates = function(head) {
    // 第二次做的反而想得太复杂？不要太想当然！
    // let dummyHead = new ListNode(0, head);
    // let pre = dummyHead;
    let cur = head;
    // if(cur === null){
    //     return null;
    // }
    while(cur !== null && cur.next !== null){
        if(cur.val === cur.next.val){
            cur.next = cur.next.next;
        }
        else{
            cur = cur.next;
        } 
    }
    return head;
};
```



### 【3】链表删除的延伸



#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

但是现在，咱们要做的事情变成了把前驱和后继一起删掉，前面两个值为1的结点要一起狗带才行，起始结点直接变成了第三个：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7079d7513b3e~tplv-t2oaga2asx-watermark.awebp)

如果继续沿用刚才的思路，我们会发现完全走不通。因为我们的 cur 指针就是从图中第一个结点出发开始遍历的，无法定位到第一个结点的前驱结点，删除便无法完成。

> 虚拟头结点应用场景：

其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 `dummy` 结点来解决这个问题。

> 本题思路

如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7116f49a1dc4~tplv-t2oaga2asx-watermark.awebp)

如此一来，就大功告成啦~

注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。

```js
const deleteDuplicates = function(head) {
    // 极端情况：0个或1个结点，则不会重复，直接返回
    if(!head || !head.next) {
        return head
    }
    // dummy 登场
    let dummy = new ListNode() 
    // dummy 永远指向头结点
    dummy.next = head   
    // cur 从 dummy 开始遍历
    let cur = dummy 
    // 当 cur 的后面有至少两个结点时
    while(cur.next && cur.next.next) {
        // 对 cur 后面的两个结点进行比较
        if(cur.next.val === cur.next.next.val) {
            // 若值重复，则记下这个值
            let val = cur.next.val
            // 反复地排查后面的元素是否存在多次重复该值的情况
            while(cur.next && cur.next.val===val) {
                // 若有，则删除
                cur.next = cur.next.next 
            }
        } else {
            // 若不重复，则正常遍历
            cur = cur.next
        }
    }
    // 返回链表的起始结点
    return dummy.next;
};
```







# 03 字符串



























# 04 二叉树























































# 05 栈与队列















# 排序算法

















# 解题技巧

# 01 双指针













# 02 哈希表



















# 03 前缀和

















# 04