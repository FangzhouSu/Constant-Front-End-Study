> 🎉重中之重的前端基础🎉

> 主要为
>
> - HTML
> - CSS
> - JavaScript
>
> 的必会知识点们
>
> > 内容来源：《JavaScript高级程序设计~（第四版）~》/ 众多大佬们的知识博客/ 自己学习过程中记录的笔记/ [MDN文档](https://developer.mozilla.org/zh-CN/docs/Web)



# HTML

## 常用标签、语义化标签

[HTML标签 参考手册](http://yige.org/html5/reference.php) 

#### `<select>&<option>`

select 元素**可创建单选或多选菜单**。

下方代码效果创建带有 4 个选项的选择列表：

```html
<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>
```

下方效果需在Typora（也许其他文本编辑器也行？）中**长按**来显示

<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>



## HTML标签属性相关



## HTML事件相关



## HTML5新增内容

[HTML5标签 参考手册](http://yige.org/html5/reference.php) 其中带new标签的是HTML5中的新标签



# CSS

## 盒模型



## 选择器、样式权重



## CSS常用属性（如：position）

#### [CSS position属性 - MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position)

#### [使用绝对定位实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-5)



## CSS常用布局（如：flex、grid）

### Flex布局

> 优质练习资源 [小青蛙找荷叶](https://flexboxfroggy.com/?utm_source=gold_browser_extension#zh-cn)
>
> [官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

#### 小青蛙案例24关

```css
#pond {
    display: flex;
	flex-direction:column-reverse;/* 改变排列方式为竖直倒序 */
    align-content: space-between;/* 决定行与行之间的距离 */
    flex-wrap: wrap-reverse;/* 自动换行成多行（默认为强制在一行） */
	justify-content: center;/* 居中 */
}
```

效果如下：

![image-20211111165046955](https://gitee.com/su-fangzhou/blog-image/raw/master/202111111650078.png)



#### 经典问题-[利用布局实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-3)



## CSS动画相关（animation）

## CSS浮动相关（float）

> 浮动这块儿讲究可多咧！回头还需要多研究下呐！

#### 浮动的作用

- 设置浮动的图片——实现文字环绕图片
- 设置了浮动的块级元素可以排列在同一行
- **设置了浮动的行内元素可以设置宽高** - `涨知识系列`
- 可以按照浮动设置的方向对齐排列盒子 - `没见过这用法`

#### 设置浮动元素的特点

- 设置了浮动，该元素脱离文档流。元素不占位置
- 如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的**高度**就**塌陷**了，同时也会造成父级盒子后面的兄弟盒子布局受到影响

清除浮动的方法

- 伪元素清除浮动

```css
.clearfix::after {
    content: ''; 
    display: table; 
    clear: both;
 }
```



- 给浮动元素父级添加 `overflow:hidden;`
- 额外标签法：给浮动元素父级增加标签

```css
<div class="wrap">
    <div class='left fl'></div>
    <div class='right fl'></div>
    <div style='clear:both'></div>
</div>
```



##### 清除浮动的特点和影响

- 伪元素清除浮动：不会新增标签，不会有其他影响，是当下清除浮动最流行的方法
- `overflow：hidden;`不会新增标签，但是如果父级元素有定位元素超出父级，超出部分会隐藏，在不涉及父级元素有超出内容的情况，overflow：hidden比较常用，毕竟写法方便简洁
-  标签插入法：清除浮动的语法加在新增标签上，由于新增标签会造成不必要的渲染，所以这种方法目前不建议使用







## 移动端适配

## 响应式布局

## CSS3新增内容



# JavaScript

## JS变量与数据类型

### 七种基本数据类型，一种引用数据类型

- 写过一篇文章 [重学数据（类型）、变量、内存](https://juejin.cn/post/7015057932135956487)，

  - 聊了一下这几个数据类型要如何通过typeof instanceof判定；

  - 聊了一下内存的问题——

    - 基本数据类型赋值给变量，变量存在栈中；
    - 引用数据类型赋值给变量，变量存在栈中，而对象保存在堆中，变量指向堆~

    ![image-20211031143811230](https://gitee.com/su-fangzhou/blog-image/raw/master/202110311438372.png)

- 基本数据类型

![image-20211031103940566](https://gitee.com/su-fangzhou/blog-image/raw/master/202110311039729.png)

```js
var a = 1, b = 2;
function test(pre, cur){
    pre = "hello world";// 函数作用域中的pre为"god"
    cur = 666;// 函数作用域中的cur为666
    // 这二位都不会影响到a b
}
function test2(){
    a = a++;
    b = 666;
}
test(a, b);
console.log(a, b);// 1 2
test2();
console.log(a, b);// 1 666
```



- 引用类型

Object 





### 隐式类型转换

#### `==`中的隐式类型转换

根据红宝书复习的内容



## Array类型相关知识，及常见api

> ES5新增的Array API
>
> [张鑫旭大佬的博客](https://www.zhangxinxu.com/wordpress/2013/04/es5%e6%96%b0%e5%a2%9e%e6%95%b0%e7%bb%84%e6%96%b9%e6%b3%95/)

> 下面这些内容大部分为红宝书的内容，回头进行整理

#### 1.创建数组的静态方法 from of

from()用于将 类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例

#### 2.数组空位

由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。

如果确实需要空位，则可以显式地用 undefined 值代替。

#### 3.length属性

数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除 / 添加元素

#### 4.数组检测

一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作 用域）的情况下，使用 `instanceof` 操作符就足矣：

> 使用 `instanceof` 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

为解决这个问题，ECMAScript提供了 `Array.isArray()`方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的

#### 5.迭代器方法 keys values entries

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回**数组索引**的迭代器，values()返回**数组元素**的迭代器，而 entries()返回**索引/值对**的迭代器：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a3256ed51ed4962adf90e49b842d086.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)

#### 6.数组复制与填充问题



![在这里插入图片描述](https://img-blog.csdnimg.cn/d15476210f1e4b9dbc986137f8d5d056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)



```js
const zeros = [0,0,0,0,0];
//zeros.fill(填充数字,填充索引起始,填充索引结束前一位);
zeros.fill(7, 1, 3);
console.log(zeros);//[0,7,7,0,0]
```

```js
let ints,
    reset = {} => ints =[0,1,2,3,4,5,6,7,8,9];

//ints.copyWithin(插入位置的索引,复制的索引起始,复制的索引结束前一位);
ints.copyWithin(4,0,3);//[0,1,2,3, 0,1,2, 7,8,9]
```

#### 7.数组->字符串

得到——以逗号分隔数组值的字符串

- `toLocaleString()`
- `toString()`
- `数组.valueOf()`

得到——以传入参数分割数组值的字符串

> 而 `包装对象实例.valueOf()` 则返回包装对象实例对应的原始类型的值
>
> ```js
> new Number(123).valueOf()  // 123
> new String('abc').valueOf() // "abc"
> new Boolean(true).valueOf() // true
> ```

- `join("xxx")`



#### 8.数组的栈方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/118c90aad04e420ea95dbe5868e2af8a.png)



#### 9.数组的队列方式

就只有 入队列的方法与栈不同 其他方法是一样的

使用shift

插入到队头



#### 10.数组排序方法 sort

sort 这个sort有个坑 所以一般不直接用 

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4cb8f58a27f482ba15f6124bfaacb7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)



#### 11.数组的操作方法-增加元素 单独切一段元素 插入元素 concat slice splice

- `concat()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ae3411e563ea4818af0be79c79571d76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

- `slice()`

![请添加图片描述](https://img-blog.csdnimg.cn/72702c8f27664677964f4c08582cb9dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



- `splice()`

![请添加图片描述](https://img-blog.csdnimg.cn/562f8ba16eb742e39d20baafbd23ba49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

#### 12.搜索数组中元素的位置 indexOf

![在这里插入图片描述](https://img-blog.csdnimg.cn/80a68236760b480dbc2ddd50c896d519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 13.迭代方法 - 各种高级操作 filter map forEach

超级好用的几个方法！

- `every()`
- `some()`
- `filter()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca565154c7664d0a8c01b45a30397477.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)

- `map()`
- `forEach()`

![请添加图片描述](https://img-blog.csdnimg.cn/b16fc430c789416aaeb99134b28a7cd5.png)

#### 14.归并方法 reduce

- `reduce()`

这里的reduce的第一个参数 prev要注意

如果求和时  一般会给其起名为total 用于存储截至此时的和 

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ccc715666954883ad908dff58bff2a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 15.Map集合类型的基本API

明确Map实例的格式 为 键值对 

```js
const map = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])
```

- set() 添加键值对
- get() 获得某个键的值
- has() 查询是否有这个键
- `.size()` 获取键值对数量
- delete() 删除某个键值对
- clear() 清除映射实例中的所有键值对
- [entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) 返回一个新的包含 `[key, value]` 对的 `Iterator` 对象，返回的迭代器的迭代顺序与 `Map` 对象的插入顺序相同。
- [forEach()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach) 按照插入顺序依次对 `Map` 中每个键/值对执行一次给定的函数
- [values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values)它包含按顺序插入Map对象中每个元素的value值。

举例：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a78321c557bb42b797bd84877bc5fe04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

另外 与Object只能使用数值、字符串、符号作为键不同

Map可以使用**任何JS数据类型**作为键！！（这也是为啥ES6要创键这个集合类型）



- 另外注意 Map实例对象2个有趣的特性：

  - 一个key放入多个value —— 覆盖原先的value

  ```js
  var m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam');//88
  ```

  可以看出 key是不允许重复的！这也符合哈希表特性

  但是重复了也不会出错 自动就覆盖掉了

  - 值重复就没啥事儿（那肯定的嘛）

  ![请添加图片描述](https://img-blog.csdnimg.cn/b7e9d37dcc56444085727559a46704ef.png)

#### 16.迭代Map实例（按照插入顺序）

p191

又看到了 .entries() 迭代器方法！

——可以返回key value

#### 17.Set集合类型的基本API 

跟Map的大多数API 和 行为 都是共有的

也是一组key的集合，但**不存储value**。                  

- 要创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
//其实跟map的初始化方法是一样的 就是初始化内容不同而已
```

由于key不能重复，所以，在`Set`中，key是无法像Map实例中一样 可以覆盖的！

- `.size`
- `has()` 判断有没有这个元素
- `clear()`
- `add()` 与map的set添加一组键值对不同 set添加个元素就好了



#### 18.apply方法的使用

通过 [apply() 方法](https://www.w3school.com.cn/js/js_function_apply.asp)，您能够编写用于不同对象的方法。（与call()方法非常类似,只有传参时有区别）

##### 方法重用

```js
var person = {
  fullName: function() {
    return this.firstName + "调用成功" + this.lastName;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
person.fullName.apply(person1); // Bill调用成功Gates
```



```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
// 还可以传参进去哈！与call不同于参数的类型 为 数组
person.fullName.apply(person1, ["Seatle", "USA"]); // Bill Gates,Seatle,USA
```

##### 可用于在数组上模拟max方法

您可以使用 `Math.max()` 方法找到（数字列表中的）最大数字：

由于 JavaScript 数组没有 max() 方法，因此您可以应用 `Math.max.apply()` 方法。

```js
Math.max(1,2,3);

let arr = [1,2,3]
Math.max.apply(null, arr); // 也会返回 3 注意：第一个参数填啥没影响的，本次使用中没他事儿~
```

##### JavaScript 严格模式

在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。

在“非严格”模式下，它成为全局对象。



## Object类型相关知识，及常见api

### 对象

> 对象是非常重要的概念

我们把对象理解为：**存放属性的容器**

- 常用的内置对象：Math **JSON** Map Set Array

  - JSON是序列化传输数据的方式（是一个数据格式）

    - `JSON.stringify()` 方法将一个 JavaScript 对象或值**转换为 JSON 字符串**

      - ```JS
        console.log(JSON.stringify({ x: 5, y: 6 }));
        // expected output: "{"x":5,"y":6}"
        
        console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
        // expected output: "[3,"false",false]"
        
        console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
        // expected output: "{"x":[10,null,null,null]}"
        
        console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
        // expected output: ""2006-01-02T15:04:05.000Z""
        ```

    - `JSON.parse()` 方法用来**解析JSON字符串**，构造由字符串描述的JavaScript值或对象

      - ```js
        const json = '{"result":true, "count":42}';
        const obj = JSON.parse(json);
        
        console.log(obj.count);
        // expected output: 42
        
        console.log(obj.result);
        // expected output: true
        
        ```

- 宿主对象

  - 浏览器宿主：Window、History、Location
  - Node宿主：global等

## 函数、类相关

### 原型与原型链



### 继承问题

> 通过原型链实现子类对父类的继承
>
> `Child.prototype = new Father();`
>
> 别忘了修正Child类显示原型的`constructor`
>
> `Child.prototype.constructor = Child`



### this关键字

> `this` 会作为变量**一直向上级词法作用域查找**，直至找到为止
>
> -[Vue官方文档](https://cn.vuejs.org/v2/guide/instance.html)

#### [MDN文档学习](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

##### 箭头函数没有自己的this指针，探究其通过 call 或 apply 调用后的局限性

> [Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
>
> `call()` 方法**使用一个指定的 `this` 值**和单独给出的一个或多个参数来**调用一个函数**。
>
> 该方法的语法和作用与 [`apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 方法类似，只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。
>
> ```js
> function.call(thisArg, arg1, arg2, ...)
> ```
>
> - thisArg
>
> 可选的。**在 *`function`* 函数运行时使用的 `this` 值。**
>
> > 请注意，`this`可能不是该方法看到的实际值：如果这个函数处于[非严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。
>
> - arg1, arg2, ...
>
> 指定的参数列表。

由于 箭头函数没有自己的this指针，通过 `call()` *或* `apply()` 方法调用一个函数时，只能传递参数（**不能绑定this**---译者注），他们的第一个参数会被忽略。（这种现象<u>对于bind方法同样成立</u>---译者注）

举个例子就知道了

```js
var adder = {
    base: 1,
    
    add:function(a){
        var f = value => value + this.base;
        return f(a);// thisArg未指定则默认指向全局对象adder
    },
    addThruCall:function(a){
        var b = {base: 666};
        var f = value => value + this.base;// 如果这里是个普通函数，则进行call时，将给b这个对象调用f方法，base为666
        return f.call(b, a);
    }
}
console.log(adder.add(1));// 2(adder.base + 1)
console.log(adder.addThruCall(1));// 2(依然是adder.base（而不是b.） + 1)
```



#### 阮大教程 偏基础，偏底层原理，例子很简单

this指向**函数运行时所在的环境**，那么为什么this关键字有这样的作用？函数的运行环境是如何决定的？看看阮一峰大大写得这篇文章，你会有新的感悟！（真的让我对内存、对象等知识都有了新的认识！）

[【阮大】JavaScript 的 this 原理](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

粘一下this的定义：

> 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的**运行环境**（context）。所以，`this`就出现了，它的设计目的就是**在函数体内部，指代函数当前的运行环境**。

#### 前辈笔记 例子很多，做完以后面试题应该是不怕了！

[this到底指向哪里？](https://note.youdao.com/ynoteshare/index.html?id=b2fab3b044aa90033395df0c8c9ca3a4&type=note&_time=1634385217314)

> 在JavaScript中`this`的指向总是让人很困惑，它到底指的啥？。`this`在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论`this`的指向。
>
> - ##### this在全局作用域中
>
> - ##### this在函数(function)里
>
> - ##### 在构造函数里的this指向
>
> - ##### 在事件处理器(event handler)中this的指向
>



> 总结：
>
> - 对于函数中的`this`，通过查看`()`左边所属的对象去确定，真的很好用。
> - 实质上，`this`是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的`this`的指向，`this`的指向就不会弄错了
>
> > 雀氏！在使用new关键字创建对象时，其中一步就是“构造函数内部的this被赋值为这个创建好的新对象（即this指向新对象）”（参考红宝书）
> >
> > ![在这里插入图片描述](https://img-blog.csdnimg.cn/2e9199be6e1d40df92a1d69246930628.png)



#### [深入理解JS函数中this指针的指向](https://www.cnblogs.com/zjjDaily/p/9482958.html)

> 又是一篇前辈的文章，例子和情景都很全面！
>



> 小结：
>
> 函数在执行时，会在函数体内部自动生成一个this指针。谁**直接调用产生这个this指针的函数**，this就指向谁。
>
> 由于js是采用的静态作用域（也叫词法作用域），这就意味着函数的执行依赖于**函数定义的时候**所产生（而不是函数调用的时候产生）的**变量作用域**。
>
> 在全局作用域中“定义”一个函数的时候，只会创建包含全局作用域的作用域链。只有“执行”该函数的时候，才会复制创建时的作用域，并将当前函数的局部作用域放在作用域链的顶端。
>
> 去取变量值的时候，首先看本函数里有没有该值，如果没有再到函数定义的外部去找

## 闭包、作用域相关（面试手写题常客）

#### 静态作用域的两道基础题

##### 面试题考察静态性-面试题1

```js
var x = 10;
function fn(){
    console.log(x);// 10
}
function show(f){
    var x = 20;
    f();
}
show(fn);// 打印10
```

记住一句话——

**在其他函数中被调用不影响x在打印语句中的值**（x在一开始定义的时候就确定了 打印的x是全局中的（毕竟是在人家全局那里调用的函数show嘛~））

> 21/10/17 更新 感觉可以用执行上下文来解释？毕竟涉及到了函数调用，很动态~
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/ff59c44a23bb42559efe8cb41512d7c8.png)

> 21/10/31更新
>
> 又见到了一次这道题
>
> 感觉上面的说法可能有一定道理，但是作用域的“静态性”才是最权威解释——在调用一个函数时，要找到它最开始被创建时的位置，进行寻值

##### 作用域链面试题~沿着作用域链找某个变量-面试题2

```js
var fn = function () {
    console.log(fn)//function(){console.log(fn)}
    var fn2 = function(){
      	console.log("找不到我吧~");
    }
}
fn()

var obj = {
    fn2: function () {
        console.log(fn2)// 报错 fn2 is not defined
        console.log(this.fn2)//function(){...}
    }
}
obj.fn2()
```

- 首先 第二行的打印是 fn对象（人家顺着作用域链就能轻松找到位于全局作用域中的fn咯~）
- 第十一行 报错 来看看fn2的心路历程
  - 先在fn2构造函数的函数作用域中找 没有定义过fn2！ 
  - 再去全局作用域里找 全局变量也没它这号变量！
  - 再去同级的函数作用域里找找行么？
    - 不行！😂

- 第十二行 打印fn2对象 加上this 表示obj对象 obj对象拥有这个fn2函数啊 没问题~





## 期约与异步函数

### promise、async、await相关

##### [理解 JavaScript 的 async/await](https://segmentfault.com/a/1190000007535316)

简单来说

> ```
> 如果await等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
> 
> 如果await等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
> ```

举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写

```javascript
function takeLongTime() {
    return new Promise(resolve => {
        setTimeout(() => resolve("long_time_value"), 1000);
    });
}

takeLongTime().then(v => {
    console.log("got", v);
});
```

如果改用 async/await 呢，会是这样

```javascript
function takeLongTime() {
    return new Promise(resolve => {
        setTimeout(() => resolve("long_time_value"), 1000);
    });
}

async function test() {
    const v = await takeLongTime();
    console.log(v);
}

test();
```

单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。

假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：

```javascript
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}

function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

现在用 Promise 方式来实现这三个步骤的处理

```javascript
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}

doIt();

// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
```

输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。

如果用 async/await 来实现呢，会是这样

```javascript
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}

doIt();
```

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，==几乎跟同步代码一样==

##### [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

### xhr、fetch相关（AJAX）





## 浏览器中的JavaScript

### DOM相关

#### DOM核心接口1

> 获取DOM中的节点

- [`document.getElementById('id')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById)
- [`document.querySelector('selecotrs')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector)
  - id、class
    - `querySelector('#root')`
  - 更高级一些——标签名、CSS属性值
    - `querySelector(input[name = 'login'])`name属性为login的input元素

#### DOM核心接口2

> 动态地创建节点并插入到DOM中

- [`element.style.xxx`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)(MDN里甚至没有中文ORZ)
  - 设置获取元素的属性
- [`document.createElement(要创建的标签名称/类名)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement)
- [`node.appendChild(子节点)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild)
  - 将子节点追加给父节点
- [`Element.innerHTML`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML)

#### DOM核心接口3

> 获取/设置元素的样式

- [`element.getAttribute(name)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getAttribute)
- [`element.setAttribute('属性名称', '属性的值/新值')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute)

#### DOM核心接口4

> 监听事件

- [`target.addEventListener()`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

#### 事件

- 注册事件方法1
  - 内容HTML和交互JS绑定在一起了，这样不好~（比较古老的写法）

```html
<button id='btn'>onclick = "eventLog('onclick')"</button>
<script>
    function eventLog(type){
        console.log('触发的事件是：' + type)
    }
</script>

```

- **注册事件的方法2**
  - 不用给标签加事件，直接用JS获取标签对应的元素然后使用 `addEventListener`（这个用得真的超级多！）

```js
function eventLog(type){
    console.log('触发的事件是：' + type)
}
const btn = document.querySelector('#btn');
btn.addEventListener('click', function(){
    eventLog('onclick');
})
```



- 常见事件

  - 鼠标点击事件

  ```js
  onclick = "回调函数"
  ```

  

  - 鼠标移入移出事件

  ```js
  onmouseover = "回调函数"
  onmouseout = "回调函数"
  ```

  

  - 文本改变事件

  ```js
  onchange = "回调函数";// 经常用onchange来监听输入框中的改变
  ```

  

  - 键盘输入事件

  ```js
  oninput = "回调函数";// 用这个监听全局的键盘键入
  ```

  

  - 输入框（光标）focus（聚焦）事件

  ```js
  onfocus = "回调函数"
  ```

  

  - 输入框（光标）blur失焦事件

  ```js
  onblur = "回调函数"
  ```

- 虽然我们现在侦听事件一般用`addEventListener(‘xxx’, 回调函数)`吧~（不包括框架！）但是原生的JS操作DOM还是要理解咧！

  - 因为追溯根源，框架就是帮助我们操作了DOM文档对象模型，后期性能优化的了解上这个必不可少！



### BOM相关

浏览器对象模型（Browser Object Model）的核心是 window 对象。是每个浏览器⼚商在浏览器上提供的，提供与浏览器交互的⽅法和接⼝（⽐如，跳转⻚⾯，获取窗⼝⼤⼩，获 取历史记录，获取当前页面URL，获取⽂档节点等）
⼤部分我们常⽤的接⼝都是相同的调⽤⽅式，但是浏览
器他们底层实现的⽅式会不同。



### 事件

#### DOM注册事件的三种方法

- method01 页面元素（标签）提供的事件属性

```html
<button onclick="myClick()" id="btn">xx</button>
```

- method02 使用DOM对象的事件属性

```js
var btn = document.getElementById("btn");
// 给指定元素添加事件监听器
btn.onclick = myClick;
function myClick(){
    xxx
}
```

- method03 事件监听器

```js
var btn = document.getElementById("btn");
// 给指定元素添加事件监听器
btn.addEventListener('click', function () {
    xxx
})
```



#### 事件的冒泡与捕获

借鉴了[这里](https://827652549.github.io/my-book/?utm_source=gold_browser_extension#/javascript/questions?id=%e5%86%92%e6%b3%a1%e5%92%8c%e6%8d%95%e8%8e%b7)

> 可以通过addEventListener()的第三个参数来确定捕获还是冒泡，第一个参数是要绑定的事件，第二个参数是回调函数，第三个参数默认是false，代表**事件冒泡阶段**调用事件处理函数，如果设置成true，则在**事件捕获阶段**调用处理函数。

**冒泡：**

点[这个demo](https://www.w3school.com.cn/tiy/t.asp?f=event_stoppropagation)试试看

还可以点[JS30中第25个demo](https://fangzhousu.github.io/JS-30Demos/25_Event-Capture-Propagation-Bubbling-and-Once/index-billSu.html)

微软提出了事件冒泡的事件流，事件会**从最内层的元素开始发生**，一直向上传播，直到document对象。p元素上发生click事件的顺序应该是p -> body -> html -> document

**捕获：**

网景提出了事件捕获的事件流，事件捕获相反，事件会**从最外层开始发生**，直到最具体的元素。p元素上发生click事件的顺序应该是document -> html -> body -> div -> p

W3C制定了统一的标准，**先捕获再冒泡**。

可以通过addEventListener()的第三个参数来确定捕获还是冒泡，第一个参数是要绑定的事件，第二个参数是回调函数，第三个参数默认是false，代表**事件冒泡阶段**调用事件处理函数，如果设置成true，则在**事件捕获阶段**调用处理函数。

##### 更极端的情况

在浏览器中，如果父子元素**都设置了捕获和冒泡**的输出，当点击子元素时：

- 先捕获父元素
- 子元素输出先注册的事件，如果是捕获先输出捕获，如果是冒泡先输出冒泡
- 再输出父元素的冒泡事件

#### 事件冒泡与阻止事件冒泡（与捕获）

看[这个demo](https://www.w3school.com.cn/tiy/t.asp?f=event_stoppropagation)

使用

```js
event.stopPropagation();// 阻止冒泡
```

#### 阻止点击事件

```js
event.defaultPrevented();// 阻止点击事件
event.cancelable();// 这样也可以？！
```

![书上的一个片段~](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101516955.png)

![image-20211110151740844](https://gitee.com/su-fangzhou/blog-image/raw/master/202111101517435.png)

## 正则表达式



## ES6、ES7、ES2020新增内容





# 浏览器

## 浏览器中的进程与线程

## 浏览器渲染原理

## 浏览器中的Eventloop

## 浏览器存储相关（localstorage、sessionstorage）
