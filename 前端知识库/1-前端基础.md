> 🎉重中之重的前端基础🎉

> 主要为
>
> - HTML
> - CSS
> - JavaScript
>
> 的必会知识点们
>
> > 内容来源：《JavaScript高级程序设计~（第四版）~》/ 众多大佬们的知识博客/ 自己学习过程中记录的笔记/ [MDN文档](https://developer.mozilla.org/zh-CN/docs/Web)



# HTML

HTML（`HyperText Markup Language`，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。

- 超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。
- 标记语言是指通过在文档的某部分穿插特别的 字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的这种特殊字符串叫做 HTML 标签（Tag）。

## 常用标签、语义化标签

[HTML标签 参考手册](http://yige.org/html5/reference.php) 

#### `<select>&<option>`

select 元素**可创建单选或多选菜单**。

下方代码效果创建带有 4 个选项的选择列表：

```html
<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>
```

下方效果需在Typora（也许其他文本编辑器也行？）中**长按**来显示

<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>



## HTML标签属性相关



## HTML事件相关



## HTML5新增内容

[HTML5标签 参考手册](http://yige.org/html5/reference.php) 其中带new标签的是HTML5中的新标签



# CSS

## CSS基础

#### `display:none` `visibility:hidden`的区别

1.display:none是彻底消失，**不在文档流中占位**，浏览器也不会解析该元素；visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，**在文档流中占位**，浏览器会解析该元素；

![image-20211116222402053](https://gitee.com/su-fangzhou/blog-image/raw/master/202111162224130.png)

2.使用visibility:hidden比display:none性能上要好，

- display:none切换显示时页面产生**回流**（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），
- 而visibility切换是否显示时则**不会引起回流**。

###  元素的层叠顺序

层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODcyMDM1OC0xMjlhMmMzMWIyN2Y3YzU1LnBuZw)

由上到下分别是：

（1）背景和边框：建立当前层叠上下文元素的背景和边框。

（2）负的 z-index：当前层叠上下文中，z-index 属性值为负的元素。

（3）块级盒：文档流内非行内级非定位后代元素。

（4）浮动盒：非定位浮动元素。

（5）行内盒：文档流内行内级非定位后代元素。

（6）z-index:0：层叠级数为 0 的定位元素。

（7）正 z-index：z-index 属性值为正的定位元素。

**注意:** 当定位元素 z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。

## 盒模型



## 选择器、样式权重



## CSS常用属性（如：position）

#### [CSS position属性 - MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position)

#### [使用绝对定位实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-5)



## CSS常用布局（如：flex、grid）

### Flex布局

> 优质练习资源 [小青蛙找荷叶](https://flexboxfroggy.com/?utm_source=gold_browser_extension#zh-cn)
>
> [官方文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)

#### 小青蛙案例24关

```css
#pond {
    display: flex;
	flex-direction:column-reverse;/* 改变排列方式为竖直倒序 */
    align-content: space-between;/* 决定行与行之间的距离 */
    flex-wrap: wrap-reverse;/* 自动换行成多行（默认为强制在一行） */
	justify-content: center;/* 居中 */
}
```

效果如下：

![image-20211111165046955](https://gitee.com/su-fangzhou/blog-image/raw/master/202111111650078.png)



#### 经典问题-[利用布局实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-3)



## CSS动画相关（animation）

## CSS浮动相关（float）

> 浮动这块儿讲究可多咧！回头还需要多研究下呐！

#### 浮动的作用

- 设置浮动的图片——实现文字环绕图片
- 设置了浮动的块级元素可以排列在同一行
- **设置了浮动的行内元素可以设置宽高** - `涨知识系列`
- 可以按照浮动设置的方向对齐排列盒子 - `没见过这用法`

#### 设置浮动元素的特点

- 设置了浮动，该元素脱离文档流。元素不占位置
- 如果父级盒子没有设置高度，需要被子盒子撑开，那么这时候父级盒子的**高度**就**塌陷**了，同时也会造成父级盒子后面的兄弟盒子布局受到影响

清除浮动的方法

- 伪元素清除浮动

```css
.clearfix::after {
    content: ''; 
    display: table; 
    clear: both;
 }
```



- 给浮动元素父级添加 `overflow:hidden;`
- 额外标签法：给浮动元素父级增加标签

```css
<div class="wrap">
    <div class='left fl'></div>
    <div class='right fl'></div>
    <div style='clear:both'></div>
</div>
```



##### 清除浮动的特点和影响

- 伪元素清除浮动：不会新增标签，不会有其他影响，是当下清除浮动最流行的方法
- `overflow：hidden;`不会新增标签，但是如果父级元素有定位元素超出父级，超出部分会隐藏，在不涉及父级元素有超出内容的情况，overflow：hidden比较常用，毕竟写法方便简洁
-  标签插入法：清除浮动的语法加在新增标签上，由于新增标签会造成不必要的渲染，所以这种方法目前不建议使用







## 移动端适配

## 响应式布局

## CSS3新增内容



# JavaScript

## JS变量与数据类型

### 七种基本数据类型，一种引用数据类型

- 写过一篇文章 [重学数据（类型）、变量、内存](https://juejin.cn/post/7015057932135956487)，

  - 聊了一下这几个数据类型要如何通过typeof instanceof判定；

  - 聊了一下内存的问题——

    - 基本数据类型赋值给变量，变量存在栈中；
    - 引用数据类型赋值给变量，变量存在栈中，而对象保存在堆中，变量指向堆~

    ![image-20211031143811230](https://gitee.com/su-fangzhou/blog-image/raw/master/202110311438372.png)

- 基本数据类型

![image-20211031103940566](https://gitee.com/su-fangzhou/blog-image/raw/master/202110311039729.png)

```js
var a = 1, b = 2;
function test(pre, cur){
    pre = "hello world";// 函数作用域中的pre为"hello world"
    cur = 666;// 函数作用域中的cur为666
    // 这二位都不会影响到a b
}
function test2(){
    a = a+1;
    b = 666;
}
test(a, b);
console.log(a, b);// 1 2
test2();
console.log(a, b);// 2 666
```



- 引用类型

Object 





### 隐式类型转换

#### `==`中的隐式类型转换

根据红宝书复习的内容

### 字符串转数值型使用的API

#### parseInt & parseFloat

首先明确定义

- `parseInt` 

`parseInt`函数将其第一个参数转换为一个字符串，对该字符串**进行解析**，然后返回一个整数或 `NaN`。

第二个参数为其对应的进制（默认是十进制哈）

> 注意如果第一个参数从左到右数，遇到字符就会舍弃字符+字符后面的内容
>
> ```js
> parseInt('0001', 2);// 1
> parseInt('00x1111', 2);// 0
> parseInt('0011x11', 2);// 3
> ```

```js
parseInt('123xxx', 5) // 先把'123xxx'转换为'123' 将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38
```

- `parseFloat`

**`parseFloat()`** 函数解析一个参数（必要时先转换为字符串）并返回一个浮点数。

```js
parseFloat('5556.6www');// 5556.6
```



这里一个有趣的应用

```js
var a = ["88","66"];
// 将a数组转换为数值型可以简单地这样做
a.map(parseFloat);// [88,66]这里其实我也不知道为啥可以XD
//a.map(parseInt) 返回就是 [88,NaN]🥺
// 也可以常规一些~
a.map(x => parseInt(x));// .map(x => parseFloat(x))
```



## Array类型相关知识，及常见api

> ES5新增的Array API
>
> [张鑫旭大佬的博客](https://www.zhangxinxu.com/wordpress/2013/04/es5%e6%96%b0%e5%a2%9e%e6%95%b0%e7%bb%84%e6%96%b9%e6%b3%95/)

### 红宝书对Array API的总结（节选）

> 下面这些内容大部分为红宝书的内容，回头进行整理

#### 1.创建数组的静态方法 from of

from()用于将 类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例

#### 2.数组空位

由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。

如果确实需要空位，则可以显式地用 undefined 值代替。

#### 3.length属性

数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除 / 添加元素

#### 4.数组检测

一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作 用域）的情况下，使用 `instanceof` 操作符就足矣：

> 使用 `instanceof` 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

为解决这个问题，ECMAScript提供了 `Array.isArray()`方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的

#### 5.迭代器方法 keys values entries

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回**数组索引**的迭代器，values()返回**数组元素**的迭代器，而 entries()返回**索引/值对**的迭代器：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a3256ed51ed4962adf90e49b842d086.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)

#### 6.数组复制与填充问题



![在这里插入图片描述](https://img-blog.csdnimg.cn/d15476210f1e4b9dbc986137f8d5d056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)



```js
const zeros = [0,0,0,0,0];
//zeros.fill(填充数字,填充索引起始,填充索引结束前一位);
zeros.fill(7, 1, 3);
console.log(zeros);//[0,7,7,0,0]
```

```js
let ints,
    reset = {} => ints =[0,1,2,3,4,5,6,7,8,9];

//ints.copyWithin(插入位置的索引,复制的索引起始,复制的索引结束前一位);
ints.copyWithin(4,0,3);//[0,1,2,3, 0,1,2, 7,8,9]
```

#### 7.数组->字符串

得到——以逗号分隔数组值的字符串

- `toLocaleString()`
- `toString()`
- `数组.valueOf()`

得到——以传入参数分割数组值的字符串

> 而 `包装对象实例.valueOf()` 则返回包装对象实例对应的原始类型的值
>
> ```js
> new Number(123).valueOf()  // 123
> new String('abc').valueOf() // "abc"
> new Boolean(true).valueOf() // true
> ```

- `join("xxx")`



#### 8.数组的栈方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/118c90aad04e420ea95dbe5868e2af8a.png)



#### 9.数组的队列方式

就只有 入队列的方法与栈不同 其他方法是一样的

使用shift

插入到队头



#### 10.数组排序方法 sort

sort 这个sort有个坑 所以一般不直接用 

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4cb8f58a27f482ba15f6124bfaacb7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)



#### 11.数组的操作方法-增加元素 单独切一段元素 插入元素 concat slice splice

- `concat()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ae3411e563ea4818af0be79c79571d76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

- `slice()`

![请添加图片描述](https://img-blog.csdnimg.cn/72702c8f27664677964f4c08582cb9dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



- `splice()`

![请添加图片描述](https://img-blog.csdnimg.cn/562f8ba16eb742e39d20baafbd23ba49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

#### 12.搜索数组中元素的位置 indexOf

![在这里插入图片描述](https://img-blog.csdnimg.cn/80a68236760b480dbc2ddd50c896d519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 13.迭代方法 - 各种高级操作 filter map forEach

超级好用的几个方法！

- `every()`
- `some()`
- `filter()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca565154c7664d0a8c01b45a30397477.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)

- `map()`
- `forEach()`

![请添加图片描述](https://img-blog.csdnimg.cn/b16fc430c789416aaeb99134b28a7cd5.png)

#### 14.归并方法 reduce

- `reduce()`

这里的reduce的第一个参数 prev要注意

如果求和时  一般会给其起名为total 用于存储截至此时的和 

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ccc715666954883ad908dff58bff2a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 15.Map集合类型的基本API

明确Map实例的格式 为 键值对 

```js
const map = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])
```

- set() 添加键值对
- get() 获得某个键的值
- has() 查询是否有这个键
- `.size()` 获取键值对数量
- delete() 删除某个键值对
- clear() 清除映射实例中的所有键值对
- [entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) 返回一个新的包含 `[key, value]` 对的 `Iterator` 对象，返回的迭代器的迭代顺序与 `Map` 对象的插入顺序相同。
- [forEach()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach) 按照插入顺序依次对 `Map` 中每个键/值对执行一次给定的函数
- [values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values)它包含按顺序插入Map对象中每个元素的value值。

举例：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a78321c557bb42b797bd84877bc5fe04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

另外 与Object只能使用数值、字符串、符号作为键不同

Map可以使用**任何JS数据类型**作为键！！（这也是为啥ES6要创键这个集合类型）



- 另外注意 Map实例对象2个有趣的特性：

  - 一个key放入多个value —— 覆盖原先的value

  ```js
  var m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam');//88
  ```

  可以看出 key是不允许重复的！这也符合哈希表特性

  但是重复了也不会出错 自动就覆盖掉了

  - 值重复就没啥事儿（那肯定的嘛）

  ![请添加图片描述](https://img-blog.csdnimg.cn/b7e9d37dcc56444085727559a46704ef.png)

#### 16.迭代Map实例（按照插入顺序）

p191

又看到了 .entries() 迭代器方法！

——可以返回key value

#### 17.Set集合类型的基本API 

跟Map的大多数API 和 行为 都是共有的

也是一组key的集合，但**不存储value**。                  

- 要创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
//其实跟map的初始化方法是一样的 就是初始化内容不同而已
```

由于key不能重复，所以，在`Set`中，key是无法像Map实例中一样 可以覆盖的！

- `.size`
- `has()` 判断有没有这个元素
- `clear()`
- `add()` 与map的set添加一组键值对不同 set添加个元素就好了



#### 18.apply方法的使用

通过 [apply() 方法](https://www.w3school.com.cn/js/js_function_apply.asp)，您能够编写用于不同对象的方法。（与call()方法非常类似,只有传参时有区别）

##### 方法重用

```js
var person = {
  fullName: function() {
    return this.firstName + "调用成功" + this.lastName;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
person.fullName.apply(person1); // Bill调用成功Gates
```



```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
// 还可以传参进去哈！与call不同于参数的类型 为 数组
person.fullName.apply(person1, ["Seatle", "USA"]); // Bill Gates,Seatle,USA
```

##### 可用于在数组上模拟max方法

您可以使用 `Math.max()` 方法找到（数字列表中的）最大数字：

由于 JavaScript 数组没有 max() 方法，因此您可以应用 `Math.max.apply()` 方法。

```js
Math.max(1,2,3);

let arr = [1,2,3]
Math.max.apply(null, arr); // 也会返回 3 注意：第一个参数填啥没影响的，本次使用中没他事儿~
```

##### JavaScript 严格模式

在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。

在“非严格”模式下，它成为全局对象。

### 经典数组去重

[数组去重12种方法](https://juejin.cn/post/6844903981311852557) - 这边里利用对象实现去重的思路挺有意思的 亮点是不用辅助数组 直接在原数组上操作 数组熟练度++~

#### 利用辅助对象模拟哈希表+（不借助辅助数组）在原数组上直接去重

```js
let arr = [12,1,12,3,1,88,66,9,66];
function unique(arr) {
    let obj = {};
    for(let i=0;i<arr.length;i++){
        let cur = arr[i];
        if(obj[cur]){// 如果当前遍历到的元素之前碰到过，进入逻辑把它从arr中删了
            // 01 删除重复元素法一
            arr.splice(i,1);// 导致数组塌陷——用i--的方式规避数组塌陷！
            // 删除重复元素法二
            // arr[i]=arr[arr.length-1];// 重复元素的坑给数组最后一个元素勒
            // arr.length--;// 删除最后一项
            console.log(i);// 2 4 6
            // 02 对重复元素进行操作之后 手动将索引值-1 保证数组的每一项都被遍历~
            i--;// 注意！删了这个元素之后它之后的数组元素都提前勒！要倒回去一个索引获得原本的下一个数组元素。
            continue;// 跳过obj[cur] = cur，给i加上1 进入下一轮循环（其实这句不加也无所谓，给对象重复赋值也没啥影响~）
        }
        obj[cur]=cur;// 给obj新增键值对；属性名和属性值是一样的
    }
}
unique(arr);
console.log(arr);// 法一答案 [12, 1, 3, 88, 66, 9] 法二答案 [12, 1, 66, 3, 9, 88] 
```

### 经典数组乱序

#### [前端面试(算法篇) - 数组乱序](https://www.cnblogs.com/wisewrong/p/10517532.html)

> 写得挺好的 搭配 [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/) 食用更佳
>
> 首先是伪随机的两种方法

- **随机取数**

从原数组中随机抽取一个数，然后使用 splice 删掉该元素

```js
function getRandomArrElement(arr, count) {
    let res = []
    while (res.length < count) {
        // 生成随机 index
        let randomIdx = (Math.random() * arr.length) >> 0;
        // splice 返回的是一个数组
        res.push(arr.splice(randomIdx, 1)[0]);
    }
    return res
}
```

上面生成随机 index 用到了按位右移操作符 >> 

当后面的操作数是 0 的时候，该语句的结果就和 Math.floor() 一样，是向下取整

但位操作符是在数值表示的最底层执行操作，因此速度更快

```js
// 按位右移
(Math.random() * 100) >> 0

// Math.floor
Math.floor(Math.random() * 100)
/* 这两种写法的结果是一样的，但位操作的效率更高 */
```



- **通过 sort 乱序**

首先认识一下 [`Array.prototype.sort()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 不了解的查看下 这个必须滚瓜烂熟

```js
let arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
arr.sort((a, b) => 0.5 - Math.random());
```

**但这并不是真正的乱序**，计算机的 random 函数因为循环周期的存在，无法生成真正的随机数（力扣那题用这个方法也跑不通XD）

- **Fisher–Yates shuffle 洗牌算法**

> 这个方法太漂亮勒！
>
> 另外这个作者的写法也很漂亮！棒！

洗牌算法的思路是：

【1】**先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置**

【2】**然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换**

以此类推，打乱整个数组的顺序

```js
function shuffle(arr) {
  let len = arr.length;

  while (len) {
    let i = (Math.random() * len--) >> 0;// 获得随机数
    // 交换位置
    let temp = arr[len];
    arr[len] = arr[i];
    arr[i] = temp;
  }
  return arr;
}
```

再结合 ES6 的解构赋值，使用洗牌算法就更方便了：

```js
Array.prototype.shuffle = function() {
    let m = this.length, i;
    while (m) {
        i = (Math.random() * m--) >>> 0;
        [this[m], this[i]] = [this[i], this[m]]
    }
    return this;
}
```







## Object类型相关知识，及常见api

### 对象

> 对象是非常重要的概念

我们把对象理解为：**存放属性的容器**

- 常用的内置对象：Math **JSON** Map Set Array

  - JSON是序列化传输数据的方式（是一个数据格式）

    - `JSON.stringify()` 方法将一个 JavaScript 对象或值**转换为 JSON 字符串**

      - ```JS
        console.log(JSON.stringify({ x: 5, y: 6 }));
        // expected output: "{"x":5,"y":6}"
        
        console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
        // expected output: "[3,"false",false]"
        
        console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
        // expected output: "{"x":[10,null,null,null]}"
        
        console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
        // expected output: ""2006-01-02T15:04:05.000Z""
        ```

    - `JSON.parse()` 方法用来**解析JSON字符串**，构造由字符串描述的JavaScript值或对象

      - ```js
        const json = '{"result":true, "count":42}';
        const obj = JSON.parse(json);
        
        console.log(obj.count);
        // expected output: 42
        
        console.log(obj.result);
        // expected output: true
        ```
  
- 宿主对象

  - 浏览器宿主：Window、History、Location
  - Node宿主：global等

### JavaScript toString() 方法

toString方法在Object的显示原型上，其他对象对toString方法进行了重写~

![image-20211118191137192](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181911262.png)



toString() 方法可把一个 Number 对象转换为一个字符串，并返回结果。

语法

```js
NumberObject.toString(radix)// radix就是指进制数
```

比较有趣的一个点

![image-20211118184251915](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181842996.png)

小数居然算是`NumberObject`…？ ==存疑！==

看了下MDN [Number.prototype.toString()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toString) 依旧困惑。暂且记住好了 

- (10) 是 numObj  10不是
- (0.6) 是 numObj 0.6也是numObj

![image-20211118191027604](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181910721.png)

> ```js
> var count = 10;
> 
> console.log(count.toString());    // 输出 '10'
> console.log((17).toString());     // 输出 '17'
> console.log(17.toString());     // Uncaught SyntaxError: Invalid or unexpected token
> console.log((17.2).toString());   // 输出 '17.2'
> console.log(17.2.toString());   // 输出 '17.2'
> 
> var x = 6;
> 
> console.log(x.toString(2));       // 输出 '110'
> console.log((254).toString(16));  // 输出 'fe'
> 
> console.log((-10).toString(2));   // 输出 '-1010'
> console.log((-0xff).toString(2)); // 输出 '-11111111'
> ```
>
> 又来了个神奇的操作
>
> ```js
> 10..toString();// 输出"10"  
> ```
>
> 听前辈说这个是因为 . 指代不明确

- 利用这个方法 配合 [`substr()`方法](https://www.runoob.com/jsref/jsref-substr.html) 可以实现**随机验证码生成**

```js
Math.random().toString(36).substr(2, 10);// 以36进制将随机数转换为随机字符串，从得到的随机字符串的第二位开始拿10个字符~根本重复不了！
```

以36进制将随机数转换为随机字符串，从得到的随机字符串的第二位开始拿10个字符~根本重复不了！

![image-20211118184717386](https://gitee.com/su-fangzhou/blog-image/raw/master/202111181847459.png)

## 函数、类相关

### 原型与原型链



### 继承问题

> 通过原型链实现子类对父类的继承
>
> `Child.prototype = new Father();`
>
> 别忘了修正Child类显示原型的`constructor`
>
> `Child.prototype.constructor = Child`



### this关键字

> `this` 会作为变量**一直向上级词法作用域查找**，直至找到为止
>
> -[Vue官方文档](https://cn.vuejs.org/v2/guide/instance.html)

#### [MDN文档学习](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

##### 箭头函数没有自己的this指针，探究其通过 call 或 apply 调用后的局限性

> [Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
>
> `call()` 方法**使用一个指定的 `this` 值**和单独给出的一个或多个参数来**调用一个函数**。
>
> 该方法的语法和作用与 [`apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 方法类似，只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。
>
> ```js
> function.call(thisArg, arg1, arg2, ...)
> ```
>
> - thisArg
>
> 可选的。**在 *`function`* 函数运行时使用的 `this` 值。**
>
> > 请注意，`this`可能不是该方法看到的实际值：如果这个函数处于[非严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下，则指定为 `null` 或 `undefined` 时会自动替换为指向全局对象，原始值会被包装。
>
> - arg1, arg2, ...
>
> 指定的参数列表。

由于 箭头函数没有自己的this指针，通过 `call()` *或* `apply()` 方法调用一个函数时，只能传递参数（**不能绑定this**---译者注），他们的第一个参数会被忽略。（这种现象<u>对于bind方法同样成立</u>---译者注）

举个例子就知道了

```js
var adder = {
    base: 1,
    
    add:function(a){
        var f = value => value + this.base;
        return f(a);// thisArg未指定则默认指向全局对象adder
    },
    addThruCall:function(a){
        var b = {base: 666};
        var f = value => value + this.base;// 如果这里是个普通函数，则进行call时，将给b这个对象调用f方法，base为666
        return f.call(b, a);
    }
}
console.log(adder.add(1));// 2(adder.base + 1)
console.log(adder.addThruCall(1));// 2(依然是adder.base（而不是b.） + 1)
```



#### 阮大教程 偏基础，偏底层原理，例子很简单

this指向**函数运行时所在的环境**，那么为什么this关键字有这样的作用？函数的运行环境是如何决定的？看看阮一峰大大写得这篇文章，你会有新的感悟！（真的让我对内存、对象等知识都有了新的认识！）

[【阮大】JavaScript 的 this 原理](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

粘一下this的定义：

> 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的**运行环境**（context）。所以，`this`就出现了，它的设计目的就是**在函数体内部，指代函数当前的运行环境**。

#### 前辈笔记 例子很多，做完以后面试题应该是不怕了！

[this到底指向哪里？](https://note.youdao.com/ynoteshare/index.html?id=b2fab3b044aa90033395df0c8c9ca3a4&type=note&_time=1634385217314)

> 在JavaScript中`this`的指向总是让人很困惑，它到底指的啥？。`this`在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论`this`的指向。
>
> - ##### this在全局作用域中
>
> - ##### this在函数(function)里
>
> - ##### 在构造函数里的this指向
>
> - ##### 在事件处理器(event handler)中this的指向
>



> 总结：
>
> - 对于函数中的`this`，通过查看`()`左边所属的对象去确定，真的很好用。
> - 实质上，`this`是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的`this`的指向，`this`的指向就不会弄错了
>
> > 雀氏！在使用new关键字创建对象时，其中一步就是“构造函数内部的this被赋值为这个创建好的新对象（即this指向新对象）”（参考红宝书）
> >
> > ![在这里插入图片描述](https://img-blog.csdnimg.cn/2e9199be6e1d40df92a1d69246930628.png)



#### [深入理解JS函数中this指针的指向](https://www.cnblogs.com/zjjDaily/p/9482958.html)

> 又是一篇前辈的文章，例子和情景都很全面！
>



> 小结：
>
> 函数在执行时，会在函数体内部自动生成一个this指针。谁**直接调用产生这个this指针的函数**，this就指向谁。
>
> 由于js是采用的静态作用域（也叫词法作用域），这就意味着函数的执行依赖于**函数定义的时候**所产生（而不是函数调用的时候产生）的**变量作用域**。
>
> 在全局作用域中“定义”一个函数的时候，只会创建包含全局作用域的作用域链。只有“执行”该函数的时候，才会复制创建时的作用域，并将当前函数的局部作用域放在作用域链的顶端。
>
> 去取变量值的时候，首先看本函数里有没有该值，如果没有再到函数定义的外部去找

## 闭包、作用域相关（面试手写题常客）

#### 静态作用域的两道基础题

##### 面试题考察静态性-面试题1

```js
var x = 10;
function fn(){
    console.log(x);// 10
}
function show(f){
    var x = 20;
    f();
}
show(fn);// 打印10
```

记住一句话——

**在其他函数中被调用不影响x在打印语句中的值**（x在一开始定义的时候就确定了 打印的x是全局中的（毕竟是在人家全局那里调用的函数show嘛~））

> 21/10/17 更新 感觉可以用执行上下文来解释？毕竟涉及到了函数调用，很动态~
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/ff59c44a23bb42559efe8cb41512d7c8.png)

> 21/10/31更新
>
> 又见到了一次这道题
>
> 感觉上面的说法可能有一定道理，但是作用域的“静态性”才是最权威解释——在调用一个函数时，要找到它最开始被创建时的位置，进行寻值

##### 作用域链面试题~沿着作用域链找某个变量-面试题2

```js
var fn = function () {
    console.log(fn)//function(){console.log(fn)}
    var fn2 = function(){
      	console.log("找不到我吧~");
    }
}
fn()

var obj = {
    fn2: function () {
        console.log(fn2)// 报错 fn2 is not defined
        console.log(this.fn2)//function(){...}
    }
}
obj.fn2()
```

- 首先 第二行的打印是 fn对象（人家顺着作用域链就能轻松找到位于全局作用域中的fn咯~）
- 第十一行 报错 来看看fn2的心路历程
  - 先在fn2构造函数的函数作用域中找 没有定义过fn2！ 
  - 再去全局作用域里找 全局变量也没它这号变量！
  - 再去同级的函数作用域里找找行么？
    - 不行！😂

- 第十二行 打印fn2对象 加上this 表示obj对象 obj对象拥有这个fn2函数啊 没问题~





## 期约与异步函数

### promise、async、await相关

##### [理解 JavaScript 的 async/await](https://segmentfault.com/a/1190000007535316)

简单来说

> ```
> 如果await等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。
> 
> 如果await等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
> ```

举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写

```javascript
function takeLongTime() {
    return new Promise(resolve => {
        setTimeout(() => resolve("long_time_value"), 1000);
    });
}

takeLongTime().then(v => {
    console.log("got", v);
});
```

如果改用 async/await 呢，会是这样

```javascript
function takeLongTime() {
    return new Promise(resolve => {
        setTimeout(() => resolve("long_time_value"), 1000);
    });
}

async function test() {
    const v = await takeLongTime();
    console.log(v);
}

test();
```

单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。

假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：

```javascript
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}

function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}

function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}

function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

现在用 Promise 方式来实现这三个步骤的处理

```javascript
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}

doIt();

// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
```

输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。

如果用 async/await 来实现呢，会是这样

```javascript
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}

doIt();
```

结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，==几乎跟同步代码一样==

##### [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

### xhr、fetch相关（AJAX）





## 浏览器中的JavaScript

### DOM相关

#### DOM核心接口1

> 获取DOM中的节点

- [`document.getElementById('id')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById)
- [`document.querySelector('selecotrs')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector)
  - id、class
    - `querySelector('#root')`
  - 更高级一些——标签名、CSS属性值
    - `querySelector(input[name = 'login'])`name属性为login的input元素

#### DOM核心接口2

> 动态地创建节点并插入到DOM中

- [`element.style.xxx`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)(MDN里甚至没有中文ORZ)
  - 设置获取元素的属性
- [`document.createElement(要创建的标签名称/类名)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement)
- [`node.appendChild(子节点)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild)
  - 将子节点追加给父节点
- [`Element.innerHTML`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML)

#### DOM核心接口3

> 获取/设置元素的样式

- [`element.getAttribute(name)`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getAttribute)
- [`element.setAttribute('属性名称', '属性的值/新值')`](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute)

#### DOM核心接口4

> 监听事件

- [`target.addEventListener()`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)

#### 事件

- 注册事件方法1
  - 内容HTML和交互JS绑定在一起了，这样不好~（比较古老的写法）

```html
<button id='btn'>onclick = "eventLog('onclick')"</button>
<script>
    function eventLog(type){
        console.log('触发的事件是：' + type)
    }
</script>

```

- **注册事件的方法2**
  - 不用给标签加事件，直接用JS获取标签对应的元素然后使用 `addEventListener`（这个用得真的超级多！）

```js
function eventLog(type){
    console.log('触发的事件是：' + type)
}
const btn = document.querySelector('#btn');
btn.addEventListener('click', function(){
    eventLog('onclick');
})
```



- 常见事件

  - 鼠标点击事件

  ```js
  onclick = "回调函数"
  ```

  

  - 鼠标移入移出事件

  ```js
  onmouseover = "回调函数"
  onmouseout = "回调函数"
  ```

  

  - 文本改变事件

  ```js
  onchange = "回调函数";// 经常用onchange来监听输入框中的改变
  ```

  

  - 键盘输入事件

  ```js
  oninput = "回调函数";// 用这个监听全局的键盘键入
  ```

  

  - 输入框（光标）focus（聚焦）事件

  ```js
  onfocus = "回调函数"
  ```

  

  - 输入框（光标）blur失焦事件

  ```js
  onblur = "回调函数"
  ```

- 虽然我们现在侦听事件一般用`addEventListener(‘xxx’, 回调函数)`吧~（不包括框架！）但是原生的JS操作DOM还是要理解咧！

  - 因为追溯根源，框架就是帮助我们操作了DOM文档对象模型，后期性能优化的了解上这个必不可少！



### BOM相关

浏览器对象模型（Browser Object Model）的核心是 window 对象。是每个浏览器⼚商在浏览器上提供的，提供与浏览器交互的⽅法和接⼝（⽐如，跳转⻚⾯，获取窗⼝⼤⼩，获 取历史记录，获取当前页面URL，获取⽂档节点等）
⼤部分我们常⽤的接⼝都是相同的调⽤⽅式，但是浏览
器他们底层实现的⽅式会不同。



### 事件

#### DOM注册事件的三种方法

- method01 页面元素（标签）提供的事件属性

```html
<button onclick="myClick()" id="btn">xx</button>
```

- method02 使用DOM对象的事件属性

```js
var btn = document.getElementById("btn");
// 给指定元素添加事件监听器
btn.onclick = myClick;
function myClick(){
    xxx
}
```

- method03 事件监听器

```js
var btn = document.getElementById("btn");
// 给指定元素添加事件监听器
btn.addEventListener('click', function () {
    xxx
})
```



#### 事件的冒泡与捕获

借鉴了[这里](https://827652549.github.io/my-book/?utm_source=gold_browser_extension#/javascript/questions?id=%e5%86%92%e6%b3%a1%e5%92%8c%e6%8d%95%e8%8e%b7)

> 可以通过addEventListener()的第三个参数来确定捕获还是冒泡，第一个参数是要绑定的事件，第二个参数是回调函数，第三个参数默认是false，代表**事件冒泡阶段**调用事件处理函数，如果设置成true，则在**事件捕获阶段**调用处理函数。

**冒泡：**

点[这个demo](https://www.w3school.com.cn/tiy/t.asp?f=event_stoppropagation)试试看

还可以点[JS30中第25个demo](https://fangzhousu.github.io/JS-30Demos/25_Event-Capture-Propagation-Bubbling-and-Once/index-billSu.html)

微软提出了事件冒泡的事件流，事件会**从最内层的元素开始发生**，一直向上传播，直到document对象。p元素上发生click事件的顺序应该是p -> body -> html -> document

**捕获：**

网景提出了事件捕获的事件流，事件捕获相反，事件会**从最外层开始发生**，直到最具体的元素。p元素上发生click事件的顺序应该是document -> html -> body -> div -> p

W3C制定了统一的标准，**先捕获再冒泡**。

可以通过addEventListener()的第三个参数来确定捕获还是冒泡，第一个参数是要绑定的事件，第二个参数是回调函数，第三个参数默认是false，代表**事件冒泡阶段**调用事件处理函数，如果设置成true，则在**事件捕获阶段**调用处理函数。

##### 更极端的情况

在浏览器中，如果父子元素**都设置了捕获和冒泡**的输出，当点击子元素时：

- 先捕获父元素
- 子元素输出先注册的事件，如果是捕获先输出捕获，如果是冒泡先输出冒泡
- 再输出父元素的冒泡事件

#### 事件冒泡与阻止事件冒泡（与捕获）

看[这个demo](https://www.w3school.com.cn/tiy/t.asp?f=event_stoppropagation)

使用

```js
event.stopPropagation();// 阻止冒泡
```

#### 阻止点击事件

```js
event.defaultPrevented();// 阻止点击事件
event.cancelable();// 这样也可以？！
```

> 图如果看不了的话 直接访问图片链接好了orz
>
> https://gitee.com/su-fangzhou/blog-image/raw/master/202111150020231.png

![image-20211115002048573](https://gitee.com/su-fangzhou/blog-image/raw/master/202111150020231.png)

## 正则表达式



## ES6、ES7、ES2020新增内容

### Map数据结构

> [阮大的ES6教程](https://es6.ruanyifeng.com/#docs/set-map#Map)

#### 初始化map

```js
const map = new Map([
	["(", ")"],
    ["[", "]"],
    ["{", "}"]
])
```

键值对不多可以用`map.set(key, value)`

#### 题目中 map的键的类型是字符型，所以可以用startsWith(xxx)方法来判断其前缀是否为xxx

碰到一道力扣 [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)，用到了字符串的这个API，很有趣也很实用！

```js
var MapSum = function() {
    this.map = new Map();

};

MapSum.prototype.insert = function(key, val) {
    this.map.set(key, val);
};

MapSum.prototype.sum = function(prefix) {
    let res = 0;
    for (const s of this.map.keys()) {
        console.log(typeof(s));// string
        if (s.startsWith(prefix)) {
            // 如果s开头是prefix，返回true
            res += this.map.get(s);
        }
    }
    return res;
};
```



# 浏览器

## 浏览器中的进程与线程

## 浏览器渲染原理

## 浏览器中的Eventloop

## 浏览器存储相关（localstorage、sessionstorage）
