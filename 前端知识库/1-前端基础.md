> 🎉重中之重的前端基础🎉

> 主要为
>
> - HTML
> - CSS
> - JavaScript
>
> 的必会知识点们
>
> > 内容来源：《JavaScript高级程序设计~（第四版）~》/ 众多大佬们的知识博客/ 自己学习过程中记录的笔记/ [MDN文档](https://developer.mozilla.org/zh-CN/docs/Web)



# HTML

## 常用标签、语义化标签

[HTML标签 参考手册](http://yige.org/html5/reference.php) 

#### `<select>&<option>`

select 元素**可创建单选或多选菜单**。

下方代码效果创建带有 4 个选项的选择列表：

```html
<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>
```

下方效果需在Typora（也许其他文本编辑器也行？）中长按来显示

<select>
  <option value ="volvo">Volvo</option>
  <option value ="saab">Saab</option>
  <option value="opel">Opel</option>
  <option value="audi">Audi</option>
</select>



## HTML标签属性相关



## HTML事件相关



## HTML5新增内容

[HTML5标签 参考手册](http://yige.org/html5/reference.php) 其中带new标签的是HTML5中的新标签



# CSS

## 盒模型



## 选择器、样式权重



## CSS常用属性（如：position）

#### [使用绝对定位实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-5)



## CSS常用布局（如：flex、grid）

#### [利用布局实现元素垂直居中](https://juejin.cn/post/7009662518406676488/#heading-3)



## CSS动画相关（animation）

## CSS浮动相关（float）



## 移动端适配

## 响应式布局

## CSS3新增内容



# JavaScript

## JS变量类型相关



## Array类型相关知识，及常见api

> ES5新增的Array API
>
> [张鑫旭大佬的博客](https://www.zhangxinxu.com/wordpress/2013/04/es5%e6%96%b0%e5%a2%9e%e6%95%b0%e7%bb%84%e6%96%b9%e6%b3%95/)

> 下面这些内容大部分为红宝书的内容，回头进行整理

#### 1.创建数组的静态方法 from of

from()用于将 类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例

#### 2.数组空位

由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。

如果确实需要空位，则可以显式地用 undefined 值代替。

#### 3.length属性

数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除 / 添加元素

#### 4.数组检测

一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作 用域）的情况下，使用 `instanceof` 操作符就足矣：

> 使用 `instanceof` 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两 个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。

为解决这个问题，ECMAScript提供了 `Array.isArray()`方法。这个方法的目的就是确定一个值是 否为数组，而不用管它是在哪个全局执行上下文中创建的

#### 5.迭代器方法 keys values entries

在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回**数组索引**的迭代器，values()返回**数组元素**的迭代器，而 entries()返回**索引/值对**的迭代器：

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a3256ed51ed4962adf90e49b842d086.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)

#### 6.数组复制与填充问题



![在这里插入图片描述](https://img-blog.csdnimg.cn/d15476210f1e4b9dbc986137f8d5d056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)



```js
const zeros = [0,0,0,0,0];
//zeros.fill(填充数字,填充索引起始,填充索引结束前一位);
zeros.fill(7, 1, 3);
console.log(zeros);//[0,7,7,0,0]
```

```js
let ints,
    reset = {} => ints =[0,1,2,3,4,5,6,7,8,9];

//ints.copyWithin(插入位置的索引,复制的索引起始,复制的索引结束前一位);
ints.copyWithin(4,0,3);//[0,1,2,3, 0,1,2, 7,8,9]
```

#### 7.数组->字符串

得到——以逗号分隔数组值的字符串

- `toLocaleString()`
- `toString()`
- `数组.valueOf()`

得到——以传入参数分割数组值的字符串

> 而 `包装对象实例.valueOf()` 则返回包装对象实例对应的原始类型的值
>
> ```js
> new Number(123).valueOf()  // 123
> new String('abc').valueOf() // "abc"
> new Boolean(true).valueOf() // true
> ```

- `join("xxx")`



#### 8.数组的栈方法

![在这里插入图片描述](https://img-blog.csdnimg.cn/118c90aad04e420ea95dbe5868e2af8a.png)



#### 9.数组的队列方式

就只有 入队列的方法与栈不同 其他方法是一样的

使用shift

插入到队头



#### 10.数组排序方法 sort

sort 这个sort有个坑 所以一般不直接用 

![在这里插入图片描述](https://img-blog.csdnimg.cn/a4cb8f58a27f482ba15f6124bfaacb7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_16,color_FFFFFF,t_70,g_se,x_16)



#### 11.数组的操作方法-增加元素 单独切一段元素 插入元素 concat slice splice

- `concat()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ae3411e563ea4818af0be79c79571d76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

- `slice()`

![请添加图片描述](https://img-blog.csdnimg.cn/72702c8f27664677964f4c08582cb9dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



- `splice()`

![请添加图片描述](https://img-blog.csdnimg.cn/562f8ba16eb742e39d20baafbd23ba49.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)

#### 12.搜索数组中元素的位置 indexOf

![在这里插入图片描述](https://img-blog.csdnimg.cn/80a68236760b480dbc2ddd50c896d519.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 13.迭代方法 - 各种高级操作 filter map forEach

超级好用的几个方法！

- `every()`
- `some()`
- `filter()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca565154c7664d0a8c01b45a30397477.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_17,color_FFFFFF,t_70,g_se,x_16)

- `map()`
- `forEach()`

![请添加图片描述](https://img-blog.csdnimg.cn/b16fc430c789416aaeb99134b28a7cd5.png)

#### 14.归并方法 reduce

- `reduce()`

这里的reduce的第一个参数 prev要注意

如果求和时  一般会给其起名为total 用于存储截至此时的和 

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ccc715666954883ad908dff58bff2a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_15,color_FFFFFF,t_70,g_se,x_16)



#### 15.Map集合类型的基本API

明确Map实例的格式 为 键值对 

```js
const map = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])
```

- set() 添加键值对
- get() 获得某个键的值
- has() 查询是否有这个键
- `.size()` 获取键值对数量
- delete() 删除某个键值对
- clear() 清除映射实例中的所有键值对

举例：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a78321c557bb42b797bd84877bc5fe04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pWy5Luj56CB55qE5bCP5o-Q55C05omL,size_18,color_FFFFFF,t_70,g_se,x_16)

另外 与Object只能使用数值、字符串、符号作为键不同

Map可以使用**任何JS数据类型**作为键！！（这也是为啥ES6要创键这个集合类型）



- 另外注意 Map实例对象2个有趣的特性：

  - 一个key放入多个value —— 覆盖原先的value

  ```js
  var m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam');//88
  ```

  可以看出 key是不允许重复的！这也符合哈希表特性

  但是重复了也不会出错 自动就覆盖掉了

  - 值重复就没啥事儿（那肯定的嘛）

  ![请添加图片描述](https://img-blog.csdnimg.cn/b7e9d37dcc56444085727559a46704ef.png)

#### 16.迭代Map实例（按照插入顺序）

p191

又看到了 .entries() 迭代器方法！

——可以返回key value

#### 17.Set集合类型的基本API 

跟Map的大多数API 和 行为 都是共有的

也是一组key的集合，但**不存储value**。                  

- 要创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：

```js
var s1 = new Set(); // 空Set
var s2 = new Set([1, 2, 3]); // 含1, 2, 3
//其实跟map的初始化方法是一样的 就是初始化内容不同而已
```

由于key不能重复，所以，在`Set`中，key是无法像Map实例中一样 可以覆盖的！

- `.size`
- `has()` 判断有没有这个元素
- `clear()`
- `add()` 与map的set添加一组键值对不同 set添加个元素就好了



#### 18.apply方法的使用

通过 [apply() 方法](https://www.w3school.com.cn/js/js_function_apply.asp)，您能够编写用于不同对象的方法。（与call()方法非常类似,只有传参时有区别）

##### 方法重用

```js
var person = {
  fullName: function() {
    return this.firstName + "调用成功" + this.lastName;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
person.fullName.apply(person1); // Bill调用成功Gates
```



```js
var person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
var person1 = {
  firstName:"Bill",
  lastName: "Gates"
}
// 还可以传参进去哈！与call不同于参数的类型 为 数组
person.fullName.apply(person1, ["Seatle", "USA"]); // Bill Gates,Seatle,USA
```

##### 可用于在数组上模拟max方法

您可以使用 `Math.max()` 方法找到（数字列表中的）最大数字：

由于 JavaScript 数组没有 max() 方法，因此您可以应用 `Math.max.apply()` 方法。

```js
Math.max(1,2,3);

let arr = [1,2,3]
Math.max.apply(null, arr); // 也会返回 3 注意：第一个参数填啥没影响的，本次使用中没他事儿~
```

##### JavaScript 严格模式

在 JavaScript 严格模式下，如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。

在“非严格”模式下，它成为全局对象。



## Object类型相关知识，及常见api



## 函数、类相关

### this关键字

#### 阮大教程 偏基础，偏底层原理，例子很简单

this指向**函数运行时所在的环境**，那么为什么this关键字有这样的作用？函数的运行环境是如何决定的？看看阮一峰大大写得这篇文章，你会有新的感悟！（真的让我对内存、对象等知识都有了新的认识！）

[【阮大】JavaScript 的 this 原理](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)

粘一下this的定义：

> 由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的**运行环境**（context）。所以，`this`就出现了，它的设计目的就是**在函数体内部，指代函数当前的运行环境**。

#### 前辈笔记 例子很多，做完以后面试题应该是不怕了！

[this到底指向哪里？](https://note.youdao.com/ynoteshare/index.html?id=b2fab3b044aa90033395df0c8c9ca3a4&type=note&_time=1634385217314)

> 在JavaScript中`this`的指向总是让人很困惑，它到底指的啥？。`this`在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论`this`的指向。
>
> - ##### this在全局作用域中
>
> - ##### this在函数(function)里
>
> - ##### 在构造函数里的this指向
>
> - ##### 在事件处理器(event handler)中this的指向
>
> 总结：
>
> - 对于函数中的`this`，通过查看`()`左边所属的对象去确定，真的很好用。
> - 实质上，`this`是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的`this`的指向，`this`的指向就不会弄错了
>
> > 雀氏！在使用new关键字创建对象时，其中一步就是“构造函数内部的this被赋值为这个创建好的新对象（即this指向新对象）”（参考红宝书）
> >
> > ![在这里插入图片描述](https://img-blog.csdnimg.cn/2e9199be6e1d40df92a1d69246930628.png)









## 闭包、作用域相关

#### 静态作用域的两道基础题

##### 面试题考察静态性-面试题1

```js
var x = 10;
function fn(){
    console.log(x);// 10
}
function show(f){
    var x = 20;
    f();
}
show(fn);// 打印10
```

记住一句话——

**在其他函数中被调用不影响x在打印语句中的值**（x在一开始定义的时候就确定了 打印的x是全局中的（毕竟是在人家全局那里调用的函数show嘛~））

> 10/17 更新 感觉可以用执行上下文来解释？毕竟涉及到了函数调用，很动态~
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/ff59c44a23bb42559efe8cb41512d7c8.png)



##### 作用域链面试题~沿着作用域链找某个变量-面试题2

```js
var fn = function () {
    console.log(fn)//function(){console.log(fn)}
    var fn2 = function(){
      	console.log("找不到我吧~");
    }
}
fn()

var obj = {
    fn2: function () {
        console.log(fn2)// 报错 fn2 is not defined
        console.log(this.fn2)//function(){...}
    }
}
obj.fn2()
```

- 首先 第二行的打印是 fn对象（人家顺着作用域链就能轻松找到位于全局作用域中的fn咯~）
- 第十一行 报错 来看看fn2的心路历程
  - 先在fn2构造函数的函数作用域中找 没有定义过fn2！ 
  - 再去全局作用域里找 全局变量也没它这号变量！
  - 再去同级的函数作用域里找找行么？
    - 不行！😂

- 第十二行 打印fn2对象 加上this 表示obj对象 obj对象拥有这个fn2函数啊 没问题~





## 期约与异步函数

### promise、async、await相关



### xhr、fetch相关（AJAX）





## DOM相关



## BOM相关



## 正则表达式



## ES6、ES7、ES2020新增内容





# 浏览器

## 浏览器中的进程与线程

## 浏览器渲染原理

## 浏览器中的Eventloop

## 浏览器存储相关（localstorage、sessionstorage）
