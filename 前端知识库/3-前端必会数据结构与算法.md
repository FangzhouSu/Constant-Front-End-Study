> 面试必考的算法题 逐一攻破有套路！🧐

参考资料：

- [前端算法与数据结构面试：底层逻辑解读与大厂真题训练](https://juejin.cn/book/6844733800300150797)
  - 墙裂推荐的前端er的刷题指南！
- [代码随想录](https://programmercarl.com/)
- [力扣题库](https://leetcode-cn.com/problemset/all/)

提纲（来自[前端算法与数据结构面试：底层逻辑解读与大厂真题训练](https://juejin.cn/book/6844733800300150797)）：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/24/171ac6e4faf30ecf~tplv-t2oaga2asx-watermark.awebp)

> 应知应会
>
> - 堆、栈
> - 链表
> - 跳表、散列
> - 二叉、多叉树相关算法
> - 图相关算法
>
> 等~

# 基础数据结构

# 01 数组

## 【1】刷题必掌握的数组API

> 这里直接看[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#)即可~讲得很详细
>
> 另外学习JS数据结构与算法这本书中提到了一些高频方法，如下

![image-20211201142027847](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011420019.png)

![image-20211201142106168](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011421315.png)



## 【2】数组必会题目

> 这部分题目为前端er必会的数组相关题目，都很有代表性！

[掘金文章链接（排版更好看一些~）](https://juejin.cn/post/7021090596135649311/)

单纯针对数组来考察的题目，总体来说，都不算太难——数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。

本部分记录那些“不那么难，但是面试中很高频且可以考验你数组掌握程度”的题目

- 不那么难，指的是这种题不需要用到困难的“解题技巧”，排序、二分思想、动态规划
- 面试中高频，字面意思，面试经常考嘛（虽说感觉前端er的面试中链表会问的比较多？）
- 考验数组掌握程度，这一点很重要，决定了面试官对你的看法——
  - 你是个不求甚解所有题目都暴力求解的选手
  - 还是会不断优化，充分利用数组API与一些简单技巧（例如双指针、哈希表）进行求解的选手？



#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

`哈希表`

> 几乎所有求和问题，都可以转化为求差问题，不知道i如何优化？试着想想求差~
>

- 借助哈希表一趟遍历解题

  - 新建一个空对象模拟哈希表

  ```js
  var twoSum = function(nums, target) {
      let map = {};
      for(let i = 0; i < nums.length; i++){
          if(map[target - nums[i]] >= 0){
              return [map[target - nums[i]], i];
          }
          else{
              map[nums[i]] = i;
          }
      }
  };
  ```

  - 另外这题里面Map数据结构真不咋好使滴（这API完全没帮上忙，还不如原生写法😂)，还是直接创建一个对象，在对象里维护键值对儿吧~（也就是上面那个方法）
  
  > 12/2更新——还是可以用一下has方法滴~ `if(map.has(target-nums[i]))`

```js
var twoSum = function(nums, target){
    let map = new Map();
    for(let i = 0; i < nums.length; i++){
        if(map.get(target - nums[i]) >= 0){
            return [i, map.get(target - nums[i])]
        }
    	else{
            map.set(nums[i], i);
        }
    }
}
```





#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

`同向正序双指针，同向倒序双指针`

- 笨拙的暴力法

```js
// 纯属是为了提高数组相关API的熟练度XD，
// 面试时可以试着用下来展示自己对数组这个数据结构的熟悉？hh
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m);
    for(let j = 0; j < n; j++){
        for(let i = 0; i < m + n; i++){
            if(nums2[j] <= nums1[i]){
                nums1.splice(i, 0, nums2[j]);
                break;
            }
            if(nums2[j] > Math.max(...nums1)){
                console.log(nums1)
                nums1.push(...nums2.slice(j)) 
                return nums1
            }
        }
    }
    // return nums1;// 如果走到这里 其实就不用return了哦
};
```

- 开辟新空间，常规同向双指针寻值

![img](https://assets.leetcode-cn.com/solution-static/88/1.gif)

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    let temp = [];
    while(p1 < m || p2 < n){
        // 如果nums1/nums2已经遍历完了，那么只能操作另外一个数组了~
        if(p1 === m){
            temp.push(nums2[p2++]);
        }
        else if(p2 === n){
            temp.push(nums1[p1++]);
        }
        // 较小的元素插入temp中（常规思路了这里~）
        else if(nums1[p1] < nums2[p2]){
            temp.push(nums1[p1++]);
        }
        else if(nums1[p1] >= nums2[p2]){
            temp.push(nums2[p2++]);
        }
    }
    for(let i = 0; i < m + n; i++){
        nums1[i] = temp[i];
    }
    // return nums1; // 题目就让把nums1修改下，没必要return了哈~核心代码模式就是爽XD
};
```

- 不必开辟新空间，巧妙逆向双指针！

ppt过程模拟[看这里](https://leetcode-cn.com/problems/merge-sorted-array/solution/88-by-ikaruga/)

面试能答出来这么个**倒序双指针**，不得起飞咯😎（好吧这其实是基操。）

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    let cur;// 参考了官方题解，设置一个cur记录每次要去进行插入的值，更加清晰勒！
    while(p1 >= 0 || p2 >= 0){
        if(p1 === -1){
            cur = nums2[p2--]; 
        }
        else if(p2 === -1){
            cur = nums1[p1--]; 
        }
        else if(nums2[p2] > nums1[p1]){
            cur = nums2[p2--];
        }
        else if(nums2[p2] <= nums1[p1]){
            cur = nums1[p1--]; 
        }
        // 每次迭代找出应该挪到后面的元素
        nums1[tail--] = cur;
    }
};
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

`反向对撞双指针`

核心方法：对撞（反向）双指针 + 定指针分别挪动 & 保证获得的三个数不能重复（使用特殊判断跳过重复的值）

这里写了个题解 [【JavaScript】对撞双指针 + 定指针 注释齐全](https://leetcode-cn.com/problems/3sum/solution/javascript-dui-zhuang-shuang-zhi-zhen-di-xbfk/)

```js
var threeSum = function(nums) {
    // 先排个序~
    nums = nums.sort((a, b) => {return a - b;})
    let res = [];
    // 定住的那个指针i
    for(let i = 0; i < nums.length - 2; i++){
        if(i >= 1 && nums[i - 1] === nums[i]){
            // 如果重复 则跳过本次循环 直接返回for语句
            continue;
        }
        // 每轮不断地动p1 p2来找答案
        let p1 = i + 1;
        let p2 = nums.length - 1;
        while(p1 < p2){
            let sum = nums[i] + nums[p1] + nums[p2];
            if(sum === 0){
                res.push([nums[i], nums[p1], nums[p2]]);
                // 找到一个答案，接着进行寻找，注意不要造成重复！
                p1++;
                while(nums[p1] === nums[p1 - 1]){
                    p1++;
                }
                p2--;
                while(nums[p2] === nums[p2 + 1]){
                    p2--;
                }
            }
            // 挪动双指针，为了防止重复，要跳过重复值
            else if(sum < 0){
                p1++;
                // 注意这里当新p1与上一个p1相同时 才会加
                while(nums[p1] === nums[p1 - 1]){
                    p1++;
                }
            }
            else if(sum > 0){
                p2--;
                // 注意这里当新p2与上一个p2相同时 才会减
                while(nums[p2] === nums[p2 + 1]){
                    p2--;
                }
            }
            // 一头一尾两个指针一轮的挪动完毕
        }
    }
    return res;
};
```



## 【3】数组高频面试题

> 这部分内容为汇总的一些前端面试高频算法题~

### 找出排序数组中只出现一次的数字&延伸题目

#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 同[剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/) 一样
>
> 我的题解——[[JavaScript]异或、二分搜索（全体二分查找乱序数组&偶数二分查找有序数组）注释齐全](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/javascriptyi-huo-er-fen-sou-suo-quan-ti-f6rzu/)
>

##### 异或快捷解决

> 540题中英文版有规定 ：Your solution must run in `O(log n)` time and `O(1)` space. 所以这个方法仅供了解
>
> 主要考察二分法！

```js
var singleNonDuplicate = function(nums) {
    let res;
    for(let i = 0; i < nums.length; i++){
        res ^= nums[i];
    }
    return res;
};
```

##### 再优化，二分法（面试重点）

> 这里的第一个关键点是先把四种情况列出来！
>
> 参考官方题解
>
> 例子 1：中间元素的同一元素在右边，且被 mid 分成两半的数组为偶数。
>
> 我们将右子数组的第一个元素移除后，则右子数组元素个数变成奇数，我们应将 lo 设置为 mid + 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/08f1ff0fa20c9963ae4f5aafb7c6317df713b5eb562064ba8b7644c1d773c626-file_1576478245275)
>
> 例子 2：中间元素的同一元素在右边，且被 mid 分成两半的数组为奇数。
>
> 我们将右子数组的第一个元素移除后，则右子数组的元素个数变为偶数，我们应将 hi 设置为 mid - 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/8481e9a41430c85977693dbad0d12de7df96a7064d13edd6eb359f7d8ccbcf99-file_1576478245283)
>
> 例子 3：中间元素的同一元素在左边，且被 mid 分成两半的数组为偶数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为奇数，我们应将 hi 设置为 mid - 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/186af681e3fced71c9588d9422accc7832062b24d33c343edecd9aef2e0c6ba1-file_1576478245286)
>
> 例子 4：中间元素的同一元素在左边，且被 mid 分成两半的数组为奇数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为偶数，我们应将 lo 设置为 mid + 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/067fab9a30b1b278da9e633de7b627931cdab5444d0f99e7142eb2907bff4431-file_1576478245290)



然后就常规二分法做就行了~注意分情况讨论的细则即可！

```js
var singleNonDuplicate = function(nums) {
    // 定义双指针
    let i = 0, j = nums.length - 1;
    while(i < j){
        // let mid = (i + j) >> 1;
        // 为了防止大数溢出 建议这么写
        let mid = i + (j - i >> 1)
        // 此方法的关键——判断哪边为奇数的变量 要设置好
        let isEven = (j - mid) % 2 == 0;
        // 如果j-mid为偶数 则去除中间两个值相同的元素并跳过它们之后，两指针（包括两指针）之间有奇数个元素，
        // 也就是单个的元素一定在这之间
        if(nums[mid] === nums[mid - 1]){
            if(isEven){
                // 在左边
                j = mid - 2;
            }
            else{
                i = mid + 1;
            }
        }
        else if(nums[mid] === nums[mid + 1]){
            if(isEven){
                // 在右边
                i = mid + 2;
            }
            else{
                console.log("last j",j)
                j = mid - 1;
            }
        }
        else{
            return nums[mid];
        }
    }
    return nums[i];
};
```

怎么说呢，双指针的题，多画图就完事了！

时间复杂度 O(logn)，相比于暴力循环（包括异或），每次迭代将搜索空间缩减了一半！

##### 进一步优化，仅对偶数索引进行二分搜索

最佳实践

```js
var singleNonDuplicate = function(nums) {
    let i = 0, j = nums.length - 1;// 数组长度必为奇数，所以一前一后两个元素下标为偶数
    while(i < j){
        let mid = i + ((j - i) >> 1);
        if(mid % 2 === 1){
            // mid为奇数则-1变为偶数 则mid现在必为“边缘” 不必再分四种情况来讨论
            // 这就是仅对偶数索引进行二分搜索！
            mid--;
        }
        if(nums[mid + 1] === nums[mid]){
            // 去除mid那一对数之后，左侧数必为偶数，右侧数必为奇数，继续去紧挨着那对数的右边1个找
            i = mid + 2;
        }
        else{
            // 去除mid那一对数之后，左侧数为奇数，右侧数必为偶数，继续去紧挨着那对数的左边1个找
            j = mid;// 此时mid已经在原基础上左移一位了 所以j直接放在mid这个位置即可
        }
    }
    return nums[i];
};
```

- 时间复杂度：O(log n/2) = O(log*n*)。我们仅对元素的一半进行二分搜索。

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

##### 位运算-分组异或

这个分组的方法就很灵性。

```js
var singleNumbers = function(nums) {
    let n = 0;
    // 01 n 为 两个单独数a b的乘积
    // 接下来(02中)使用与运算
        // 与运算特点 二进制中只有6&6 = 6 6&0 = 0&0 =0
    for(let num of nums){
        n ^= num;
    }
    // 02 m可以保证这个数组中单身的两个数a b中的一个可以不被它抵消掉 
    // 也就是 m&a = 0 m&b != 0
    let m = 1;
    while((n & m) === 0){
        // 只要n&m不为0 就一直让m左移，直到m可以抵消掉a与b中的一个
        m <<= 1;
    }
    // 03 接下来使用m把两个单独的数分在两堆 并分组
    let x = 0, y = 0;
    for(let num of nums){
        if((num & m) === 0){
            x ^= num;
        }
        else{
            y ^= num;
        }
    }
    return [x, y];
};
```

> 看不懂我这个解释（或者觉得太大白话） 可以看看 [K神的题解](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)



#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

同[剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)一样

##### 暴力哈希解

```js
var singleNumber = function(nums) {
    let map = new Map();
    for(let num of nums){
        if(map.get(num) > 0){
            let count = map.get(num);
            count++;
            map.set(num, count);
        }
        else{
            map.set(num, 1);
        }
    }
    for(let [num,count] of map.entries()){
        if(count === 1){
            return num;
        }
    }
};
```

[其他方法](https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/)太恶心了 饶了我吧…我真不想做位运算了😢😢😢😢😢😢

## 【4】数组经典面试题

> 这部分题目由leetcode官网的“学习计划”提供，都是经典习题~

#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

经典的数组查重问题！

- 【1】利用判重API `indexOf`构建去重辅助数组

```js
var containsDuplicate = function(nums) {
    let newArr = []
    for(let i = 0; i < nums.length; i++) {
        if(newArr.indexOf(nums[i]) === -1) {
            newArr.push(nums[i])
        }
    }
    return newArr.length !== nums.length
};
```

执行用时较高！想必是indexOf方法的锅咯~

- 【2】利用数据结构Set 构造只有单一元素的Set对象,判断Set对象与原数组长度是否相同

```js
var containsDuplicate = function(nums) {
    let newArr = new Set(nums)
    return newArr.size !== nums.length
};
```

- 同理 使用哈希表记录出现的次数也可以~

这里用Set其实更好哈~主要上面刚用过 换个口儿😄

```js
var containsDuplicate = function(nums) {
    let map = new Map()
    for(let i = 0; i < nums.length; i++) {
        if(map.has(nums[i])) {
            return true
        }
        else{
            map.set(nums[i], 1)
        }
    }
    return false
};
```

时间复杂度O(N)

空间复杂度O(N)

- 【3】排序后冒泡比较

这里可以拓展炫技手写个排序出来？😏

```js
var containsDuplicate = function(nums) {
    nums.sort((a, b) => a - b)
    for(let i = 0; i < nums.length - 1; i++) {
        if(nums[i] === nums[i + 1]) {
            return true
        }
    }
    return false
};
```

时间复杂度O(N*log~N~)

空间复杂度O(log~N~) 在这里应当考虑排序时递归调用栈的深度。

>  V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，
>
> - 数量小于10的数组使用 `InsertionSort`-插入排序
> - 比10大的数组则使用 `QuickSort`-快速排序
>
> 详情见[V8 引擎array源码](https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js) 710行开始 快排在760行处



- 【4】说干就干！来手写个快排！参考之前写过的一篇[Java题解](https://blog.csdn.net/qq_45704942/article/details/116448702?spm=1001.2014.3001.5502)（写得贼详细 每一步都拆分开来说了！），这篇文章是参考的leetcode主站的一篇[优秀图解 by 袁厨](https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/)~（好家伙连环参考）

快排分以下几步

1.选出基准值

2.使用[填坑法](https://leetcode-cn.com/problems/sort-an-array/solution/dong-hua-mo-ni-yi-ge-kuai-su-pai-xu-wo-x-7n7g/)，写一个partition函数将数组分为小于基准值和大于基准值两部分

3.递归完成快排！

下面代码里这个注释很清楚了吧！

另外还写了个[题解](https://leetcode-cn.com/problems/sort-an-array/solution/javascriptjava-chao-xiang-xi-ti-jie-tian-dsvc/) 搭配图看着更舒服哈~

```js
var sortArray = function(nums) {
    quicksort(nums, 0, nums.length - 1)// 调用快排方法
    return nums
};
var quicksort = function(nums, low, high) {
    if(low < high) {
        let index = partition(nums, low, high)// 得到用来将数组分成两部分（左面全小于index 右面全大于index）的索引
        quicksort(nums, low, index - 1)// 以第一轮得出的index为基准划分出左半区和右半区 对数组的左半区进行递归 将其全部变为有序
        quicksort(nums, index + 1, high)// 同理左半区
    }
}
var partition = function(arr, low, high) {
    let pivot = arr[low]// 选定第一个元素为基准值 把它拿出来 即为“挖坑”
    while(low < high) {
        // 【1】 挖了坑就需要填坑~从high指针开始向左找 
        while(low < high && arr[high] >= pivot) {
            high--
        }
        arr[low] = arr[high]// 一旦找到比坑对应值pivot小的 就扔到low那侧的坑里
        // 【2】 同【1】从low指针开始向右找填坑值
        while(low < high && arr[low] < pivot) {
            low++
        }
        arr[high] = arr[low]// 一旦找到比坑对应值pivot大的 就扔到high那侧的坑里
        //（刚刚这侧有一个值去填low那侧的坑了 所以出现了一个坑位~）
    }
    // 经过上面【1】【2】的不断迭代 low===high 此时这个位置即为基准位置
    arr[low] = pivot
    return low// 分区成功！返回定海神针~（此时low=high哦~）
}
```

> 再拓展补充下~
>
> - 不稳定的四种排序方法 **快选希堆** 
>
> - 最快的排序方法 **快速排序 归并排序** 时间复杂度为 n×log~n~

#### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

> 字节日常实习二面遇到的一题

- 【1】贪心思想找到关键点解决问题

关键是：维护一个当前遍历到的元素之和sum 只要sum<0 那么就丢弃上一组元素 让sum=当前元素

![image-20211201160632347](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011606431.png)

```js
var maxSubArray = function(nums) {
    let max = nums[0]
    let sum = nums[0]
    let n = nums.length
    for(let i = 1; i < n; i++) {
        if(sum < 0) {
            sum = nums[i]
        }
        else {
            sum += nums[i]
        }
        max = max > sum ? max : sum
    }
    return max
}; 
```

- 【2】动态规划

本题是超级经典的动态规划题型~

对dp几乎一窍不通的我向weiwei哥[学习了一下](https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)~

*需要我们掌握动态规划问题设计状态的技巧（**无后效性**）

*我们需要知道如何推导状态转移方程

运用动态规划解题过程如下：

1.定义状态 `dp[i]`：表示以 `nums[i]`（也就是第i个元素） **结尾** 的 **连续** 子数组的最大和。

2.写出状态转移方程（描述子问题之间的联系）

这也是所有dp问题的关键

在本题中我们研究一个连续求和的问题——

- 如果 `dp[i - 1] > 0`，那么可以把 `nums[i]` 直接接在 `dp[i - 1]` 表示的那个数组的后面，得到和更大的连续子数组；
- 如果 `dp[i - 1] <= 0`，那么 `nums[i]` 加上前面的数 `dp[i - 1]` 以后值不会变大。（这里其实和贪心思想是一致的！）于是 `dp[i]` 「另起炉灶」，此时单独的一个 `nums[i]` 的值，就是 `dp[i]`。

以上两种情况的最大值就是 `dp[i]` 的值，写出如下状态转移方程：（上下两个状态转移方程同理嗷~）

![image-20211201162011012](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011620083.png)

3.思考初始值

`dp[0]` 根据定义，只有 1 个数，一定以 `nums[0]` 结尾，因此 `dp[0] = nums[0]`。

> 根据「状态转移方程」，`dp[i]` 的值只和 `dp[i - 1]` 有关，因此可以使用「滚动变量」的方式将代码进行优化。

【1】不进行空间优化的dp解

（也是看起来比较像动态规划的解法hhh）

```js
var maxSubArray = function(nums) {
    let n = nums.length
    let dp = new Array(n)// dp[i]表示以nums[i]结尾的连续子数组的最大和
    dp[0] = nums[0]
    let max = dp[0]// 记录最大子数组和
    for(let i = 1; i < n; i++) {
        // 根据状态转移方程计算dp[i]的值
        if(dp[i - 1] > 0) {
            dp[i] = dp[i - 1] + nums[i]
        }
        else {
            dp[i] = nums[i]
        }
        max = max > dp[i] ? max : dp[i]// 不断更新最大值
    }
    return max
};
```



【2】进行空间优化的dp解

> 与贪心算法非常类似！本方法中pre+num就相当于贪心法中的sum 比较sum与num选取更大的一方
>
> 而贪心法是只有sum小于0时才选取下一个
>
> 相比之下我认为这个动态规划的思想要更加出色与容易理解！

```js
var maxSubArray = function(nums) {
    let pre = 0
    let max = nums[0]
    for(let num of nums) {
        // 因为本题中 dp[i] 的值只和 dp[i - 1] 有关 
        // 所以可以使用这种滚动变量的方法（也可以说是 归并法~比较像reduce方法的感觉~）
        // 使用变量pre代替dp[i-1]
        pre = Math.max(pre + num, num)
        max = Math.max(max, pre)
    }
    return max
};
```

这里weiwei哥对空间优化补充了一下~

![image-20211201163957005](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011639084.png)

最后评论区里再学习一波

感谢weiwei哥详尽的分享！

![image-20211201162449105](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011624186.png)

![image-20211201162423302](https://gitee.com/su-fangzhou/blog-image/raw/master/202112011624388.png)

#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

一些简单题是很可以考察思维的~可以思考下本题除了暴力破解还可以有什么好方法呢？

- 【1】暴力双层遍历

```js
var twoSum = function(nums, target) {
    for(let i = 0; i < nums.length - 1; i++) {
        for(let j = i + 1; j < nums.length; j++) {
            if(nums[i] + nums[j] === target) {
            	return [i, j]
            }
        }
    }
};
```

- 【2】哈希表＋变加法为减法——一趟遍历解决问题

```js
// 借助数据结构Map
var twoSum = function(nums, target) {
    let map = new Map()
    for(let i = 0; i < nums.length; i++) {
        let t = target - nums[i]// 将问题变为减法，t是通过减法获得的要找的那个值
        if(map.has(t)) {
            return [i, map.get(t)]
        }
        else { 
            map.set(nums[i], i)// 为避免返回重复的值 先判断map中是否有值再进行填充
        }
    }
};
```

- 【还可以使用更高效的数组来直接模拟哈希表

```js
var twoSum = function(nums, target) {
    let n = nums.length
    let map = new Array(n)
    for(let i = 0; i < n; i++) {
        let t = target - nums[i]// 要找的那个值
        if(map[t] >= 0) {
            return [i, map[t]]
        }
        else { 
            map[nums[i]] = i// 为避免返回重复的值 先判断map中是否有值再进行填充
        }
    }
};
```

#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

- 【1】取巧-暴力插入后全体排序

```js
var merge = function(nums1, m, nums2, n) {
    for(let i = 0; i < n; i++) {
        nums1[i + m] = nums2[i]
    }
    nums1.sort((a, b) => a - b)
};
```

> 面试官：“啥？没有优化了么？哦这样，好的，今天的面试就到这里了 你还有什么想问我的麽”

- 【2】利用辅助数组和同向双指针

抄一下官方题解的动图 很形象~

![img](https://assets.leetcode-cn.com/solution-static/88/1.gif)

```js
var merge = function(nums1, m, nums2, n) {
    let ans = []
    let i = 0, j = 0
    while(i < m || j < n) {
        // 如果双指针任意一个到达了边界 则将另一个数组中的值加入结果数组
        if (i === m) {
            ans.push(nums2[j++])
        }
        else if (j === n) {
            ans.push(nums1[i++])
        }
        // 将较小的值加入结果数组
        else if (nums1[i] < nums2[j]) {
            ans.push(nums1[i++])
        }
        else if (nums1[i] >= nums2[j]){
            ans.push(nums2[j++])
        }
    }
    // 因为最后要返回nums1 所以要把结果数组中的内容加入nums1中
    for(let i = 0; i < ans.length; i++) {
        nums1[i] = ans[i]
    }
};
```

- 【3】不需要辅助空间+反向双指针原地完成

```js
var merge = function(nums1, m, nums2, n) {
    let i = m - 1, j = n - 1
    let tail = m + n - 1
    let cur;
    while(i >= 0 || j >= 0) {
        // 遍历完一个数组则拿另一个数组中的值
        if (i === -1) {
            cur = nums2[j--]
        }
        else if (j === -1) {
            cur = nums1[i--]
        }
        // 拿到较大的值 放到尾部
        else if (nums1[i] < nums2[j]) {
            cur = nums2[j--]
        }
        else if (nums1[i] >= nums2[j]) {
            cur = nums1[i--]
        }
        nums1[tail--] = cur
    }
};
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- 一趟循环——贪心法

贪心地在日价格prices[i]更低的时候记录一下~

```js
var maxProfit = function(prices) {
    let maxProfit = 0// 如果无法盈利则返回0
    let lowPrice = prices[0]
    for(let i = 0; i < prices.length; i++) {
        lowPrice = lowPrice < prices[i] ? lowPrice : prices[i]// 每轮更新最低买入价格
        let profit = prices[i] - lowPrice
        maxProfit = profit > maxProfit ? profit : maxProfit// mei
    }
    return maxProfit
};
```

#### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

- 双层比对暴力解

纯粹为了练练编码速度~

```js
var intersect = function(nums1, nums2) {
    // 首先尝试下暴力大法 练练熟练度
    let m = nums1.length
    let n = nums2.length
    // 找出来数组长度较短的那一个-nums1 算是效率较高的暴力解吧~
    if(m < n){  
        return intersect(nums2, nums1)
    }
    let res = []
    for(let i = 0; i < nums1.length; i++) {
        for(let j = 0; j < nums2.length; j++) {
            if(nums1[i] === nums2[j]) {
                res.push(nums1[i])
                nums2.splice(j, 1)// 及时删去较长数组中的元素
                break
            }
        }
    }
    return res
};
```

- 排序＋双指针

比对两个数组使用的常客——双指针~~

```js
var intersect = function(nums1, nums2) {
    // 先将二者升序排列
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);
    let l1 = 0, l2 = 0;// 给出同向双指针
    let res = [];
    // 双指针法熟悉的while循环
    while(l1 < nums1.length && l2 < nums2.length){
        if(nums1[l1] === nums2[l2]){
            // 找到元素则双指针都往后走一位
            res.push(nums1[l1]);
            l1++;
            l2++;
        }
        else if(nums1[l1] > nums2[l2]){
            l2++;
        }
        else{
            l1++
        }
    }
    return res;
};
```



- 哈希表

很容易想到的哈希表方法

感觉涉及到“元素在序列中出现的次数符合xxx要求”的问题都可以用哈希表记录一个状态，有点像人工智能研究中的一个思维方式——“咋让机器（有）学习（能力）？整几个表记录学习过程中的状态，智能体下一步的策略根据这个表来进行！”（啥你问我为啥刷题时候能想到机器学习？前段时间实验做多了的缘故吧！）

```js
var intersect = function(nums1, nums2) {
    // 本题 哈希表中存储的形式为 {num: count}
    let map = new Map();
    let res = [];
    if(nums1.length > nums2.length){
        // 将较短的数组存入哈希表中 降低空间复杂度 一天一个优化小技巧~
        return intersect(nums2, nums1);
    }
    // 将较短的数组存入哈希表中
    for(let x of nums1){
        let count = map.get(x);//根据数组的元素 获得“值”
        if(count > 0){//判断这个值是否已经插入过哈希表
            count++;
            map.set(x, count);
        }
        else{
            map.set(x, 1)
        }
    }
    for(let x of nums2){
        // 开始进行比对
        let count = map.get(x);//如果哈希表中有x这个键 那么获取它对应的count
        if(count > 0){
            res.push(x);
            count--;
            map.set(x, count);
        }
    }
    return res;
};
```

#### [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

- 先将老数组mat扁平化再赋值给新数组

直接使用一个一维数组进行过渡

```js
var matrixReshape = function(mat, r, c) {
    let m = mat.length
    let n = mat[0].length
    // reshape操作不合理则输出原始矩阵
    if(m * n !== r * c) {
        return mat
    }
    let queue = mat.flat()// 数组扁平化获得一维数组 存在队列中 FIFO
    let ans = []// 最终答案数组
    console.log(queue)
    for(let i = 0; i < r; i++) {
        let temp = []// 共有r个temp最终需要存到ans中
        for(let j = 0; j < c; j++) {
            temp.push(queue.shift())
        }
        ans.push(temp)
    }
    return ans
};
```



- 将二维数组映射成为一维数组 不用借助flat函数拍平！

直接从二维数组 nums 得到 r 行 c 列的重塑矩阵

![image-20211206132935372](https://gitee.com/su-fangzhou/blog-image/raw/master/202112061329519.png)

```js
var matrixReshape = function(mat, r, c) {
    let m = mat.length
    let n = mat[0].length
    if(m * n !== r * c) {
        return mat
    }
    let ans = new Array(r).fill(0).map(() => new Array(c).fill(0))
    for(let i = 0; i < m * n; i++) {
        ans[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n]
    }
    return ans
};
```

时间复杂度：O(rc)

空间复杂度：O(1)

#### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

- 暴力找规律(数学)法

```js
var generate = function(numRows) {
    // 比较暴力的找规律法——根据上一行的两个值算出本行的值
    let ans = []
    for(let i = 0; i < numRows; i++) {
        let temp = new Array(i + 1).fill(1)
        for(let j = 1; j < i; j++) {
            temp[j] = ans[i - 1][j - 1] + ans[i - 1][j] 
        }
        ans.push(temp)
    }
    return ans
};
```



# 02 字符串

## 【1】刷题必掌握的API

#### [`String.prototype.substring()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring)

> **`substring() `**方法返回一个字符串在**开始索引到结束索引之间的一个子集**, 或从开始索引直到字符串的末尾的一个子集。
>
> ```js
> str.substring(indexStart[, indexEnd])
> ```
>
> - `indexStart`
>
>   需要截取的第一个字符的索引，该索引位置的字符作为返回的字符串的首字母。
>
> - `indexEnd`
>
>   可选。一个 0 到字符串长度之间的整数，**以该数字为索引的字符不包含在截取的字符串内**。

```js
var anyString = "bill";
// 输出"bil" 
console.log(anyString.substring(0,3));
// 下面这些神奇的用法同样可以输出索引 0 1 2 的字符
console.log(anyString.substring(3,0));
console.log(anyString.substring(3,-3));
console.log(anyString.substring(3,NaN));
console.log(anyString.substring(-2,3));
console.log(anyString.substring(NaN,3));
// 比较好用的一个取数技巧
var test = "xbill";
// 获取字符串bill 剔除前面的字符
test.substring(1);// "bill" 比较实用~
```



##  【2】字符串必会题型

> 字符串在算法面试中，单独考察的机会并不多，同样倾向于和一些经典算法（后面会讲的）结合来体现区分度。本节我们先解决只需要数据结构知识做基础就可以解决的字符串问题。
>
> 两个字符串相关的基本算法技能
>
> - 反转字符串
> - 判断是否为回文字符串
>
> 这两个技能偶尔也会单独命题，但整体来看在综合性题目中的考察频率较高，需要大家**着重熟悉、反复练习和记忆**，确保真正做题时万无一失。（链表的题里面这二位也是经典得不行勒！）



### 反转字符串

直接调用API即可（还有其他的方法，比较体现技巧，一些公司一面为了试水，有时会单独考这个操作）

```js
let str = "bytedance";
let res = str.split("").reverse().join("");// "ecnadetyb"
```

这里的核心主要是数组的API  `reverse()`

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

[代码随想录题解](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)

- 双指针

```js
var reverseString = function(s) {
    let i = 0, j = s.length - 1;
    while(i < j){
        [s[i], s[j]] = [s[j], s[i]];// 解构赋值快速交换两个数的位置~
        i++;
        j--;
    }
    // return s;这里的字符串没有被改变，依旧是原来的顺序，不理解的可以在下一题试一试，看看还能不能这么反转
    // 题目中每组[s[i],s[j]]的顺组改变了，最终返回一个反转好的字符数组
};
```



#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

与344的反转字符串容易搞混的点在于：

344中测试代码接收的结果为`[s[s.length-1],...s[1],s[0]]`——是一个字符数组 

而本题要求返回字符串，需要对数组&字符串的转换很熟悉！

```js
var reverseStr = function(s, k) {
    let loop = Math.ceil(s.length / (2*k));// 需要进行对撞双指针遍历的轮数loop
    let arr = s.split("");// 将字符串拆成数组，方便最后返回结果arr.join(""),不然交换元素不能改变字符串本身
    for(let m = 0; m < loop; m++){
        // 每轮双指针的位置如下：（也是本题的关键）
        let i = m*2*k;
        let j = (s.length - i) < k ? s.length - 1 : i + k - 1;// 若剩余字符<k 则j指针位于字符串的末尾（将剩余字符全部反转）
        while(i < j){
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
            j--;
        }
    }
    return arr.join("");
};
```



### 回文字符串

判断一个字符串是否回文是必备技能！

回文字符串例子

```js
let str = "gooddoog"
```

- 【1】使用额外的空间存一个新字符串，看看与最开始的是否是同一个

最简单的想法，但是空间复杂度为 O(N)

```js
let newStr = str.split('').reverse().join('');
return newStr === str;
```

- 【重要】【2】利用字符串以中间为轴的对称性，使用双指针

```js
for(let i = 0; i < str.length; i++){
    // 遍历字符串的前半部分，如果与后半部分相同，则满足对称性
    if(str[i] !== str[str.length - i]){
        return false;
    }
}
return true;
```



#### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

这题一个比较重要的点是要做数据预处理，把空格、逗号、冒号啥的都去除XD

```js
s = "I:am:bill, llib ma I";// 这个字符串回文的必要条件是剔除掉空格、特殊符号们
```



- 使用正则表达式进行数据预处理

这种方法一劳永逸，一次性去除特殊字符

```js
let newS = s.toLowerCase().match(/[a-z0-9]+/g);
console.log(newS);// ['i','am', 'bill', 'llib', 'ma', ]
// 使用match方法在字符串内索引指定值/找到一个或多个正则表达式的匹配
// 查找从大写A到小写z的字符，并返回匹配值
```



- 写一个**判断遍历到的字母是否位于 a-z / 0-9 之间** 的函数 进行数据预处理

这种方法要求进行遍历，并在遍历过程中进行调用函数，判断对应字符是否符合要求

另外注意：在JS中进行字符串的比较大小实际上就是比较它们的ASCII码值的大小~如下：

![image-20211024222125820](https://gitee.com/su-fangzhou/blog-image/raw/master/202110242221956.png)

建议搭配双指针使用

```js
function isValid(str){
    return str >= 'a' && str <= 'z' || str >= '0' && str <= '9';
}
// 如果遍历到的字母
```



将数据预处理好了之后，有三种经典的解决方法

![image-20211024214937424](https://gitee.com/su-fangzhou/blog-image/raw/master/202110242149557.png)

是的，就是`reverse、 双指针、栈`三种方法

- 【1】正则匹配 + reverse法

reverse法非常适合与正则表达式搭配对题目进行秒杀

```js
var isPalindrome = function(s) {
    let valid = s.toLowerCase().match(/[a-z0-9]+/g);// valid为进行正则匹配后筛选出来的数组
    if(!valid){
        return true;
    }
    let str = valid.join("");// 数据预处理(正则匹配)后得到的字符串
    let comp = str.split("").reverse().join("");// 将字符串翻转
    return comp === str;
};
```

- 【2】特殊字符处理函数 + 双指针

```js
var isPalindrome = function(s) {
    var str = s.toLowerCase();
    // 定义好一头一尾的双指针
    let i = 0;
    let j = str.length - 1;

    while(i < j){
        // i/j不符合下面的isValid就推动左/右指针 并结束本轮迭代
        if(!isValid(str[i])){
            i++;
            continue;
        }
        if(!isValid(str[j])){
            j--;
            continue;
        }
        if(str[i] !== str[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;
};
var isValid = function(str){
    return (str >= 'a' && str <= 'z') || (str >= '0' && str <= '9');
}
```

- 【3】正则匹配 + 栈

```js
var isPalindrome = function(s) {
    let valid = s.toLowerCase().match(/[a-z0-9]+/g);
    if(!valid){
        return true;
    }
    let str = valid.join("");// 正则匹配过后获得的字符串
    let stack = [];
    
    let mid = str.length >> 1;// 设置中间的位置，入栈至str[mid - 1]再遍历后续内容 并与栈中内容一一比对
    for(let i = 0; i < mid; i++){
        stack.push(str[i]);
    }
    // 入栈完毕，接下来进行比对
    // 额外注意：如果字符串长度为奇数，应该跳过中间的字符进行比对
    if(str.length % 2){
        mid++;
    }
    for(let i = mid; i < str.length; i++){
        let comp = stack.pop();// 将元素一一出栈
        if(comp !== str[i]){
            return false;
        }
    }
    return true;
};
```



#### [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

经典衍生问题

> 本质思想依旧是利用回文字符串的对称性——自然而然地想到了双指针~
>
> 要记住！
>
> - 对称性
> - 双指针
>
> 可以解决大部分回文字符串相关问题！

另外本体需要我们头脑清晰地创建一个**工具方法**——`isPalindrome(s, i, j)` 判断字符串s`从i到j`是否局部回文！

```js
var validPalindrome = function(s) {
    let i = 0;
    let j = s.length - 1;
    while(i < j){
        if(s[i] !== s[j]){
            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);
        }
        i++;
        j--;
    }
    return true;
};
// 判断从i到j的s是否回文！跳过某一项之后局部回文，则整体回文！
// eg: cuppucu 
    // 先判断 uppucu 发现不回文 
    // 再判断 cuppuc 发现回文
var isPalindrome = function(s, i, j){
    while(i < j){
        if(s[i] !== s[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;
}
```



### 实用技巧-正则表达式

> 暂时跳过了，正则表达式回头根据情况学一下咯！

#### [【medium】211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)

> 设计题
>

#### [【medium】8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

## 【3】字符串高频面试题

> 这部分内容为汇总的一些前端面试高频算法题~

## 【4】字符串经典面试题

#### [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

- 利用哈希表存储数频

```js
var firstUniqChar = function(s) {
    let map = new Map()
    for(let i = 0; i < s.length; i++) {
        if(map.has(s[i])) {
            let count = map.get(s[i]) + 1
            map.set(s[i], count)
        }
        else {
            map.set(s[i], 1)
        }
    }
    for(let i = 0; i < s.length; i++) {
        if(map.get(s[i]) === 1) {
            return i
        }
    }
    return -1
};
```

#### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

- 用哈希表（利用map数据结构）存储杂志的字符串出现次数，与信上一一比对

可以用来熟练下Map数据结构的使用，但是在碰到**需要哈希表记录出现频率**的场景使用一维数组比使用Map数据结构要优秀！

```js
var canConstruct = function(ransomNote, magazine) {
    let mapMag = new Map()
    // 用哈希表存储杂志的字符串出现次数
    for(let str of magazine) {
        if(mapMag.has(str)) {
            let count = mapMag.get(str) + 1
            mapMag.set(str, count)
        }
        else {
            mapMag.set(str, 1)
        }
    }
    // 进行比对
    for(let str of ransomNote) {
        if(!mapMag.has(str) || mapMag.get(str) <= 0) {
            return false
        }
        else {
            // 发现相同字符则将哈希表中记录的频率-1
            let count = mapMag.get(str) - 1
            mapMag.set(str, count)
        }
    }
    return true
};
```

- 更高效的哈希表方法——用长度为26的一维数组模拟哈希表

所有**涉及到字符出现频率的哈希表问题**都建议用这个方法！构造简单，效率高🤤

```js
var canConstruct = function(ransomNote, magazine) {
    let mapMag = new Array(26).fill(0)
    // 用哈希表存储杂志的字符串出现次数
    for(let str of magazine) {
        mapMag[str.charCodeAt() - 'a'.charCodeAt()]++
    }
    // 进行比对
    for(let str of ransomNote) {
        // 发现相同字符则将哈希表中记录的频率-1
        mapMag[str.charCodeAt() - 'a'.charCodeAt()]--
        if(mapMag[str.charCodeAt() - 'a'.charCodeAt()] < 0) {
            return false
        }  
    }
    return true
};
```

另外可以在最开始优化一下

```js
if(ransomNote.length > magazine.length) {
    // 随手一写的特殊情况排除 显示出考虑的全面性~~
    return false
}
```



#### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

- 使用哈希表记录字符串出现频率并进行比对

```js
var isAnagram = function(s, t) {
    if(s.length !== t.length) {
        return false// 特殊条件判断下~
    }
    let map = new Array(26).fill(0)
    // 创建哈希表记录字符串t的字符串频率
    for(let str of t) {
        map[str.charCodeAt() - 'a'.charCodeAt()]++
    }  
    // 与字符串s进行比对
    for(let str of s) {
        // 防止s中字符比t中多——如果发现t中没有s中的字符，则返回false
        if(map[str.charCodeAt() - 'a'.charCodeAt()] <= 0) {
            return false
        }
        else {
            map[str.charCodeAt() - 'a'.charCodeAt()]--
        }
    }
    // 防止t中字符比s中多——最后要保证哈希表中记录的字符串出现频率为空
    return !map.includes(1)
};
```

- 排序之后一一比对

一行了事~

另外字符串和数组来回倒腾的方法也要非常熟练~

```js
var isAnagram = function(s, t) {
    // 因为是小写字母的排序，所以直接调用sort排序就好~
    // 如果大小写都有则需要在sort里面用toLowerCase()全转化成小写再进行比较
    return s.length === t.length && [...s].sort().join('') === Array.from(t).sort().join('')
};
```



# 03 链表

## 【1】链表基础

#### 链表结点的构造函数

```js
function ListNode(val, next){
    this.val = val;
    this.next = next;
}
// 创建结点node时，传入数据域对应的值val；指定next-下一个链表结点
let head = new ListNode(1);// 头结点，值为1
head.next = new ListNode(2);// 头结点指向的结点，值为2
let dummyHead = new ListNode(0, head);// 虚拟头结点，指向头结点head
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816ad2c296f74df78342093e4d6edcf6~tplv-k3u1fbpfcp-watermark.awebp)



## 【2】链表基础操作【刷题】

数组、字符串若想往难了出，那一定是要结合一些超越数据结构本身的东西——比如排序算法、二分思想、动态规划思想等等

但是链表可不一样了。如果说在命题时，数组和字符串的角色往往是“算法思想的载体”，那么链表本身就可以被认为是“命题的目的”。

结合实际面试中的命题规律，我把这些题目分为以下三类：

- 链表的处理
  - 合并
  - **删除**（重点！）
- 链表的反转 以及 衍生题目
- 链表成环问题 以及 衍生题目

[快速上手——从0到1掌握算法面试需要的数据结构（二）-栈、队列、链表](https://juejin.cn/book/6844733800300150797/section/6844733800342093837)

[链表的应用——真题归纳与解读](https://juejin.cn/book/6844733800300150797/section/6844733800350498823)

### 【1】链表的合并

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)（递归法重要！）

这俩题一样哈——[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

##### 迭代法

![image-20211207225850392](https://gitee.com/su-fangzhou/blog-image/raw/master/202112072258508.png)

```js
var mergeTwoLists = function(l1, l2) {
    let dummyHead = new ListNode(0, l1);
    let cur = dummyHead;
    while(l1 !== null && l2 !== null){
        if(l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        }
        else{
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    cur.next = l1 === null ? l2 : l1;
    return dummyHead.next;
};
```

OJ中链表以数组形式展示，打印出来就一目了然了~

```js
var mergeTwoLists = function(list1, list2) {
    let dummyHead = new ListNode(0, list1)
    let cur = dummyHead
    while(list1 !== null && list2 !== null) {
        if(list1.val <= list2.val) {
            // console.log(list1, cur, dummyHead)
            cur.next = list1
            list1 = list1.next
        }
        else {
            // console.log(list2, cur, dummyHead)
            cur.next = list2
            list2 = list2.next
        }
        cur = cur.next
    }
    cur.next = list1 === null ? list2 : list1
    // console.log(cur, dummyHead)
    return dummyHead.next
};
```

![image-20211207230112277](https://gitee.com/su-fangzhou/blog-image/raw/master/202112072301365.png)

可以清晰地看出来 cur就像是虚拟头结点`dummyHead`的打工人一样，不断前进并把list2中的内容按照升序加入list1中（因为`dummyHead`是根据list1创建的）

最终返回`dummyHead.next`即可得到最终结果

##### 递归

> 要了解**递归调用栈**的原理！
>
> 第二步过程中着重思考**最内层**（递归调用栈**栈顶的函数**）即可（也就是达成边界条件的那一步）！

```js
var mergeTwoLists = function(list1, list2) {
    if(list1 === null) {
        return list2// 递归第一步——
        // 边界条件：碰到一个链表走到null 就结束递（将函数放入递归调用栈）开始归（根据递归调用栈顺序开始调用对应函数）
    }
    else if(list2 === null) {
        return list1
    }
    else if(list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2)// 递归第二步——
        // 逐步将内层函数放入递归调用栈中
        return list1
    }
    else {
        list2.next = mergeTwoLists(list1, list2.next)
        return list2
    }
};
```

[递归法图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)

递归就思考第一层第二层最好

每层不要忘了返回当层结果（执行这一次递归函数 返回的结果）！

以原始用例 [1,2] [1,3,4]

【1】**开始“递”** 一直到最里面那一层 

- l1小的时候 l1指向再里层一些的那个递归函数`mergeTwoLists()`别忘了l1要往前挪动一位 `mergeTwoLists(l1.next, l2)`
- l2小的时候同理

![img](https://pic.leetcode-cn.com/fe5eca7edea29a76316f7e8529f73a90ae4990fd66fea093c6ee91567788e482-%E5%B9%BB%E7%81%AF%E7%89%874.JPG)

【2】return l2 执行时

![img](https://pic.leetcode-cn.com/e59fd2981f3633cc70a90bd3136e07647ecf89c6f4eefb82159ea54db9772889-%E5%B9%BB%E7%81%AF%E7%89%875.JPG)

**这里结束了“递”** 

最里面那层的`mergeTwoLists()`执行完了

开始“归” —— 逐步执行外层的`mergeTwoLists()`函数

【3】最外面一层函数执行完 

![img](https://pic.leetcode-cn.com/e95ec0c841cfa308e5789eb1f9f214f785bc77d99214c01504b303939581eb07-%E5%B9%BB%E7%81%AF%E7%89%877.JPG)

就可以返回最终结果了~

![img](https://pic.leetcode-cn.com/c1687ef7811036b7b5e58e4882ed12e243f6a77ddb8077123f013ef094cafd73-%E5%B9%BB%E7%81%AF%E7%89%878.JPG)

还有点懵？问题不大 按顺序打印一下每一步的状态——

```js
var mergeTwoLists = function(list1, list2) {
    if(list1 === null) {
        console.log(list2)
        return list2// 递归第一步——
        // 边界条件：碰到一个链表走到null 就结束递（将函数放入递归调用栈）开始归（根据递归调用栈顺序开始调用对应函数）
    }
    else if(list2 === null) {
        return list1
    }
    else if(list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2)// 递归第二步——
        // 逐步将内层函数放入递归调用栈中
        console.log(list1)
        return list1
    }
    else {
        list2.next = mergeTwoLists(list1, list2.next)
        console.log(list2)
        return list2
    }
};
```

结果如下

![image-20211207232905819](https://gitee.com/su-fangzhou/blog-image/raw/master/202112072329904.png)

### 【2】链表的删除

要点：找要删除的结点的**前一个**结点

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

超经典链表删除题！

```js
var removeElements = function(head, val) {
    let dummyHead = new ListNode(0, head)
    let pre = dummyHead// 使用虚拟头结点避免在用例需要删除头结点时删不掉头结点
    while(pre !== null && pre.next !== null) {
        if(pre.next.val === val) {
            // 删除关键操作~
            pre.next = pre.next.next
        }
        else {
            pre = pre.next
        }
    }
    return dummyHead.next
};
```

如果不用虚拟头结点就会在需要删除头结点的用例中出错~

以身试法😑

![image-20211208000248479](https://gitee.com/su-fangzhou/blog-image/raw/master/202112080002605.png)

想不用虚拟头结点就得先循环把头结点删了 

嘿！这才算是把虚拟头结点理解透了嘛！

```js
var removeElements = function(head, val) {
    // 先跳过所有头结点
    while(head !== null && head.val === val) {
        head = head.next
    }
    if(head === null) {
        return head
    }
    pre = head
    // 之后正常遍历即可~
    while(pre !== null && pre.next !== null) {
        if(pre.next.val === val) {
            pre.next = pre.next.next
        }
        else {
            pre = pre.next
        }
    }
    return head
};
```



#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

与上题略有一些不同~要删除重复元素而不是指定元素

因为第一个结点不会被删掉 所以不需要使用`dummyHead`~

```js
var deleteDuplicates = function(head) {
    let cur = head
    while(cur !== null && cur.next !== null) {
        if(cur.val === cur.next.val) {
            // 当前值与下一个值相同则 通过修改链表结点指向跳过这个值
            cur.next = cur.next.next
        }
        else {
            // 当前值与下一个值不相同则 结点继续移动 检查接下来的结点
            cur = cur.next
        }
    }
    return head
};
```



### 【3】链表删除的延伸（变式）

#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

但是现在，咱们要做的事情变成了把前驱和后继一起删掉，前面两个值为1的结点要一起狗带才行，起始结点直接变成了第三个：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7079d7513b3e~tplv-t2oaga2asx-watermark.awebp)

如果继续沿用刚才的思路，我们会发现完全走不通。因为我们的 cur 指针就是从图中第一个结点出发开始遍历的，无法定位到第一个结点的前驱结点，删除便无法完成。

> 虚拟头结点应用场景：

其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 `dummy` 结点来解决这个问题。

> 本题思路

如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7116f49a1dc4~tplv-t2oaga2asx-watermark.awebp)

如此一来，就大功告成啦~

注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。

```js
const deleteDuplicates = function(head) {
    // 极端情况：0个或1个结点，则不会重复，直接返回
    if(!head || !head.next) {
        return head
    }
    // dummy 登场
    let dummy = new ListNode() 
    // dummy 永远指向头结点
    dummy.next = head   
    // cur 从 dummy 开始遍历
    let cur = dummy 
    // 当 cur 的后面有至少两个结点时
    while(cur.next && cur.next.next) {
        // 对 cur 后面的两个结点进行比较
        if(cur.next.val === cur.next.next.val) {
            // 若值重复，则记下这个值
            let val = cur.next.val
            // 反复地排查后面的元素是否存在多次重复该值的情况
            while(cur.next && cur.next.val===val) {
                // 若有，则删除
                cur.next = cur.next.next 
            }
        } else {
            // 若不重复，则正常遍历
            cur = cur.next
        }
    }
    // 返回链表的起始结点
    return dummy.next;
};
```



#### [237. 删除链表中的结点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

![image-20211102212232070](https://gitee.com/su-fangzhou/blog-image/raw/master/202111022122175.png)

很有趣的一道题！你真的很熟悉链表的删除嘛？来试一试~

```js
var deleteNode = function(node) {
    // 本题关键：无法要删除“node”，没关系！把node.next赋值给node，再删掉node.next即可！
    let nodeNext = node.next;// 暂存下一个结点
    node.val = nodeNext.val;// 把node.next赋值给node
    node.next = nodeNext.next;// 再删掉node.next
};
```

评论区热评——

![image-20211102212321732](https://gitee.com/su-fangzhou/blog-image/raw/master/202111022123797.png)

很贴切有木有！！

### 【4】双指针的妙用

#### [【medium】29.删除链表的倒数第 N 个结点](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-nth-node-from-end-of-list%2F)

两个要点——

- 虚拟头结点
- 双指针（快指针先走一步~）

```js
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(0, head);
    let slow = dummy;
    let fast = dummy;
    for(let i = 0; i < n; i++){
        fast = fast.next;
    }
    while(fast !== null && fast.next !== null){
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return dummy.next;
};
```



#### [206.反转链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-linked-list%2F)

- 双指针法

这题的双指针写法相当经典！

在很多其他题型的解决方案种也有体现！（比如回文链表）

```js
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur !== null){
        let temp = cur.next;
        // 下面三步让局部的两个结点指向反转&各自前进一个结点
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};
```

分享一篇[GIF图解](https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/)，当初我就是看着这篇的GIF明白的😄

- 递归法速解

还可以使用递归的方法秒杀本题~

```js
var reverseList = function(head) {
    // “递”的过程 一直递到链表的最后一个结点 即为反转后的头结点
    if(head === null || head.next === null){
        return head;
    }
    let newHead = reverseList(head.next);// 把head.next这个子问题传进去 递归调用栈将调用函数reverseList入栈
    // “归”的过程——递归调用栈开始弹栈
    head.next.next = head;// 让下一个结点head.next的next指针指向当前结点head
    head.next = null;// 让当前结点head本来指向head.next的指针指向NULL
    // 至此 一次局部反转完成
    return newHead;
};
```

递归这里的动图看[这篇](https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/)~ 清楚！另外刚才那篇题解的递归图解也是不错的！

#### [【medium】92.反转链表 II](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-linked-list-ii%2F)

> 好题！局部反转！
>
> 要点：保存断开连接的边缘，用于连接反转过后得到的头结点

```js
var reverseBetween = function(head, left, right) {
    let dummy = new ListNode(0,head);
    let p = dummy;// 用于遍历
    for(let i = 0; i < left - 1; i++){
        p = p.next;
    }
    let leftHead = p;// 保存断开的边缘
    let start = leftHead.next;// 保存开始反转的边界
    // 设置双指针
    let pre = start;
    let cur = pre.next;
    for(let j = left; j < right; j++){
        // 反转局部链表
        let temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    leftHead.next = pre;// 连接最开始(断链的边缘)和局部反转链表反转过后得到的头结点
    start.next = cur;// 连接反转后的链表和后面那段链表
    return dummy.next;
};
```







### 【5】经典环形链表问题

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

快慢指针的经典（也是很简单的一个）实践~

**只要有环二者必定可以相遇**

- 比较简洁的双指针实现方式如下：

```js
var hasCycle = function(head) {
    let slow = head;
    let fast = head;
    while(fast !== null && fast.next !== null){
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){
            return true;
        }  
    }
    return false;
};
```

- 二刷的时候用了这个代码A的

可见思考问题还是不够全面！

```js
var hasCycle = function(head) {
    if(head === null || head.next === null) {
        return false
    }
    let slow = head
    let fast = head
    while(true) {
        fast = fast.next.next
        slow = slow.next
        // 这里就可以如上面一样简化咯！还不用写特例判断了！
        if(fast === null || fast.next === null) {
            return false
        }
        if(fast === slow) {
            return true
        }
    }
};
```



#### [【medium】142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> 超级经典的面试题，尽量对其中的数学原理多了解些！面试时候可以说出点东西最好！
>
> 我写的[题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/javascript-ba-zhong-deng-nan-du-zuo-chen-j8en/)
>
> 推荐看的[图文并茂的题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)（当时我就是看这个懂的！）

简单说一下这题的数学原理——

首先 设链表长度为 a + b(环内结点个数)

- 【1】slow指针a+nb步之后一定会到入口；

- 【2】二者第一次相遇时慢指针已经走了nb步；
  - 数学推导得来——fast走了`2*slow` 且第一次相遇时fast比slow快了 `b*n` 步 联立一下:
  - fast = 2 * slow ; fast = slow + n*b; —— `slow = n*b`

所以要让slow在第一次与fast相遇后再走a步停下来（满足刚好走完一整圈链表的长度）

这里建议看一下大佬们的图解XD 就很好理解了！

```js
var detectCycle = function(head) {
    let slow = head;
    let fast = head;
    // 01 让两个指针第一次相交 此时slow指针走了n*b步
    while(true){
        if(fast === null || fast.next === null){
            return null;
        }
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){
            break;
        }
    }
    // 02 换新的结点从头结点开始丈量a步 保证slow指针一共走了a+n*b步
    let newFast = head;
    while(slow !== newFast){
        newFast = newFast.next;
        slow = slow.next;
    }
    // 03 返回slow指向的结点 一定刚好走完一整圈
    return slow;
}
```





















# 04 二叉树

- [ ] DFS&BFS思想~
  - [ ] 这个用得很深的题很多鸭 感觉还是只掌握了皮毛
- [x] 基本的递归操作
- [ ] 回溯思想的运用
- [x] 二叉搜索树
  - [x] 简单的查找、插入操作
  - [ ] 二叉搜索树的删除-这个有一丢丢麻烦的说
- [ ] 平衡二叉树
- [ ] 简单的堆问题-堆的建立&堆排序

## 【1】二叉树递归

> 感觉二叉树的简单**递归**是有很多有趣的模板的~
>
> - 遍历
>   - 计算深度
>   - 单纯遍历
>     - 二叉树的经典 前、中、[后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)（同理的）
> - 对节点进行操作
>   - 插入
>   - 交换顺序
> - 比较两个二叉树
>   - [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)







## 【2】N叉树递归









## 【3】二叉树迭代





































# 05 栈与队列

- [x] 经典：用栈实现队列
- [x] 辅助栈的思想（关键是是理解栈这个数据结构入栈、出栈的规则并灵活使用）
  - [x] 经典-有效的括号
  - [x] 递归调用栈的思想
- [ ] 单调栈（很多难题的解决方案）
- [ ] 一些骚操作待学习…



### 【1】栈的设计

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

![image-20211101120800306](https://gitee.com/su-fangzhou/blog-image/raw/master/202111011208422.png)

其实这题主要难点在于获取栈中最小值的功能实现，这一点上我们可以优化~

所以我们使用两个方案解决这个问题~

##### 一趟遍历法（O(N)的时间复杂度）

最好想的点——一趟遍历法

```js
// 初始化栈结构
var MinStack = function() {
    this.stack = [];
};
// 入栈操作
MinStack.prototype.push = function(val) {
    this.stack.push(val);
};

// 出栈操作
MinStack.prototype.pop = function() {
    this.stack.pop();
};

// 获取栈顶元素
MinStack.prototype.top = function() {
    if(this.stack === null || this.stack.length === 0){
        // 熟练地完成边界条件判断可能不是必要地，但在不少时候可能会救你一命XD
        return;
    }
    return this.stack[this.stack.length - 1];
};

// 获取栈中最小值
MinStack.prototype.getMin = function() {
    const {stack} = this;// 小秀一手解构赋值
    let min = stack[0];
    for(let i = 1; i < stack.length; i++){
        min = stack[i] > min ? min : stack[i];
    }
    return min;
};
```



##### 辅助栈法（O(1)的时间复杂度）

经典空间换时间哈~

这里使用的辅助栈下面`739.每日温度`也会用到！

==单调栈==——创建一个单调栈用于辅助，栈顶元素为最小，最后getMin的时候直接对辅助栈出栈即可~

```js
// 初始化栈结构
var MinStack = function() {
    this.stack = [];
    this.stack2 = [];// 辅助栈
};
// 入栈操作
MinStack.prototype.push = function(val) {
    this.stack.push(val);
    // 本方法的关键——如何维护辅助栈！
        // 当辅助栈为空时入栈val & val比辅助栈栈顶元素小时入栈
    if(this.stack2.length === 0 || val <= this.stack2[this.stack2.length - 1]){
        this.stack2.push(val);
    }
};

// 出栈操作
MinStack.prototype.pop = function() {
    if(this.stack.pop() === this.stack2[this.stack2.length - 1]){
        // 若出栈元素和目前辅助栈栈顶元素相同则将其从辅助栈出栈
        this.stack2.pop();
    }
};

// 获取栈顶元素
// 这里没变化~
MinStack.prototype.top = function() {
    if(this.stack === null || this.stack.length === 0){
        // 熟练地完成边界条件判断可能不是必要地，但在不少时候可能会救你一命XD
        return;
    }
    return this.stack[this.stack.length - 1];
};

// 获取栈中最小值
MinStack.prototype.getMin = function() {
    return this.stack2[this.stack2.length - 1];// 直接取栈顶元素即可！
};// 初始化栈结构
var MinStack = function() {
    this.stack = [];
    this.stack2 = [];// 辅助栈
};
// 入栈操作
MinStack.prototype.push = function(val) {
    this.stack.push(val);
    // 本方法的关键——如何维护辅助栈！
        // 当辅助栈为空时入栈val & val比辅助栈栈顶元素小时入栈
    if(this.stack2.length === 0 || val <= this.stack2[this.stack2.length - 1]){
        this.stack2.push(val);
    }
};

// 出栈操作
MinStack.prototype.pop = function() {
    if(this.stack.pop() === this.stack2[this.stack2.length - 1]){
        // 若出栈元素和目前辅助栈栈顶元素相同则将其从辅助栈出栈
        this.stack2.pop();
    }
};

// 获取栈顶元素
// 这里没变化~
MinStack.prototype.top = function() {
    if(this.stack === null || this.stack.length === 0){
        // 熟练地完成边界条件判断可能不是必要地，但在不少时候可能会救你一命XD
        return;
    }
    return this.stack[this.stack.length - 1];
};

// 获取栈中最小值
MinStack.prototype.getMin = function() {
    return this.stack2[this.stack2.length - 1];// 直接取栈顶元素即可！
};
```



#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)



### 【2】使用到栈的经典题型

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

很经典(且面试高频)的题！重点是要联想到**使用栈辅助**解题！

```js
var isValid = function(s) {
    // 利用Map对象创建哈希表~
    const map = new Map([        
        ["(",")"],
        ["{","}"],
        ["[","]"]
    ])

    let stack = [];
    // 遍历fi'fu'c并 对栈进行填充 + 将没资格入栈的元素与栈顶元素比较（别忘了出栈~）
    for(let str of s){
        if(map.has(str)){
            stack.push(str);
        }
        else{
            if(map.get(stack.pop()) !== str){
                return false;
            }
        }
    }
    return !stack.length;
    // 只要栈里没有元素了 可以返回true，
    // 但别忘了如果栈中还有元素说明右侧的括号并没有成功匹配哦！
};
```



#### [【medium】739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

![image-20211028220101210](https://gitee.com/su-fangzhou/blog-image/raw/master/202110282201314.png)

> 本题可以用暴力两层循环去写，但是这样写会造成重复操作
>
> **栈结构可以帮我们避免重复操作**。
>
> > 及时将**不必要的数据出栈**，避免它对我们后续的遍历产生干扰即可！

- **单调栈**的思想！单调栈的特点如下：
  - 存储下标
  - 从栈底到栈顶的下标对应着的温度依次**降低**！
    - 一旦出现一个不符合这个规律的（`temperatures[i] > temperatures[stack[stack.length - 1]]`）就将下标出栈并得到答案！

```js
// 入参是温度数组
const dailyTemperatures = function(T) {
    const len = T.length // 缓存数组的长度 
    const stack = [] // 初始化一个栈   
    const res = (new Array(len)).fill(0) //  初始化结果数组，注意数组定长，占位为0
    for(let i=0;i<len;i++) {
      // 若栈不为0，且存在打破递减趋势的温度值
      while(stack.length && T[i] > T[stack[stack.length-1]]) {
        // 将栈顶温度值对应的索引出栈
        const top = stack.pop()  
        // 计算 当前栈顶温度值与第一个高于它的温度值 的索引差值
        res[top] = i - top 
      }
      // 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算
      stack.push(i)
    }
    // 返回结果数组
    return res 
};
```







### 【3】使用栈实现队列

#### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

- 入队
- 出队（如果无法出队 则返回-1）

> 本题为面试高频题目，务必很熟练！
>
> 而且在很多题目中需要用到辅助栈的思路，请掌握！

栈的方法没法实现队列的需求？

没关系！用辅助栈！

```js
// 初始化两个辅助栈
var CQueue = function() {
    this.stack1 = [];
    this.stack2 = [];
};

// 在队列尾部添加数据 
CQueue.prototype.appendTail = function(value) {
    this.stack1.push(value);
};

// 删除队列头部数据
CQueue.prototype.deleteHead = function() {
    if(this.stack2.length === 0){
        while(this.stack1.length !== 0){
            this.stack2.push(this.stack1.pop());
        }
    }
    // 将stack1中内容移到stack2中之后，如果stack2中再没有（说明stack1也是空的，没有值被移到stack2）就不对了！
    if(this.stack2.length === 0){
        return -1;
    }
    else{
        return this.stack2.pop();
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */
```

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 入队
- 出队
- 返回队头
- 判断队列是否为空



因为栈是先进后出

队列是先进先出

所以想只用栈的入栈、出栈方法来实现队列，必须要使用两个栈按照一定规则将元素插入、弹出

![image-20211210133938910](https://gitee.com/su-fangzhou/blog-image/raw/master/202112101339025.png)



举个例子，把这个过程想象成银行叫号

用A B两个“罐子”（也就是两个栈）模拟银行叫号的“先排队的先办业务”

这个过程如下所示：

【1】push方法发给每个人一个取号牌，拿到取号牌的人就放到A罐中

![image-20211210135405001](https://gitee.com/su-fangzhou/blog-image/raw/master/202112101354094.png)

【2】`MyQueue.prototype.pop`方法就好比叫号，怎么根据栈的pop方法来让1号牌子出栈呢，人家是第一个排队的嘛

那么我们就要用到B罐子——调用pop方法时，把A罐子中的所有牌子依次出栈放到B中

```js
while(this.stack1.length !== 0) {
    this.stack2.push(this.stack1.pop())
}
return stack2.pop()
```



![image-20211210134729729](https://gitee.com/su-fangzhou/blog-image/raw/master/202112101347804.png)

【3】这里要注意，并不是每一次pop操作都要把A罐子中的内容放到B中！

B罐子中都是正在排队的老用户，A罐子的新人怎么能插队呢！

所以只有B罐子（stack2）中为空时，才会把A罐子中的等号牌放进B罐子中

```js
if(this.stack2.length === 0) {
    while(this.stack1.length !== 0) {
        this.stack2.push(this.stack1.pop())
    }
}
```

![image-20211210134907506](https://gitee.com/su-fangzhou/blog-image/raw/master/202112101349582.png)

【4】简单总结下

此类辅助栈的思想在很多题型中都可以用得到，一定要很熟悉栈这个数据结构！

```js
var MyQueue = function() {
    this.stack1 = []
    this.stack2 = []
};
// 入队
MyQueue.prototype.push = function(x) {
    this.stack1.push(x)
};  
// 出队
MyQueue.prototype.pop = function() {
    if(this.stack2.length === 0) {
        while(this.stack1.length !== 0) {
            this.stack2.push(this.stack1.pop())
        }
    }
    return this.stack2.pop()
};
// 查看队头 元素
MyQueue.prototype.peek = function() {
    // 复用上面的pop方法 先把队头元素弹出 再把它放进去，位置不会变~
    let first = this.pop()
    this.stack2.push(first)
    return top
};
// 判断队列是否为空
MyQueue.prototype.empty = function() {
    return !this.stack2.length && !this.stack1.length
};
```



### 【4】双端队列用途

- 可用于检查回文字符串

先添加到双端队列（用数组模拟即可）中

再用依次比对(其实与双指针同理，只不过这个看起来更有数据结构的思维hh)

> 顺带着还练了下字符串的操作XD

```js
var isPalindrome = function(s) {
    let queue = []
    s = s.toLowerCase()
    // 获取符合要求的队列
    for(let str of s) {
        if(!isValid(str)) continue
        queue.push(isValid(str))
    }
    // 使用双端队列j
    while(queue.length > 1) {
        if(queue.shift() !== queue.pop()) {
            return false
        }
    }
    return true
};
// 去除 小写字母&数字 以外的字符
function isValid(s) {
    if((s >= 'a' && s <= 'z') || (s >= '0' && s <= '9')) {
        return s
    }
}
```



- 双端队列衍生出的滑窗问题

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 

和 主站的 [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)一样

借鉴的[修言大佬的思路](https://juejin.cn/book/6844733800300150797/section/6844733800358871054)~

```js
const maxSlidingWindow = function (nums, k) {
  // 缓存数组的长度
  const len = nums.length;
  // 初始化结果数组
  const res = [];
  // 初始化双端队列
  const deque = [];
  // 开始遍历数组
  for (let i = 0; i < len; i++) {
    // 当队尾元素小于当前元素时
    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
      // 将队尾元素（索引）不断出队，直至队尾元素大于等于当前元素
      deque.pop();
    }
    // 入队当前元素索引（注意是索引）
    deque.push(i);
    // 当队头元素的索引已经被排除在滑动窗口之外时
    while (deque.length && deque[0] <= i - k) {
      // 将队头元素索引出队
      deque.shift();
    }
    // 判断滑动窗口的状态，只有在被遍历的元素个数大于 k 的时候，才更新结果数组
    if (i >= k - 1) {
      res.push(nums[deque[0]]);
    }
  }
  // 返回结果数组
  return res;
};
```

自己理解了一下~

```js
var maxSlidingWindow = function(nums, k) {
    // 将暴力双重循环O(n*k)变为O(n) 在窗口发生移动时，只根据发生变化的元素对最大值进行更新
    // 达到这个效果的核心方法是使用递减队列（目的：确保队头元素始终是当前窗口的最大值）
    // 随着滑窗前进，不断检查被抛弃的那个数是不是最大值-如果是（和当前队头比较即可）则出队，不是就不用管
    // 另外别忘了特值-保证遍历到的元素个数是大于滑动窗口长度的（考虑要全面哦~）
    const len = nums.length;
    const res = [];
    const deque = [];// 本题关键-维护双端队列
    for(let i = 0; i < len; i++){
        // 双端队列中有元素 且 队尾元素小于当前元素的话，不符合递减队列，出队~一直出队到碰到比当前元素大的！
        while(deque.length && nums[deque[deque.length - 1]] < nums[i]){
            deque.pop();
        }
        // 当前元素是最大/仅次于最大的那个了~，入队当前元素的索引(回头在滑窗滑过它的时候需要把它出队！通过索引判断~)
        deque.push(i);
        // 队头元素的索引已经被排除在滑窗之外时，把它出队(从队头)，新王准备登基
        if(deque.length && deque[0] <= i - k){
            deque.shift();
        }
        if(i >= k - 1){
            // 特殊情况的判断-保证遍历到的元素个数是大于滑动窗口长度的
            res.push(nums[deque[0]]);
        }
    }
    return res;
};
```

回头刷剑指的时候我们还会再见面的~



# 06 设计题

## 【1】数组相关

#### [384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

> medium

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:

```
Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
```

- 随机选数+及时删除

```js
var Solution = function(nums) {
    this.nums = nums
    this.copy = nums.slice()
};

Solution.prototype.reset = function() {
    this.nums = this.copy.slice()
    return this.nums
};

Solution.prototype.shuffle = function() {
    let list = []
    let shuffled = new Array(this.nums.length).fill(0)
    let list = this.copy.slice()// 复制一个原数组的副本下来 边随机插入结果数组shuffled 边进行删除
    for(let i = 0; i < this.nums.length; i++){
        let len = list.length
        let index = Math.random()*len
        shuffled[i] = list[Math.floor(index)]
        list.splice(index, 1)
    }
    this.nums = shuffled.slice()
    return this.nums
};
// 下面是官方的暴力解 但是效率奇低 不知道为啥。。
// var Solution = function(nums) {
//     this.nums = nums
//     this.copy = nums.slice()
// };

// Solution.prototype.reset = function() {
//     this.nums = this.copy.slice()
//     return this.nums
// };

// Solution.prototype.shuffle = function() {
//     let shuffled = new Array(this.nums.length).fill(0)
//     let list = this.nums.slice()
//     for(let i = 0; i < this.nums.length; i++){
//         let index = Math.random()*list.length
//         console.log(index)
//         shuffled[i] = list.splice(index, 1)[0];
//     }
//     this.nums = shuffled.slice()
//     return this.nums
// };
```



- **Fisher–Yates shuffle 洗牌算法**

> 非常有趣的思路与解法！
>
> 是解决随机打乱问题的最优方法！

【1】**先从数组末尾开始，选取最后一个元素，与数组中随机一个位置的元素交换位置**

【2】**然后在已经排好的最后一个元素以外的位置中，随机产生一个位置，让该位置元素与倒数第二个元素进行交换**

以此类推，打乱整个数组的顺序

```js
var Solution = function(nums) {
    this.nums = nums;
    this.original = this.nums.slice();
};

Solution.prototype.reset = function() {
    this.nums = this.original.slice();
    return this.nums;
};

Solution.prototype.shuffle = function() {
    for (let i = 0; i < this.nums.length; ++i) {
        const j = Math.floor(Math.random() * (this.nums.length - i)) + i;
        const temp = this.nums[i];
        this.nums[i] = this.nums[j];
        this.nums[j] = temp;
    }
    return this.nums;
};
```

#### [519. 随机翻转矩阵](https://leetcode-cn.com/problems/random-flip-matrix/)

> medium

> 很不错的设计题！二维矩阵一定要用二位数组来表示麽？不一定！要根据题目给出的数据用例来判断所用的数据结构 一维数组也可以很好地模拟二维数组的一些行为 比如本题中的操作！

![image-20211127090701725](https://gitee.com/su-fangzhou/blog-image/raw/master/202111270907859.png)

![image-20211127090711320](https://gitee.com/su-fangzhou/blog-image/raw/master/202111270907397.png)

- 数组映射的巧妙方法

虽然不是最优解，但是比较简单易懂~

```js
var Solution = function(m, n) {
    this.m = m
    this.n = n
    this.total = m * n
    this.map = new Map()
};

Solution.prototype.flip = function() {
    const x = Math.floor(Math.random() * this.total);
    this.total--
    // 如果这个x是之前出现过的 那麽就从哈希表中获取对应的映射——保证随机性~
    const idx = this.map.get(x) || x
    // x出现过一次则建立映射到末尾位置，下一次再出现的时候就可以直接拿末尾那个数了~
    this.map.set(x, this.map.get(this.total) || this.total)
    // 因为是一维矩阵 所以用idx这个随机数（从m*n个格子中选取一个值 它在表格中的Math.floor(idx / this.n)行，idx % this.n列）来表示要取的下标
    return [Math.floor(idx / this.n), idx % this.n]
};

Solution.prototype.reset = function() {
    // 将格子数量total重置，将哈希表清空
    this.total = this.m * this.n
    this.map.clear()
};

/**
 * Your Solution object will be instantiated and called as such:
 * var obj = new Solution(m, n)
 * var param_1 = obj.flip()
 * obj.reset()
 */
```

## 【2】栈、队列相关

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

- 入队
- 出队
- 返回队头
- 判断队列是否为空

```js
var MyQueue = function() {
    this.stack1 = []
    this.stack2 = []
};
// 入队
MyQueue.prototype.push = function(x) {
    this.stack1.push(x)
};  
// 出队
MyQueue.prototype.pop = function() {
    if(this.stack2.length === 0) {
        while(this.stack1.length !== 0) {
            this.stack2.push(this.stack1.pop())
        }
    }
    return this.stack2.pop()
};
// 查看队头 元素
MyQueue.prototype.peek = function() {
    // 复用上面的pop方法 先把队头元素弹出 再把它放进去，位置不会变~
    let first = this.pop()
    this.stack2.push(first)
    return top
};
// 判断队列是否为空
MyQueue.prototype.empty = function() {
    return !this.stack2.length && !this.stack1.length
};
```





# 解题技巧

# 01 双指针

- [x] 同向而行快慢指针（常用于链表）
- [x] 反向而行双指针（对撞指针，常用于数组）

## 【1】链表中的双指针

【medium】[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

【easy】[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

【medium】[92.反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)



## 【2】数组中的双指针-求和、比大小

> 前提为：数组有序——以便双指针帮助我们缩小定位的范围。
>

【easy】[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

【medium】[15. 三数之和](https://leetcode-cn.com/problems/3sum/)



# 02 哈希表

















# 03 递归

- [x] 递归的基本原理  [掌握递归调用栈思想 由浅入深研究递归🎉](https://juejin.cn/post/7016324095843237901)
- [x] 树的前中后序遍历
- [ ] 数组、链表等题目中的递归骚操作





# 04 DFS BFS

## 【1】DFS 深度优先搜索

> 之前写的专题记录[深度优先搜索 leetcode104 101 112 543 129 五道题小练一下深度优先遍历搜索算法 java刷题笔记](https://blog.csdn.net/qq_45704942/article/details/117712490)

> 一句话理解DFS：走迷宫，不撞南墙不回头，撞了南墙回到上一个节点再次去撞南墙（取决于有几个岔路口），撞遍当前节点的南墙再往回退一个节点（换个岔路口），以此类推…
>
> ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/17190aa8a73ba344~tplv-t2oaga2asx-watermark.awebp)
>
> 本质为栈结构
>
> - 搜索过程中的前进、后退操作与栈结构的入栈、出栈过程很相似！

### 二叉树中的DFS

还是根据上例来说，我们使用递归编程解决这个问题——**递归式就是我们选择道路的过程，而递归边界就是“南墙”**

在二叉树中

- 节点就好比是迷宫里的坐标
- 图中的每个节点在作为父节点时无疑是岔路口
- 空节点就是“南墙”。

比如二叉树的前序遍历就是一个策略明显（先撞左侧的南墙，撞穿勒左侧再去撞右侧，然后再回到前一个节点…）的DFS的过程——空节点就是这个问题里的“南墙”，

也可以说 **先序遍历是DFS思想的递归实现**，后面我们接触的很多题都可以用DFS思想来递归实现！（不撞南墙不回头~）

来看看代码——

```js
function preorder(root){
    if(root === null){
        return;// 边界条件——“南墙”
    }
    console.log(root);
    preorder(root.left);
    preorder(root.right);    
}
```

### 为什么说DFS的本质是栈？

我的理解：DFS的实现与栈的原理类似（一般都用递归来快速模拟深度优先搜索的过程，而递归的原理就是“函数调用**栈**”）

> [修言大大的理解](https://juejin.cn/book/6844733800300150797/section/6844733800358887438)（本知识库中好多思想都是从修言大大的这本掘金小册学来的！真的很受用！）
>
> - 首先，函数调用的底层，仍然是由栈来实现的。JS 会维护一个叫“函数调用栈”的东西（类似的思想我写过一篇文章  [掌握递归调用栈思想 由浅入深研究递归🎉](https://juejin.cn/post/7016324095843237901) 就是说这个递归调用栈的~），`preorder`每调用一次自己，相关调用的上下文就会被`push`进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被`pop`出来。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。
> - 其次，DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号——DFS 的解题场景其实有很多，其中有一类会要求我们记录每一层递归式里路径的状态，此时就会强依赖栈结构（这一点会在下一节的真题实战中体现得淋漓尽致）。



## 【2】BFS广度优先搜索

> 之前写的专题记录 
>
> [广度优先搜索 刷熟一个模板（层序遍历打印二叉树）秒杀一堆问题leetcode102 111 116 617 java刷题笔记](https://blog.csdn.net/qq_45704942/article/details/117884207)

DFS的实现与栈的原理类似

而BFS的实现与**队列**密不可分，做一道贼经典的题就知道了

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

我们要做的是对这个二叉树进行层序遍历。

**层序遍历**的概念很好理解：按照层次的顺序，从上到下，从左到右地遍历一个二叉树，如图所示（红色数字即为遍历的序号）：

> 欸嘿！这不就是我们的BFS广度优先搜索麽！

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/19/1719130c81086dbb~tplv-t2oaga2asx-watermark.awebp)

- 效率有点低 但是好想的方法~每一层都有个辅助数组temp

```js
var levelOrder = function(root) {
    let res = [];
    if(root === null){
        return res;
    }
    const queue = [];// 用队列辅助进行二叉树的广度搜索
    queue.push(root);
    while(queue.length){
        console.log(queue);
        let temp = [];// 存这一层的节点
        let currentL = queue.length;// 存当前这一层有几个节点~
        for(let i = 0; i < currentL; i++){
            // 将这一层的所有节点广度搜索一遍，并顺带着探索一下每个节点的下一层有没有节点，如果有则加入到队列中
            let node = queue.shift();
            temp.push(node.val);// 将每一次for循环遍历得到的节点值加入临时数组temp中
            if(node.left !== null) queue.push(node.left);
            if(node.right !== null) queue.push(node.right);
        }
        res.push(temp);// 将一层的节点值加入到答案数组中
    }
    return res;
};
```

- 高效官方题解——就改了一处想法（如注释）但是效率一下子起来了！太优秀勒！

```js
var levelOrder = function(root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [];
    q.push(root);
    while (q.length !== 0) {
        const currentLevelSize = q.length;
        ret.push([]);// 二维数组中添加一个一位数组来存这一层的节点值
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift();
            ret[ret.length - 1].push(node.val);// 依次将节点值加入到队列末尾的那个数组（代表着当前层）中
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return ret;
};
```



# 05 回溯

- 回溯算法的基本思想

> 从一条路往前走，能进则进，不能进则退回来，换一条路再试。——leetcode

> 这里的“回溯”二字，可以理解为是在强调上面提到的 `DFS` 过程中“退一步重新选择”这个动作。这样想的话， `DFS` 算法其实就是回溯思想的体现。  

> 涉及剪枝操作的递归，我们一般称之为回溯。——某算法书籍

> 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种**走不通就退回再走的技术**为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。
> 许多复杂的，规模较大的问题都可以使用回溯法，有“**通用解题方法**”的美称。——前端算法与数据结构面试

## 【1】解题模板

### 什么时候用回溯算法？

- 题目中暗示了一个/多个解，要求我们列出来每一个解的 **具体内容**
- 冷静分析下，可以转化为 **树形逻辑模型求解** 

### 为什么用回溯算法？

- 递归与回溯的过程，本身就是 **穷举** 的过程
  - 如果题目要求我们把每一个解都列举出来，那么自然就需要 **穷举**
- 穷举所有可能性时，对构建出来的搜索树进行恰当的剪枝（具体过程可以看下面题目的题解）

> 不让列举出解的所有情况，只问解的个数。
>
> 用动态规划。这可是个老大难问题！
>
> - 背包问题
> - 跑楼梯问题
> - …

### 怎么用回溯算法？

- 分析问题要关注**一个模型**
  - 树形逻辑模型
    - 要能想出来这个模型
    - 要会找树形模型中的 **坑位**
      - 一个坑位对应树中的一层
      - 每一层的处理逻辑（递归式的内容）一般都是一样的
- 写代码要关注**两个要点**（所有递归问题都是关注这俩玩意儿）
  - 递归式
    - 树形逻辑模型每一层的处理逻辑即为递归式
  - 递归边界
    - 即为题目“每个答案的要求” / “坑位数量的边界”

伪代码总结下编码形式（这部分内容只是一个简单**模板**，具体情况还要结合题意（和根据题意分析出来的树形逻辑结构）来分析）——

```js
const 具体问题 = function(入参){
    定义辅助数组，缓存后面题目要用到的变量（数组长度啥的）
    const path = [];// 定义路径栈——回溯思想中最重要的辅助
    const res = [];// 结果数组，把path中的内容加入到res中，往往使用res.push(path.slice())
    function dfs(递归参数){
        if(达到递归边界){
       		处理边界逻辑，往往和path内容有关/向结果数组res中加入内容
           	return;
        }
        // 
        for(遍历“坑位”的可选值){
            path.push(当前遍历到这个坑位的值);
        	处理坑位本身的相关逻辑
            path.pop();
        }
    }
	dfs(回溯起点);	

}
```



## 【2】递归回溯经典题目

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

回溯法解题

![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-watermark.awebp)

```js
const permute = function(nums) {
  // 缓存数组的长度
  const len = nums.length
  // curr 变量用来记录当前的排列内容
  const curr = []
  // res 用来记录所有的排列顺序
  const res = []
  // visited 用来避免重复使用同一个数字
  const visited = {}
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs(nth) {
      // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回
      if(nth === len) {
          // 此时前 len 个坑位已经填满，将对应的排列记录下来
          res.push(curr.slice())
          return 
      }
      // 检查手里剩下的数字有哪些
      for(let i=0;i<len;i++) {
          // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
          if(!visited[nums[i]]) {
              // 给 nums[i] 打个“已用过”的标
              visited[nums[i]] = 1
              // 将nums[i]推入当前排列
              curr.push(nums[i])
              // 基于这个排列继续往下一个坑走去
              dfs(nth+1) 
              // nums[i]让出当前坑位
              curr.pop()
              // 下掉“已用过”标识
              visited[nums[i]] = 0
          }
      }
  }
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0)
  return res
};
```



#### [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

回溯法解题

![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-watermark.awebp)

```js
// 入参是一个数组
const subsets = function(nums) {
    // 初始化结果数组
    const res = []   
    // 缓存数组长度
    const len = nums.length
    // 初始化组合数组
    const subset = []
    // 进入 dfs
    dfs(0)  

    // 定义 dfs 函数，入参是 nums 中的数字索引
    function dfs(index) {
        // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
        res.push(subset.slice())
        // 从当前数字的索引开始，遍历 nums
        for(let i=index;i<len;i++) {
            // 这是当前数字存在于组合中的情况
            subset.push(nums[i]) 
            // 基于当前数字存在于组合中的情况，进一步 dfs
            dfs(i+1)
            // 这是当前数字不存在与组合中的情况
            subset.pop()
        }
    }
    // 返回结果数组
    return res 
};
```



#### [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

对搜索树进行剪枝，答案为红箭头串联起来的内容

![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-watermark.awebp)

```js
const combine = function(n, k) {
   // 初始化结果数组
    const res = []   
    // 初始化组合数组
    const subset = []
    // 进入 dfs，起始数字是1
    dfs(1)  

    // 定义 dfs 函数，入参是当前遍历到的数字
    function dfs(index) {
        if(subset.length === k) {
            res.push(subset.slice())
            return 
        }
        // 从当前数字的值开始，遍历 index-n 之间的所有数字
        for(let i=index;i<=n;i++) {
            // 这是当前数字存在于组合中的情况
            subset.push(i) 
            // 基于当前数字存在于组合中的情况，进一步 dfs
            dfs(i+1)
            // 这是当前数字不存在与组合中的情况
            subset.pop()
        }
    }
    // 返回结果数组
    return res 
};
```



# 06 排序问题

- 基础排序算法：
  - 冒泡排序
  - 插入排序
  - 选择排序
- 进阶排序算法
  - 归并排序
  - 快速排序



# 07 动态规划

### 经典动归问题

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

很好的一篇题解，把思想说得蛮清楚

[经典动态规划问题（理解「无后效性」）](https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/)

# 08 前缀和



# 09 位运算

## 【1】位运算基础知识

### 按位**与** a & b

【1】a b转换为二进制【2】进行按位运算 “且”的规则

```js
0&0=0; 
0&1=0;
1&0=0;  
1&1=1;
```

- 利用这个特性可以快速判断一个数字是否为奇数（最后一个二进制是否为1）

```js
(5 & 1) === 1;// true
(4 & 1) === 1;// false
```

### 按位**或** a | b

【1】a b转换为二进制【2】进行按位运算  “或”的规则

```js
0|0=0;
0|1=1;
1|0=1;
1|1=1;
```

### **异或**  a ^ b

很有用的运算符!! 【1】a b转换为二进制【2】进行按位运算  “相同的数异或得0 任何数与0异或等于本身”的规则

```js
// 二进制
0^0=0 1^1=0
0^1=1 1^0=1
// 十进制
6 ^ 6 = 0
0 ^ 666 = 666
```

- 两个经典用法

  - 找出没有重复得数（一组数，都是成对的，只有一个落单的）进行全部异或运算最终结果即为落单那个数

    ```js
    1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5// 异或支持交换律和结合律~
    ```

  - 不使用额外得辅助变量 交换两个数x y的位置

    ```js
    x = x ^ y;
    y = x ^ y;
    x = x ^ y;
    ```

### 短路运算符 逻辑与 a && b

- a 和 b都为真 才返回true

- 进行位运算时

```js
0 && 6 = 0;// 发生短路（有一个结果为假）
6 && 8 = 8;
8 && 6 = 6;
6 && 7 && 8 = 8;// 两个都为true才不会发生短路 返回最后一个值
```

- 优先级比||高

```js
3 || 2 && 5 || 0 = 3
// 先计算 2&&5=5 然后计算 3||5=3 最后得到 3||0=3 
```



### 短路运算符 逻辑或 a || b

- a与b有一个为真 返回true
- 进行位运算时

```js
0 || 0 = 0;// 结果为假时，返回第二个为假的值0
6 || 4 = 6;
4 || 6 = 4;// 结果为真时，返回第一个为真的值 
6 || 0 = 6;// 因为是短路，所以前面出现一个true，不看后面直接停止
```

- 项目开发时，经常对一个数据进行逻辑或运算避免其报错 `let obj = xxx || {}`

## 【2】位运算经典应用

### 找出排序数组中只出现一次的数字&延伸题目

#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 同[剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/) 一样
>
> 我的题解——[[JavaScript]异或、二分搜索（全体二分查找乱序数组&偶数二分查找有序数组）注释齐全](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/javascriptyi-huo-er-fen-sou-suo-quan-ti-f6rzu/)

##### 异或快捷解决

> 540题中英文版有规定 ：Your solution must run in `O(log n)` time and `O(1)` space. 所以这个方法仅供了解
>
> 主要考察二分法！

```js
var singleNonDuplicate = function(nums) {
    let res;
    for(let i = 0; i < nums.length; i++){
        res ^= nums[i];
    }
    return res;
};
```

##### 再优化，二分法（面试重点）

> 这里的第一个关键点是先把四种情况列出来！
>
> 参考官方题解
>
> 例子 1：中间元素的同一元素在右边，且被 mid 分成两半的数组为偶数。
>
> 我们将右子数组的第一个元素移除后，则右子数组元素个数变成奇数，我们应将 lo 设置为 mid + 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/08f1ff0fa20c9963ae4f5aafb7c6317df713b5eb562064ba8b7644c1d773c626-file_1576478245275)
>
> 例子 2：中间元素的同一元素在右边，且被 mid 分成两半的数组为奇数。
>
> 我们将右子数组的第一个元素移除后，则右子数组的元素个数变为偶数，我们应将 hi 设置为 mid - 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/8481e9a41430c85977693dbad0d12de7df96a7064d13edd6eb359f7d8ccbcf99-file_1576478245283)
>
> 例子 3：中间元素的同一元素在左边，且被 mid 分成两半的数组为偶数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为奇数，我们应将 hi 设置为 mid - 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/186af681e3fced71c9588d9422accc7832062b24d33c343edecd9aef2e0c6ba1-file_1576478245286)
>
> 例子 4：中间元素的同一元素在左边，且被 mid 分成两半的数组为奇数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为偶数，我们应将 lo 设置为 mid + 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/067fab9a30b1b278da9e633de7b627931cdab5444d0f99e7142eb2907bff4431-file_1576478245290)



然后就常规二分法做就行了~注意分情况讨论的细则即可！

```js
var singleNonDuplicate = function(nums) {
    // 定义双指针
    let i = 0, j = nums.length - 1;
    while(i < j){
        // let mid = (i + j) >> 1;
        // 为了防止大数溢出 建议这么写
        let mid = i + (j - i >> 1)
        // 此方法的关键——判断哪边为奇数的变量 要设置好
        let isEven = (j - mid) % 2 == 0;
        // 如果j-mid为偶数 则去除中间两个值相同的元素并跳过它们之后，两指针（包括两指针）之间有奇数个元素，
        // 也就是单个的元素一定在这之间
        if(nums[mid] === nums[mid - 1]){
            if(isEven){
                // 在左边
                j = mid - 2;
            }
            else{
                i = mid + 1;
            }
        }
        else if(nums[mid] === nums[mid + 1]){
            if(isEven){
                // 在右边
                i = mid + 2;
            }
            else{
                console.log("last j",j)
                j = mid - 1;
            }
        }
        else{
            return nums[mid];
        }
    }
    return nums[i];
};
```

怎么说呢，双指针的题，多画图就完事了！

时间复杂度 O(logn)，相比于暴力循环（包括异或），每次迭代将搜索空间缩减了一半！

##### 进一步优化，仅对偶数索引进行二分搜索

最佳实践

```js
var singleNonDuplicate = function(nums) {
    let i = 0, j = nums.length - 1;// 数组长度必为奇数，所以一前一后两个元素下标为偶数
    while(i < j){
        let mid = i + ((j - i) >> 1);
        if(mid % 2 === 1){
            // mid为奇数则-1变为偶数 则mid现在必为“边缘” 不必再分四种情况来讨论
            // 这就是仅对偶数索引进行二分搜索！
            mid--;
        }
        if(nums[mid + 1] === nums[mid]){
            // 去除mid那一对数之后，左侧数必为偶数，右侧数必为奇数，继续去紧挨着那对数的右边1个找
            i = mid + 2;
        }
        else{
            // 去除mid那一对数之后，左侧数为奇数，右侧数必为偶数，继续去紧挨着那对数的左边1个找
            j = mid;// 此时mid已经在原基础上左移一位了 所以j直接放在mid这个位置即可
        }
    }
    return nums[i];
};
```

- 时间复杂度：O(log n/2) = O(log*n*)。我们仅对元素的一半进行二分搜索。

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

##### 位运算-分组异或

这个分组的方法就很灵性。

```js
var singleNumbers = function(nums) {
    let n = 0;
    // 01 n 为 两个单独数a b的乘积
    // 接下来(02中)使用与运算
        // 与运算特点 二进制中只有6&6 = 6 6&0 = 0&0 =0
    for(let num of nums){
        n ^= num;
    }
    // 02 m可以保证这个数组中单身的两个数a b中的一个可以不被它抵消掉 
    // 也就是 m&a = 0 m&b != 0
    let m = 1;
    while((n & m) === 0){
        // 只要n&m不为0 就一直让m左移，直到m可以抵消掉a与b中的一个
        m <<= 1;
    }
    // 03 接下来使用m把两个单独的数分在两堆 并分组
    let x = 0, y = 0;
    for(let num of nums){
        if((num & m) === 0){
            x ^= num;
        }
        else{
            y ^= num;
        }
    }
    return [x, y];
};
```

> 看不懂我这个解释（或者觉得太大白话） 可以看看 [K神的题解](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)

# 10.滑动窗口



## 经典题目

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

![image-20211128220400103](https://gitee.com/su-fangzhou/blog-image/raw/master/202111282204196.png)

> 非常棒的一题
>
> - 很明显的（第一次做完全没看出来，惭愧！）滑动窗口的思想
> - 利用一维数组模拟哈希表（之前我一看见哈希表二话不说直接new Map()…）

来看个图 很清晰了就 [来源](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/tong-ge-lai-shua-ti-la-hua-dong-chuang-k-xgkv/)

![image-20211128090548278](https://pic.leetcode-cn.com/1638063958-WzvElV-file_1638063958629)

注释齐全，这个方法是最最基础的固定窗口大小的滑动窗口，再困难一些的有窗口大小变动的[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)，嗯是个hard🥺

```js
var findAnagrams = function(s, p) {
    // 在滑动窗口中维护每种字母的数量（通过哈希表，注意哈希表不一定用Map数据结构哈，一维数组也ok 如本题经典的26个坑的哈希表——数组索引即为“键”，对应数组值即为“值”）
    const sLen = s.length, pLen = p.length;
    if(sLen < pLen) {
        return [];// 这个判空一下子没想到XD
    }
    const ans = [];
    // 一维哈希表初始化下,初始化值为0
    const hashS = new Array(26).fill(0);
    const hashP = new Array(26).fill(0);
    // 01 先建立起第一个窗口，顺便将hashP这个哈希表建立好
    for(let i = 0; i < pLen; i++) {
        hashS[s[i].charCodeAt() - 'a'.charCodeAt()]++;
        hashP[p[i].charCodeAt() - 'a'.charCodeAt()]++;
    }
    if(hashS.toString() === hashP.toString()) {
        ans.push(0)
    }
    // 02 将滑窗往后推，每轮推动将滑窗第一个位置的元素值-1，将滑窗末端下一个位置的元素值+1
    for(let i = 0; i < sLen - pLen; i++) {
        // 滑动窗口的推动
        hashS[s[i].charCodeAt() - 'a'.charCodeAt()]--;
        hashS[s[i + pLen].charCodeAt() - 'a'.charCodeAt()]++;
        if(hashS.toString() === hashP.toString()) {
            ans.push(i + 1)
        }
    }
    return ans;
};
```

