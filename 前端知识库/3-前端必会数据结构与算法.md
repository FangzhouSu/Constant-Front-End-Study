> 面试必考的算法题 逐一攻破有套路！🧐



参考资料：

- [前端算法与数据结构面试：底层逻辑解读与大厂真题训练](https://juejin.cn/book/6844733800300150797)
- [代码随想录](https://programmercarl.com/)
- [力扣题库](https://leetcode-cn.com/problemset/all/)

提纲：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/24/171ac6e4faf30ecf~tplv-t2oaga2asx-watermark.awebp)

> 应知应会
>
> - 堆、栈
> - 链表
> - 跳表、散列
> - 二叉、多叉树相关算法
> - 图相关算法
>
> 等~

# 基础数据结构

# 01 数组

## 【1】刷题必掌握的数组API

> 不求全背下来，有需求时来看一眼即可

> 回头要结合一些题目的操作，好好整理一下 21/10/16







## 【2】数组必会题目

[掘金文章链接（排版更好看一些~）](https://juejin.cn/post/7021090596135649311/)

单纯针对数组来考察的题目，总体来说，都不算太难——数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。

本部分记录那些“不那么难，但是面试中很高频且可以考验你数组掌握程度”的题目

- 不那么难，指的是这种题不需要用到困难的“解题技巧”，排序、二分思想、动态规划
- 面试中高频，字面意思，面试经常考嘛（虽说感觉前端er的面试中链表会问的比较多？）
- 考验数组掌握程度，这一点很重要，决定了面试官对你的看法——
  - 你是个不求甚解所有题目都暴力求解的选手
  - 还是会不断优化，充分利用数组API与一些简单技巧（例如双指针、哈希表）进行求解的选手？



#### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

`哈希表`

> 几乎所有求和问题，都可以转化为求差问题，不知道i如何优化？试着想想求差~
>

- 借助哈希表一趟遍历解题

  - 新建一个空对象模拟哈希表

  ```js
  var twoSum = function(nums, target) {
      let map = {};
      for(let i = 0; i < nums.length; i++){
          if(map[target - nums[i]] >= 0){
              return [map[target - nums[i]], i];
          }
          else{
              map[nums[i]] = i;
          }
      }
  };
  ```

  - 另外这题里面Map数据结构真不咋好使滴（这API完全没帮上忙，还不如原生写法😂)，还是直接创建一个对象，在对象里维护键值对儿吧~（也就是上面那个方法）

```js
var twoSum = function(nums, target){
    let map = new Map();
    for(let i = 0; i < nums.length; i++){
        if(map.get(target - nums[i]) >= 0){
            return [i, map.get(target - nums[i])]
        }
    	else{
            map.set(nums[i], i);
        }
    }
}
```





#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

`同向正序双指针，同向倒序双指针`

- 笨拙的暴力法

```js
// 纯属是为了提高数组相关API的熟练度XD，
// 面试时可以试着用下来展示自己对数组这个数据结构的熟悉？hh
var merge = function(nums1, m, nums2, n) {
    nums1.splice(m);
    for(let j = 0; j < n; j++){
        for(let i = 0; i < m + n; i++){
            if(nums2[j] <= nums1[i]){
                nums1.splice(i, 0, nums2[j]);
                break;
            }
            if(nums2[j] > Math.max(...nums1)){
                console.log(nums1)
                nums1.push(...nums2.slice(j)) 
                return nums1
            }
        }
    }
    // return nums1;// 如果走到这里 其实就不用return了哦
};
```

- 开辟新空间，常规同向双指针寻值

![img](https://assets.leetcode-cn.com/solution-static/88/1.gif)

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = 0, p2 = 0;
    let temp = [];
    while(p1 < m || p2 < n){
        // 如果nums1/nums2已经遍历完了，那么只能操作另外一个数组了~
        if(p1 === m){
            temp.push(nums2[p2++]);
        }
        else if(p2 === n){
            temp.push(nums1[p1++]);
        }
        // 较小的元素插入temp中（常规思路了这里~）
        else if(nums1[p1] < nums2[p2]){
            temp.push(nums1[p1++]);
        }
        else if(nums1[p1] >= nums2[p2]){
            temp.push(nums2[p2++]);
        }
    }
    for(let i = 0; i < m + n; i++){
        nums1[i] = temp[i];
    }
    // return nums1; // 题目就让把nums1修改下，没必要return了哈~核心代码模式就是爽XD
};
```

- 不必开辟新空间，巧妙逆向双指针！

ppt过程模拟[看这里](https://leetcode-cn.com/problems/merge-sorted-array/solution/88-by-ikaruga/)

面试能答出来这么个**倒序双指针**，不得起飞咯😎（好吧这其实是基操。）

```js
var merge = function(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1;
    let tail = m + n - 1;
    let cur;// 参考了官方题解，设置一个cur记录每次要去进行插入的值，更加清晰勒！
    while(p1 >= 0 || p2 >= 0){
        if(p1 === -1){
            cur = nums2[p2--]; 
        }
        else if(p2 === -1){
            cur = nums1[p1--]; 
        }
        else if(nums2[p2] > nums1[p1]){
            cur = nums2[p2--];
        }
        else if(nums2[p2] <= nums1[p1]){
            cur = nums1[p1--]; 
        }
        // 每次迭代找出应该挪到后面的元素
        nums1[tail--] = cur;
    }
};
```



#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

`反向对撞双指针`

核心方法：对撞（反向）双指针 + 定指针分别挪动 & 保证获得的三个数不能重复（使用特殊判断跳过重复的值）

这里写了个题解 [【JavaScript】对撞双指针 + 定指针 注释齐全](https://leetcode-cn.com/problems/3sum/solution/javascript-dui-zhuang-shuang-zhi-zhen-di-xbfk/)

## 【3】数组高频面试题

### 找出排序数组中只出现一次的数字&延伸题目

#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 同[剑指 Offer II 070. 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/) 一样
>
> 我的题解——[[JavaScript]异或、二分搜索（全体二分查找乱序数组&偶数二分查找有序数组）注释齐全](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/javascriptyi-huo-er-fen-sou-suo-quan-ti-f6rzu/)
>

##### 异或快捷解决

> 540题中英文版有规定 ：Your solution must run in `O(log n)` time and `O(1)` space. 所以这个方法仅供了解
>
> 主要考察二分法！

```js
var singleNonDuplicate = function(nums) {
    let res;
    for(let i = 0; i < nums.length; i++){
        res ^= nums[i];
    }
    return res;
};
```

##### 再优化，二分法（面试重点）

> 这里的第一个关键点是先把四种情况列出来！
>
> 参考官方题解
>
> 例子 1：中间元素的同一元素在右边，且被 mid 分成两半的数组为偶数。
>
> 我们将右子数组的第一个元素移除后，则右子数组元素个数变成奇数，我们应将 lo 设置为 mid + 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/08f1ff0fa20c9963ae4f5aafb7c6317df713b5eb562064ba8b7644c1d773c626-file_1576478245275)
>
> 例子 2：中间元素的同一元素在右边，且被 mid 分成两半的数组为奇数。
>
> 我们将右子数组的第一个元素移除后，则右子数组的元素个数变为偶数，我们应将 hi 设置为 mid - 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/8481e9a41430c85977693dbad0d12de7df96a7064d13edd6eb359f7d8ccbcf99-file_1576478245283)
>
> 例子 3：中间元素的同一元素在左边，且被 mid 分成两半的数组为偶数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为奇数，我们应将 hi 设置为 mid - 2。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/186af681e3fced71c9588d9422accc7832062b24d33c343edecd9aef2e0c6ba1-file_1576478245286)
>
> 例子 4：中间元素的同一元素在左边，且被 mid 分成两半的数组为奇数。
>
> 我们将左子数组的最后一个元素移除后，则左子数组的元素个数变为偶数，我们应将 lo 设置为 mid + 1。
>
> ![在这里插入图片描述](https://pic.leetcode-cn.com/067fab9a30b1b278da9e633de7b627931cdab5444d0f99e7142eb2907bff4431-file_1576478245290)



然后就常规二分法做就行了~注意分情况讨论的细则即可！

```js
var singleNonDuplicate = function(nums) {
    // 定义双指针
    let i = 0, j = nums.length - 1;
    while(i < j){
        // let mid = (i + j) >> 1;
        // 为了防止大数溢出 建议这么写
        let mid = i + (j - i >> 1)
        // 此方法的关键——判断哪边为奇数的变量 要设置好
        let isEven = (j - mid) % 2 == 0;
        // 如果j-mid为偶数 则去除中间两个值相同的元素并跳过它们之后，两指针（包括两指针）之间有奇数个元素，
        // 也就是单个的元素一定在这之间
        if(nums[mid] === nums[mid - 1]){
            if(isEven){
                // 在左边
                j = mid - 2;
            }
            else{
                i = mid + 1;
            }
        }
        else if(nums[mid] === nums[mid + 1]){
            if(isEven){
                // 在右边
                i = mid + 2;
            }
            else{
                console.log("last j",j)
                j = mid - 1;
            }
        }
        else{
            return nums[mid];
        }
    }
    return nums[i];
};
```

怎么说呢，双指针的题，多画图就完事了！

时间复杂度 O(logn)，相比于暴力循环（包括异或），每次迭代将搜索空间缩减了一半！

##### 进一步优化，仅对偶数索引进行二分搜索

最佳实践

```js
var singleNonDuplicate = function(nums) {
    let i = 0, j = nums.length - 1;// 数组长度必为奇数，所以一前一后两个元素下标为偶数
    while(i < j){
        let mid = i + ((j - i) >> 1);
        if(mid % 2 === 1){
            // mid为奇数则-1变为偶数 则mid现在必为“边缘” 不必再分四种情况来讨论
            // 这就是仅对偶数索引进行二分搜索！
            mid--;
        }
        if(nums[mid + 1] === nums[mid]){
            // 去除mid那一对数之后，左侧数必为偶数，右侧数必为奇数，继续去紧挨着那对数的右边1个找
            i = mid + 2;
        }
        else{
            // 去除mid那一对数之后，左侧数为奇数，右侧数必为偶数，继续去紧挨着那对数的左边1个找
            j = mid;// 此时mid已经在原基础上左移一位了 所以j直接放在mid这个位置即可
        }
    }
    return nums[i];
};
```

- 时间复杂度：O(log n/2) = O(log*n*)。我们仅对元素的一半进行二分搜索。

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

##### 位运算-分组异或

这个分组的方法就很灵性。

```js
var singleNumbers = function(nums) {
    let n = 0;
    // 01 n 为 两个单独数a b的乘积
    // 接下来(02中)使用与运算
        // 与运算特点 二进制中只有6&6 = 6 6&0 = 0&0 =0
    for(let num of nums){
        n ^= num;
    }
    // 02 m可以保证这个数组中单身的两个数a b中的一个可以不被它抵消掉 
    // 也就是 m&a = 0 m&b != 0
    let m = 1;
    while((n & m) === 0){
        // 只要n&m不为0 就一直让m左移，直到m可以抵消掉a与b中的一个
        m <<= 1;
    }
    // 03 接下来使用m把两个单独的数分在两堆 并分组
    let x = 0, y = 0;
    for(let num of nums){
        if((num & m) === 0){
            x ^= num;
        }
        else{
            y ^= num;
        }
    }
    return [x, y];
};
```

> 看不懂我这个解释（或者觉得太大白话） 可以看看 [K神的题解](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)



#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

同[剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)一样

##### 暴力哈希解

```js
var singleNumber = function(nums) {
    let map = new Map();
    for(let num of nums){
        if(map.get(num) > 0){
            let count = map.get(num);
            count++;
            map.set(num, count);
        }
        else{
            map.set(num, 1);
        }
    }
    for(let [num,count] of map.entries()){
        if(count === 1){
            return num;
        }
    }
};
```

[其他方法](https://leetcode-cn.com/problems/single-number-ii/solution/zhi-chu-xian-yi-ci-de-shu-zi-ii-by-leetc-23t6/)太恶心了 饶了我吧…我真不想做位运算了😢😢😢😢😢😢

# 02 字符串

## 【1】刷题必掌握的API

#### [`String.prototype.substring()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substring)

> **`substring() `**方法返回一个字符串在**开始索引到结束索引之间的一个子集**, 或从开始索引直到字符串的末尾的一个子集。
>
> ```js
> str.substring(indexStart[, indexEnd])
> ```
>
> - `indexStart`
>
>   需要截取的第一个字符的索引，该索引位置的字符作为返回的字符串的首字母。
>
> - `indexEnd`
>
>   可选。一个 0 到字符串长度之间的整数，**以该数字为索引的字符不包含在截取的字符串内**。

```js
var anyString = "bill";
// 输出"bil" 
console.log(anyString.substring(0,3));
// 下面这些神奇的用法同样可以输出索引 0 1 2 的字符
console.log(anyString.substring(3,0));
console.log(anyString.substring(3,-3));
console.log(anyString.substring(3,NaN));
console.log(anyString.substring(-2,3));
console.log(anyString.substring(NaN,3));
// 比较好用的一个取数技巧
var test = "xbill";
// 获取字符串bill 剔除前面的字符
test.substring(1);// "bill" 比较实用~
```



##  【2】字符串必会题型

> 字符串在算法面试中，单独考察的机会并不多，同样倾向于和一些经典算法（后面会讲的）结合来体现区分度。本节我们先解决只需要数据结构知识做基础就可以解决的字符串问题。
>
> 两个字符串相关的基本算法技能
>
> - 反转字符串
> - 判断是否为回文字符串
>
> 这两个技能偶尔也会单独命题，但整体来看在综合性题目中的考察频率较高，需要大家**着重熟悉、反复练习和记忆**，确保真正做题时万无一失。（链表的题里面这二位也是经典得不行勒！）



### 反转字符串

直接调用API即可（还有其他的方法，比较体现技巧，一些公司一面为了试水，有时会单独考这个操作）

```js
let str = "bytedance";
let res = str.split("").reverse().join("");// "ecnadetyb"
```

这里的核心主要是数组的API  `reverse()`

#### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

[代码随想录题解](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)

- 双指针

```js
var reverseString = function(s) {
    let i = 0, j = s.length - 1;
    while(i < j){
        [s[i], s[j]] = [s[j], s[i]];// 解构赋值快速交换两个数的位置~
        i++;
        j--;
    }
    // return s;这里的字符串没有被改变，依旧是原来的顺序，不理解的可以在下一题试一试，看看还能不能这么反转
    // 题目中每组[s[i],s[j]]的顺组改变了，最终返回一个反转好的字符数组
};
```



#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

与344的反转字符串容易搞混的点在于：

344中测试代码接收的结果为`[s[s.length-1],...s[1],s[0]]`——是一个字符数组 

而本题要求返回字符串，需要对数组&字符串的转换很熟悉！

```js
var reverseStr = function(s, k) {
    let loop = Math.ceil(s.length / (2*k));// 需要进行对撞双指针遍历的轮数loop
    let arr = s.split("");// 将字符串拆成数组，方便最后返回结果arr.join(""),不然交换元素不能改变字符串本身
    for(let m = 0; m < loop; m++){
        // 每轮双指针的位置如下：（也是本题的关键）
        let i = m*2*k;
        let j = (s.length - i) < k ? s.length - 1 : i + k - 1;// 若剩余字符<k 则j指针位于字符串的末尾（将剩余字符全部反转）
        while(i < j){
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
            j--;
        }
    }
    return arr.join("");
};
```







### 回文字符串

判断一个字符串是否回文是必备技能！

回文字符串例子

```js
let str = "gooddoog"
```

- 【1】使用额外的空间存一个新字符串，看看与最开始的是否是同一个

最简单的想法，但是空间复杂度为 O(N)

```js
let newStr = str.split('').reverse().join('');
return newStr === str;
```

- 【重要】【2】利用字符串以中间为轴的对称性，使用双指针

```js
for(let i = 0; i < str.length; i++){
    // 遍历字符串的前半部分，如果与后半部分相同，则满足对称性
    if(str[i] !== str[str.length - i]){
        return false;
    }
}
return true;
```



#### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

这题一个比较重要的点是要做数据预处理，把空格、逗号、冒号啥的都去除XD

```js
s = "I:am:bill, llib ma I";// 这个字符串回文的必要条件是剔除掉空格、特殊符号们
```



- 使用正则表达式进行数据预处理

这种方法一劳永逸，一次性去除特殊字符

```js
let newS = s.toLowerCase().match(/[a-z0-9]+/g);
console.log(newS);// ['i','am', 'bill', 'llib', 'ma', ]
// 使用match方法在字符串内索引指定值/找到一个或多个正则表达式的匹配
// 查找从大写A到小写z的字符，并返回匹配值
```



- 写一个**判断遍历到的字母是否位于 a-z / 0-9 之间** 的函数 进行数据预处理

这种方法要求进行遍历，并在遍历过程中进行调用函数，判断对应字符是否符合要求

另外注意：在JS中进行字符串的比较大小实际上就是比较它们的ASCII码值的大小~如下：

![image-20211024222125820](https://gitee.com/su-fangzhou/blog-image/raw/master/202110242221956.png)

建议搭配双指针使用

```js
function isValid(str){
    return str >= 'a' && str <= 'z' || str >= '0' && str <= '9';
}
// 如果遍历到的字母
```



将数据预处理好了之后，有三种经典的解决方法

![image-20211024214937424](https://gitee.com/su-fangzhou/blog-image/raw/master/202110242149557.png)

是的，就是`reverse、 双指针、栈`三种方法

- 【1】正则匹配 + reverse法

reverse法非常适合与正则表达式搭配对题目进行秒杀

```js
var isPalindrome = function(s) {
    let valid = s.toLowerCase().match(/[a-z0-9]+/g);// valid为进行正则匹配后筛选出来的数组
    if(!valid){
        return true;
    }
    let str = valid.join("");// 数据预处理(正则匹配)后得到的字符串
    let comp = str.split("").reverse().join("");// 将字符串翻转
    return comp === str;
};
```

- 【2】特殊字符处理函数 + 双指针

```js
var isPalindrome = function(s) {
    var str = s.toLowerCase();
    // 定义好一头一尾的双指针
    let i = 0;
    let j = str.length - 1;

    while(i < j){
        // i/j不符合下面的isValid就推动左/右指针 并结束本轮迭代
        if(!isValid(str[i])){
            i++;
            continue;
        }
        if(!isValid(str[j])){
            j--;
            continue;
        }
        if(str[i] !== str[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;
};
var isValid = function(str){
    return (str >= 'a' && str <= 'z') || (str >= '0' && str <= '9');
}
```

- 【3】正则匹配 + 栈

```js
var isPalindrome = function(s) {
    let valid = s.toLowerCase().match(/[a-z0-9]+/g);
    if(!valid){
        return true;
    }
    let str = valid.join("");// 正则匹配过后获得的字符串
    let stack = [];
    
    let mid = str.length >> 1;// 设置中间的位置，入栈至str[mid - 1]再遍历后续内容 并与栈中内容一一比对
    for(let i = 0; i < mid; i++){
        stack.push(str[i]);
    }
    // 入栈完毕，接下来进行比对
    // 额外注意：如果字符串长度为奇数，应该跳过中间的字符进行比对
    if(str.length % 2){
        mid++;
    }
    for(let i = mid; i < str.length; i++){
        let comp = stack.pop();// 将元素一一出栈
        if(comp !== str[i]){
            return false;
        }
    }
    return true;
};
```



#### [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

经典衍生问题

> 本质思想依旧是利用回文字符串的对称性——自然而然地想到了双指针~
>
> 要记住！
>
> - 对称性
> - 双指针
>
> 可以解决大部分回文字符串相关问题！

另外本体需要我们头脑清晰地创建一个**工具方法**——`isPalindrome(s, i, j)` 判断字符串s`从i到j`是否局部回文！

```js
var validPalindrome = function(s) {
    let i = 0;
    let j = s.length - 1;
    while(i < j){
        if(s[i] !== s[j]){
            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);
        }
        i++;
        j--;
    }
    return true;
};
// 判断从i到j的s是否回文！跳过某一项之后局部回文，则整体回文！
// eg: cuppucu 
    // 先判断 uppucu 发现不回文 
    // 再判断 cuppuc 发现回文
var isPalindrome = function(s, i, j){
    while(i < j){
        if(s[i] !== s[j]){
            return false;
        }
        i++;
        j--;
    }
    return true;
}
```



### 实用技巧-正则表达式

#### [【medium】211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)

> 设计题
>
> 

#### [【medium】8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)



# 03 链表

## 【1】链表基础

#### 链表结点的构造函数

```js
function ListNode(val){
    this.val = val;
    this.next = next;
}
// 创建结点node时，传入数据域对应的值val；指定next-下一个链表结点
let head = new ListNode(1);// 头结点，值为1
head.next = new ListNode(2);// 头结点指向的结点，值为2
let dummyHead = new ListNode(0, head);// 虚拟头结点，指向头节点head
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816ad2c296f74df78342093e4d6edcf6~tplv-k3u1fbpfcp-watermark.awebp)



## 【2】链表基础操作【刷题】

数组、字符串若想往难了出，那一定是要结合一些超越数据结构本身的东西——比如排序算法、二分思想、动态规划思想等等

但是链表可不一样了。如果说在命题时，数组和字符串的角色往往是“算法思想的载体”，那么链表本身就可以被认为是“命题的目的”。

结合实际面试中的命题规律，我把这些题目分为以下三类：

- 链表的处理
  - 合并
  - **删除**（重点！）
- 链表的反转 以及 衍生题目
- 链表成环问题 以及 衍生题目

[快速上手——从0到1掌握算法面试需要的数据结构（二）-栈、队列、链表](https://juejin.cn/book/6844733800300150797/section/6844733800342093837)

[链表的应用——真题归纳与解读](https://juejin.cn/book/6844733800300150797/section/6844733800350498823)

### 【1】链表的合并

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)（递归法重要！）

这俩题一样哈——[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

##### 迭代法

```js
var mergeTwoLists = function(l1, l2) {
    let dummyHead = new ListNode(0, l1);
    let cur = dummyHead;
    while(l1 !== null && l2 !== null){
        if(l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        }
        else{
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    cur.next = l1 === null ? l2 : l1;
    return dummyHead.next;
};
```



##### 递归

```js
var mergeTwoLists = function(l1, l2){
    if(l1 === null){
        return l2;// 碰到一个链表走到null 就结束“递” 开始归
    }
    else if(l2 === null){
        return l1;
    }
    else if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next, l2);
    }
    else{
        l2.next = mergeTwoLists(l1, l2.next);
    }
}
```

[递归法图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)

递归就思考第一层第二层最好

每层不要忘了返回当层结果（执行这一次递归函数 返回的结果）！

以原始用例 [1,2] [1,3,4]

【1】**开始“递”** 一直到最里面那一层 

- l1小的时候 l1指向再里层一些的那个递归函数`mergeTwoLists()`别忘了l1要往前挪动一位 `mergeTwoLists(l1.next, l2)`
- l2小的时候同理

![img](https://pic.leetcode-cn.com/fe5eca7edea29a76316f7e8529f73a90ae4990fd66fea093c6ee91567788e482-%E5%B9%BB%E7%81%AF%E7%89%874.JPG)

【2】return l2 执行时

![img](https://pic.leetcode-cn.com/e59fd2981f3633cc70a90bd3136e07647ecf89c6f4eefb82159ea54db9772889-%E5%B9%BB%E7%81%AF%E7%89%875.JPG)

**这里结束了“递”** 

最里面那层的`mergeTwoLists()`执行完了

开始“归” —— 逐步执行外层的`mergeTwoLists()`函数

【3】最外面一层函数执行完 

![img](https://pic.leetcode-cn.com/e95ec0c841cfa308e5789eb1f9f214f785bc77d99214c01504b303939581eb07-%E5%B9%BB%E7%81%AF%E7%89%877.JPG)

就可以返回最终结果了~

![img](https://pic.leetcode-cn.com/c1687ef7811036b7b5e58e4882ed12e243f6a77ddb8077123f013ef094cafd73-%E5%B9%BB%E7%81%AF%E7%89%878.JPG)

小结一下——

- 想一下“哪个是最里层被调用的函数” 在那里返回对应结果
  - 也就是主要想**第一层**

### 【2】链表的删除

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)



```js
var deleteDuplicates = function(head) {
    // 第二次做的反而想得太复杂？不要太想当然！
    // let dummyHead = new ListNode(0, head);
    // let pre = dummyHead;
    let cur = head;
    // if(cur === null){
    //     return null;
    // }
    while(cur !== null && cur.next !== null){
        if(cur.val === cur.next.val){
            cur.next = cur.next.next;
        }
        else{
            cur = cur.next;
        } 
    }
    return head;
};
```



### 【3】链表删除的延伸



#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

但是现在，咱们要做的事情变成了把前驱和后继一起删掉，前面两个值为1的结点要一起狗带才行，起始结点直接变成了第三个：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7079d7513b3e~tplv-t2oaga2asx-watermark.awebp)

如果继续沿用刚才的思路，我们会发现完全走不通。因为我们的 cur 指针就是从图中第一个结点出发开始遍历的，无法定位到第一个结点的前驱结点，删除便无法完成。

> 虚拟头结点应用场景：

其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 `dummy` 结点来解决这个问题。

> 本题思路

如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e7116f49a1dc4~tplv-t2oaga2asx-watermark.awebp)

如此一来，就大功告成啦~

注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。

```js
const deleteDuplicates = function(head) {
    // 极端情况：0个或1个结点，则不会重复，直接返回
    if(!head || !head.next) {
        return head
    }
    // dummy 登场
    let dummy = new ListNode() 
    // dummy 永远指向头结点
    dummy.next = head   
    // cur 从 dummy 开始遍历
    let cur = dummy 
    // 当 cur 的后面有至少两个结点时
    while(cur.next && cur.next.next) {
        // 对 cur 后面的两个结点进行比较
        if(cur.next.val === cur.next.next.val) {
            // 若值重复，则记下这个值
            let val = cur.next.val
            // 反复地排查后面的元素是否存在多次重复该值的情况
            while(cur.next && cur.next.val===val) {
                // 若有，则删除
                cur.next = cur.next.next 
            }
        } else {
            // 若不重复，则正常遍历
            cur = cur.next
        }
    }
    // 返回链表的起始结点
    return dummy.next;
};
```



### 【4】双指针的妙用

#### [【medium】29.删除链表的倒数第 N 个结点](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fremove-nth-node-from-end-of-list%2F)



#### [206.反转链表](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-linked-list%2F)



#### [【medium】92.反转链表 II](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Freverse-linked-list-ii%2F)

> 好题！局部反转！
>
> 要点：保存断开连接的边缘，用于连接反转过后得到的头节点

```js
var reverseBetween = function(head, left, right) {
    let dummy = new ListNode(0,head);
    let p = dummy;// 用于遍历
    for(let i = 0; i < left - 1; i++){
        p = p.next;
    }
    let leftHead = p;// 保存断开的边缘
    let start = leftHead.next;// 保存开始反转的边界
    // 设置双指针
    let pre = start;
    let cur = pre.next;
    for(let j = left; j < right; j++){
        // 反转局部链表
        let temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    leftHead.next = pre;// 连接最开始(断链的边缘)和局部反转链表反转过后得到的头节点
    start.next = cur;// 连接反转后的链表和后面那段链表
    return dummy.next;
};
```







### 【5】经典环形链表问题

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)





#### [【medium】142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> 超级经典的面试题，尽量对其中的数学原理多了解些！面试时候可以说出点东西最好！
>
> 我写的[题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/javascript-ba-zhong-deng-nan-du-zuo-chen-j8en/)
>
> 推荐看的[图文并茂的题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)（当时我就是看这个懂的！）

```js
var detectCycle = function(head) {
    let slow = head;
    let fast = head;
    // 01 让两个指针第一次相交 此时slow指针走了n*b步
    while(true){
        if(fast === null || fast.next === null){
            return null;
        }
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){
            break;
        }
    }
    // 02 换新的结点从头结点开始丈量a步 保证slow指针一共走了a+n*b步
    let newFast = head;
    while(slow !== newFast){
        newFast = newFast.next;
        slow = slow.next;
    }
    // 03 返回slow指向的结点 一定刚好走完一整圈
    return slow;
}
```





















# 04 二叉树

- [ ] DFS&BFS 
- [ ] 基本的递归操作
- [ ] 回溯思想的运用
- [ ] 二叉搜索树
- [ ] 平衡二叉树
- [ ] 简单的堆问题-堆的建立&堆排序





















































# 05 栈与队列

- [x] 经典：用栈实现队列
- [ ] 一些骚操作待学习…



### 【1】栈的设计

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)



#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)



### 【2】使用到栈的经典题型

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

很经典(且面试高频)的题！重点是要联想到**使用栈辅助**解题！

```js
var isValid = function(s) {
    let arr = s.split("");
    // 利用Map对象创建哈希表~
    const map = new Map([        
        ["(",")"],
        ["{","}"],
        ["[","]"]
    ])

    let stack = [];
    // 遍历数组并 对栈进行填充 + 将没资格入栈的元素与栈顶元素比较（别忘了出栈~）
    for(let item of arr){
        if(map.has(item)){
            stack.push(item);
        }
        else{
            let temp = stack.pop();
            console.log(temp,item)
            if(map.get(temp) !== item){
                return false;
            }
        }
    }
    return !stack.length;
    // 只要栈里没有元素了 可以返回true，
    // 但别忘了如果栈中还有元素说明右侧的括号并没有成功匹配哦！
};
```



#### [【medium】739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

![image-20211028220101210](https://gitee.com/su-fangzhou/blog-image/raw/master/202110282201314.png)

> 本题可以用暴力两层循环去写，但是这样写会造成重复操作
>
> **栈结构可以帮我们避免重复操作**。
>
> > 及时将**不必要的数据出栈**，避免它对我们后续的遍历产生干扰即可！

- **单调栈**的思想！单调栈的特点如下：
  - 存储下标
  - 从栈底到栈顶的下标对应着的温度依次**降低**！
    - 一旦出现一个不符合这个规律的（`temperatures[i] > temperatures[stack[stack.length - 1]]`）就将下标出栈并得到答案！

```js
// 入参是温度数组
const dailyTemperatures = function(T) {
    const len = T.length // 缓存数组的长度 
    const stack = [] // 初始化一个栈   
    const res = (new Array(len)).fill(0) //  初始化结果数组，注意数组定长，占位为0
    for(let i=0;i<len;i++) {
      // 若栈不为0，且存在打破递减趋势的温度值
      while(stack.length && T[i] > T[stack[stack.length-1]]) {
        // 将栈顶温度值对应的索引出栈
        const top = stack.pop()  
        // 计算 当前栈顶温度值与第一个高于它的温度值 的索引差值
        res[top] = i - top 
      }
      // 注意栈里存的不是温度值，而是索引值，这是为了后面方便计算
      stack.push(i)
    }
    // 返回结果数组
    return res 
};

```







### 【3】使用栈设计队列





### 【4】双端队列衍生出的滑窗问题























# 解题技巧

# 01 双指针

- [x] 同向而行快慢指针（常用于链表）
- [x] 反向而行双指针（对撞指针，常用于数组）

## 【1】链表中的双指针

【medium】[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

【easy】[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

【medium】[92.反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)



## 【2】数组中的双指针-求和、比大小

> 前提为：数组有序——以便双指针帮助我们缩小定位的范围。
>

【easy】[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

【medium】[15. 三数之和](https://leetcode-cn.com/problems/3sum/)



# 02 哈希表

















# 03 递归

- [x] 递归的基本原理  [掌握递归调用栈思想 由浅入深研究递归🎉](https://juejin.cn/post/7016324095843237901)
- [x] 树的前中后序遍历
- [ ] 数组、链表等题目中的递归骚操作

[掌握递归调用栈思想 由浅入深研究递归🎉](https://juejin.cn/post/7016324095843237901)















# 04 回溯











# 05 排序问题





# 06 动态规划





# 07 前缀和

