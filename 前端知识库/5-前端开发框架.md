> 日后工作中一直要接触的内容 入行的标准🧑‍💻

# React

参考学习资源

- [阮大的 React入门实例教程](https://www.ruanyifeng.com/blog/2015/03/react.html)
- [React官网基础教程](https://react.docschina.org/docs/hello-world.html)
- B站尚硅谷课程

## React基础知识

#### HTML模板

> ```jsx
> <!DOCTYPE html>
> <html>
>   <head>
>     <script src="../build/react.js"></script>
>     <script src="../build/react-dom.js"></script>
>     <script src="../build/browser.min.js"></script>
>   </head>
>   <body>
>     <div id="example"></div>
>     <script type="text/babel">
>       // ** Our code goes here! **
>     </script>
>   </body>
> </html>
> ```

 `<script>` 标签的 `type` 属性为 `text/babel` 。

这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 `type="text/babel"` 。

上面代码一共用了三个库： `react.js` 、`react-dom.js` 和 `Browser.js` ，它们必须首先加载。其中

- `react.js` 是 React 的核心库
- `react-dom.js` 是提供与 DOM 相关的功能
- `Browser.js` 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。

#### `ReactDOM.render()`

`ReactDOM.render` 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。

> ```jsx
> ReactDOM.render(
>   <h1>Hello, world!</h1>,
>   document.getElementById('example')
> );
> ```

上面代码将一个 `h1` 标题，插入 `example` 节点（查看 [`demo01`](https://github.com/ruanyf/react-demos/blob/master/demo01/index.html)），运行结果如下。

![img](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015033109.png)



## JSX

#### JSX语法

HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 [JSX 的语法](https://facebook.github.io/react/docs/displaying-data.html#jsx-syntax)，它允许 HTML 与 JavaScript 的混写（查看 [`Demo02`](https://github.com/ruanyf/react-demos/blob/master/demo02/index.html) ）。

> 旧版本
>
> ```jsx
> var names = ['Alice', 'Emily', 'Kate'];
> 
> ReactDOM.render(
>   <div>
>   {
>     names.map(function (name) {
>       return <div>Hello, {name}!</div>
>     })
>   }
>   </div>,
>   document.getElementById('example')
> );
> ```

> 新版本
>
> 涉及了key的内容
>
> > 需要注意！如果涉及到遍历列表的需求，key最好不要用index！
> >
> > ![image-20211026114735118](https://gitee.com/su-fangzhou/blog-image/raw/master/202110261147195.png)
> >
> > ![image-20211026114801860](https://gitee.com/su-fangzhou/blog-image/raw/master/202110261148929.png)
> >
> > 小结：如果不存在对数据的逆序添加、逆序删除，仅仅是为了渲染列表用于展示，那就可以使用index作为key
> >
> > ![image-20211026114904827](https://gitee.com/su-fangzhou/blog-image/raw/master/202110261149879.png)
>
> > 开发中如何选取key？
> >
> > 有唯一标识尽量还是用唯一标识！
> >
> > ![image-20211026115023933](https://gitee.com/su-fangzhou/blog-image/raw/master/202110261150005.png)
>
> ```jsx
> ReactDOM.render(
>   <div>
>   {
>     names.map(function (name, index) {
>       return <div key={index}>Hello, {name}!</div>
>     })
>   }
>   </div>,
>   document.getElementById('example')
> );
> ```

上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 `<` 开头），就用 HTML 规则解析；遇到代码块（以 `{` 开头），就用 JavaScript 规则解析。

![img](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015033106.png)

#### JSX中会展开数组

JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员（查看 [`demo03`](https://github.com/ruanyf/react-demos/blob/master/demo03/index.html) ）。

> ```javascript
> var arr = [
>   <h1>Hello world!</h1>,
>   <h2>React is awesome</h2>,
> ];
> ReactDOM.render(
>   <div>{arr}</div>,
>   document.getElementById('example')
> );
> ```

上面代码的`arr`变量是一个数组，结果 JSX 会把它的所有成员，添加到模板。

![img](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015033107.png)

## 组件

#### “组件类”

React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。`React.createClass` 方法就用于生成一个组件类（查看 [`demo04`](https://github.com/ruanyf/react-demos/blob/master/demo04/index.html)）。

> 旧版本
>
> ```jsx
> var HelloMessage = React.createClass({
>   render: function() {
>     return <h1>Hello {this.props.name}</h1>;
>   }
> });
> 
> ReactDOM.render(
>   <HelloMessage name="John" />,
>   document.getElementById('example')
> );
> ```

> 新版本
>
> ```jsx
> class HelloMessage extends React.Component{
>     render(){
>         return <h1>Hello {this.props.name}</h1>;
>     }
> }
> ```
>
> 组件“类”

上面代码中，变量 `HelloMessage` 就是一个组件类。模板插入 `<HelloMessage />` 时，会自动生成 `HelloMessage` 的一个实例（下文的"组件"都指组件类的实例）

> “自动生成组件类的一个实例”这个概念好像之前没听见过！学习了！

#### 组件类使用render方法输出组件

所有组件类都必须有自己的 `render` 方法，用于输出组件。

注意，组件类的第一个字母必须大写，否则会报错，比如`HelloMessage`不能写成`helloMessage`。

> 另外，组件类只能包含一个顶层标签，否则也会报错。
>
> > ```jsx
> > var HelloMessage = React.createClass({
> >   render: function() {
> >     return <h1>
> >       Hello {this.props.name}
> >     </h1><p>
> >       some text
> >     </p>;
> >   }
> > });
> > ```
>
> 上面代码会报错，因为`HelloMessage`组件包含了两个顶层标签：`h1`和`p`。

#### 组件实例从组件类的`this.props`对象获取属性

组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 `<HelloMessage name="John">` ，就是 `HelloMessage` 组件加入一个 `name` 属性，值为 `John`。组件的属性可以**在组件类的 `this.props` 对象上获取**，比如 `name` 属性就可以通过 `this.props.name` 读取。

#### 组件属性名的注意点

添加组件属性，有一个地方需要注意，就是 `class` 属性需要写成 `className` ，`for` 属性需要写成 `htmlFor` ，这是因为 `class` 和 `for` 是 JavaScript 的保留字。

## Props

#### `this.props.children`-组件所有子节点

`this.props` 对象的属性与组件的属性一一对应，但是有一个例外，就是 `this.props.children` 属性。它表示组件的所有子节点（查看 [`demo05`](https://github.com/ruanyf/react-demos/blob/master/demo05/index.html)）。

> 旧版本
>
> ```jsx
> var NotesList = React.createClass({
>   render: function() {
>     return (
>       <ol>
>       {
>         React.Children.map(this.props.children, function (child) {
>           return <li>{child}</li>;
>         })
>       }
>       </ol>
>     );
>   }
> });
> 
> ReactDOM.render(
>   <NotesList>
>     <span>hello</span>
>     <span>world</span>
>   </NotesList>,
>   document.body
> );
> ```

> 新版本
>
> ```jsx
> class NotesList extends React.Component{
>     render(){
>         return (
>         	<ol>
>             	{
>                     React.Children.map(this.props.children, function(child){
>                         return <li>{child}</li>
>                     })
>                 }
>             </ol>
>         )
>     }
> }
> ```



上面代码的 `NoteList` 组件有两个 `span` 子节点，它们都可以通过 `this.props.children` 读取，运行结果如下。

![img](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015033110.png)

#### 用`React.Children.map`遍历子节点

这里需要注意， `this.props.children` 的值有三种可能：

- 如果当前组件没有子节点，它就是 `undefined` ;
- 如果有一个子节点，数据类型是 `object` ；
- 如果有多个子节点，数据类型就是 `array` 。

所以，处理 `this.props.children` 的时候要小心。

React 提供一个工具方法 [`React.Children-中文文档`](https://zh-hans.reactjs.org/docs/react-api.html#reactchildren) 来处理 `this.props.children` 。我们可以用 `React.Children.map` 来遍历子节点，而不用担心 `this.props.children` 的数据类型是 `undefined` 还是 `object`。更多的 `React.Children` 的方法，请参考[官方文档-英文原版](https://reactjs.org/docs/react-api.html#reactchildren)。



#### `PropTypes`-验证使用组件时提供的参数是否符合要求

> 老版本中阮大使用 `const Com React.createClass`创建组件，与我之前学到的（更接近ES6规范的class写法）`class Com extends React.Component` 不太一样，且一些地方的用法也不同
>
> 可以看看[这篇文章](https://www.cnblogs.com/fightjianxian/p/12350499.html)所阐述的这两者之间的区别
>
> ```jsx
>     1、语法区别
>     2、propType 和 getDefaultProps
>     3、状态的区别
>     4、this区别
>     5、Mixins
> ```

组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。

组件类的`PropTypes`属性，就是用来验证组件实例的属性是否符合要求（查看 [`demo06`](https://github.com/ruanyf/react-demos/blob/master/demo06/index.html)）。

> 老版本
>
> 通过`proTypes`对象和`getDefaultProps()`方法来设置和获取`props`.
>
> ```jsx
> var MyTitle = React.createClass({
>     propTypes: {
>         title:React.PropTypes.string.isRequired,
>     },
>     render: function(){
>         return <h1>{this.props.title}</h1>
>     }
> })
> ```

> 新版本
>
> 通过设置两个属性`propTypes`和`defaultProps`
>
> ```jsx
> class MyTitle extends React.Component{
>     //  改为属性
>     static propTypes = {
>         title: PropType.string.isRequired,
>     }
> 	render(){
>         return <h1> {this.props.title} </h1>;
>     }
> }
> ```
>
> 

上面的`Mytitle`组件有一个`title`属性。`PropTypes` 告诉 React，这个 `title` 属性是必须的，**而且它的值必须是字符串**。

举个反例来测试下

设置 `title` 属性的值是一个数值。

> ```jsx
> var data = 123;
> 
> ReactDOM.render(
>   <MyTitle title={data} />,
>   document.body
> );
> ```

这样一来，`title`属性就通不过验证了。控制台会显示一行错误信息。

> ```bash
> Warning: Failed propType: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`.
> ```

更多的`PropTypes`设置，可以查看[官方文档](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper)。



> [之前在fcc中学习到的 定义Props类型](https://chinese.freecodecamp.org/learn/front-end-development-libraries/react/use-proptypes-to-define-the-props-you-expect)是在组件类之外
>
> 上面学习到的直接在组件类里面定义也很是简单！
>
> ```js
> class ShoppingCart extends React.Component {
>     constructor(porps){
>         super(props);
>     }
>     render(){
>         return <Items />
>     }
> }
> const Items = (porps) => {
>     return <h1>Current Quantity of Items in Cart:{props.quantity}</h1>
> }
> // 这里定义 propTypes 属性 验证组件是否接收了正确类型的 props
> Items.propTypes = {quantity:PropTypes.number.isRequired};
> ```

#### `getDefaultProps`-设置组件属性的默认值



> 旧版本
>
> ```jsx
> var MyTitle = React.createClass({
>   getDefaultProps : function () {
>     return {
>       title : 'Hello World'
>     };
>   },
> 
>   render: function() {
>      return <h1> {this.props.title} </h1>;
>    }
> });
> 
> ReactDOM.render(
>   <MyTitle />,
>   document.body
> );
> ```

> 新版本
>
> ```jsx
> class MyTitle extends React.Component{
>     static defaultProps = { 
>         // as static property
>         title: 'Hello World'
>     };
>     render(){
>         return <h1>{this.props.title}</h1>
>     }
> }
> ```

上面代码会输出"Hello World"。

## State

#### 组件与用户的互动-`this.state`

React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI （查看 [`demo08`](https://github.com/ruanyf/react-demos/blob/master/demo08/index.html) ）。

> 旧版本
>
> ```jsx
> var LikeButton = React.createClass({
>   /*getInitialState: function() {
>     return {liked: false};
>   },*/
>   handleClick: function(event) {
>     this.setState({liked: !this.state.liked});
>   },
>   render: function() {
>     var text = this.state.liked ? 'like' : 'haven\'t liked';
>     return (
>       <p onClick={this.handleClick}>
>         You {text} this. Click to toggle.
>       </p>
>     );
>   }
> });
> 
> ReactDOM.render(
>   <LikeButton />,
>   document.getElementById('example')
> );
> ```

> 新版本
>
> ```jsx
> class LikeButton extends React.Component{
>     /*constructor(props){
>         super(props);
>         this.state = {
>             liked : false
>         }
>         this.handleClick = this.handleClick.bind(this);// 时刻记住要绑定这个方法
>     }*/
>     handleClick(event){
>         this.setState({
>             liked: !this.state.liked;
>         })
>     }
>     render(){
> 		var text = this.state.liked ? 'like' : 'haven\'t liked';
>         return(
>             <p onClick={this.handleClick}>
>         		You {text} this.Click to toggle
>         	</p>
>         )
>     }
> }
> ```



上面代码是一个 `LikeButton` 组件，

> 它的 `getInitialState` 方法用于定义——
>
> - 初始状态state(**新版本中使用构造函数来定义state**)，也就是**一个对象**，这个对象<u>可以通过 `this.state` 属性读取</u>。

当用户点击组件，导致状态变化，`this.setState` 方法就修改状态值，每次修改以后，**自动调用 `this.render` 方法**，再次渲染组件。

#### 区分props与state

由于 `this.props` 和 `this.state` 都用于描述组件的特性，可能会产生混淆。

一个简单的区分方法是：

- `this.props` 表示那些一旦定义，就不再改变的特性
- 而 `this.state` 是会随着用户互动而产生变化的特性。

[官方文档](https://react.docschina.org/docs/faq-state.html#what-is-the-difference-between-state-and-props)是这么说的：

> props（“properties” 的缩写）和 state 都是**普通的 JavaScript 对象**。
> 它们都是**用来保存信息**的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：
>
> - props 是**传递给组件**的（类似于函数的形参）
> - 而 state 是**在组件内被组件自己管理的**（类似于在一个函数内声明的变量）

> 官方推荐阅读材料
>
> - [Props vs State](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)
> - [ReactJS: Props vs. State](https://lucybain.com/blog/2016/react-state-vs-pros/)

## [Refs](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html)

Refs 提供了一种方式，允许我们**访问 DOM 节点或在 render 方法中创建的 React 元素**。

在典型的 React 数据流中，[props](https://zh-hans.reactjs.org/docs/components-and-props.html) 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。

但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。

#### 何时使用 Refs

下面是几个适合使用 refs 的情况：

- 管理焦点，文本选择或媒体播放。
- 触发强制动画。
- 集成第三方 DOM 库。

避免使用 refs 来做任何可以通过声明式实现来完成的事情。

举个例子，避免在 `Dialog` 组件里暴露 `open()` 和 `close()` 方法，最好传递 `isOpen` 属性。

#### 勿过度使用 Refs

你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 [状态提升](https://zh-hans.reactjs.org/docs/lifting-state-up.html) 以获取更多有关示例。

#### 实例-创建 Refs

Refs 是使用 `React.createRef()` 创建的，并通过 `ref` 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();  }
  render() {
    return <div ref={this.myRef} />;  }
}
```

#### 访问 Refs

当 ref 被传递给 `render` 中的元素时，<u>对该节点的引用可以在 ref 的 `current` 属性中被访问。</u>

```jsx
const node = this.myRef.current;
```

ref 的值根据节点的类型而有所不同：

- 当 `ref` 属性用于 HTML 元素时，构造函数中使用 `React.createRef()` 创建的 `ref` 接收底层 DOM 元素作为其 `current` 属性。
- 当 `ref` 属性用于自定义 class 组件时，`ref` 对象接收组件的挂载实例作为其 `current` 属性。
- **你不能在函数组件上使用 `ref` 属性**，因为他们没有实例。

#### 实例-将虚拟DOM插入文档，获取真实DOM

组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。

根据 React 的设计，**所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上**，这种算法叫做 [DOM diff](https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm) ，它可以极大提高网页的性能表现。

但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 `ref` 属性（查看 [demo07](https://github.com/ruanyf/react-demos/blob/master/demo07/index.html) ）。

> 旧版本
>
> ```jsx
> var MyComponent = React.createClass({
>     handleClick: function(){
>         this.refs.myTextInput.focus();
>     }
>     render: function() {
>     	return (
>           <div>
>             <input type="text" ref="myTextInput" />
>             <input type="button" value="Focus the text input" onClick={this.handleClick} />
>           </div>
>         );
>       }
> })
> ```
>
> 需要注意，本例中提到的[字符型的ref属性已经过时了](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs)！（主要是因为效率不高+存在[一些问题](https://github.com/facebook/react/pull/8333#issuecomment-271648615)）
>
> 不过用这个的程序员可能还挺多 因为比较简单省事儿~
>
> 严谨起见，建议使用下面新版本中的[回调函数方式](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#caveats-with-callback-refs)！

> [新版本](https://github.com/ruanyf/react-demos/blob/master/demo07/index.html)
>
> 使用了[`React.createRef`](https://zh-hans.reactjs.org/docs/react-api.html#reactcreateref)，创建一个能够通过ref属性附加到 React 元素的 [ref](https://zh-hans.reactjs.org/docs/refs-and-the-dom.html)。
>
> ```jsx
> class MyComponent extends React.Component{
>     constructor(props){
>         super(props);
>         this.myTextInput = React.createRef();// myTextInput就是创建的Refs
>         this.handleClick = this.handleClick.bind(this);// 绑定点击事件
>     }
>     handleClick(){
>         //  点击事件的回调函数，作用：在点击按钮之后对“render中的元素”进行聚焦
>         this.myTextInput.current.focus();
>     }
>     render(){
>         return(
>             <div>
>                 {/* 将ref传给render中的元素，对该节点（input输入框）的引用可以在ref的current属性中访问！见上面第9行的代码 */}
>                 <input type="text" ref={this.myTextInput} /> 
>                 <input type="button" value="Focus te text input" onClick={this.handleClick} />
>             </div>
>         )
>     }
>     
> }
> ```

上面代码中，组件 `MyComponent` 的子节点有一个文本输入框，用于获取用户的输入。这时就必须**获取真实的 DOM 节点**，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 `ref` 属性，然后 `this.refs.[refName]` 就会返回这个真实的 DOM 节点。

![image-20211026114118072](https://gitee.com/su-fangzhou/blog-image/raw/master/202110261141127.png)

> 需要注意的是，由于 `this.refs.[refName]` 属性**获取的是真实 DOM** ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。
>
> 上面代码中，通过为组件指定 `Click` 事件的回调函数，确保了只有等到真实 DOM 发生 `Click` 事件之后，才会读取 `this.refs.[refName]` 属性。
>
> React 组件支持很多事件，除了 `Click` 事件以外，还有 `KeyDown` 、`Copy`、`Scroll` 等，完整的事件清单请查看[官方文档](https://facebook.github.io/react/docs/events.html#supported-events)。



## 表单



## 虚拟DOM与DOM Diffing算法

[Diffing 算法](https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm)



## 组件生命周期





## AJAX